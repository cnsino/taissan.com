<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Rust Cookbook系列】十九 Web 编程</title>
      <link href="/news/1682928435899.html"/>
      <url>/news/1682928435899.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-提取链接">1. 提取链接</h2><p>  需要安装<code>error-chain</code>库、<code>reqwest</code>库、<code>select</code>库、<code>url</code>库以及<code>tokio</code>库，可通过以下命令安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo add error_chain</span><br><span class="line">cargo add select</span><br><span class="line">cargo add tokio --features full</span><br><span class="line">cargo add reqwest</span><br><span class="line">cargo add url</span><br></pre></td></tr></table></figure><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br><span class="line"><span class="attr">reqwest</span> = <span class="string">&quot;0.11.17&quot;</span></span><br><span class="line"><span class="attr">select</span> = <span class="string">&quot;0.6.0&quot;</span></span><br><span class="line"><span class="attr">tokio</span> = &#123; version = <span class="string">&quot;1.28.0&quot;</span>, features = [<span class="string">&quot;full&quot;</span>] &#125;</span><br><span class="line"><span class="attr">url</span> = <span class="string">&quot;2.3.1&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-1-从-HTML-网页中提取所有链接">1.1 从 HTML 网页中提取所有链接</h3><p>  使用 <code>reqwest::get</code> 执行 <code>HTTP GET</code> 请求，然后使用 <code>Document::from_read</code> 将响应信息解析为 <code>HTML</code> 文档。以“<code>a</code>”（锚元素）作为结构体 <code>Name</code> 的参数，将结构体 <code>Name</code> 作为条件，使用 <code>find</code> 方法检索所有链接。在结构体 <code>Selection</code> 上调用 <code>filter_map</code> 方法，从具有 “<code>href</code>” attr（属性）的链接检索所有 <code>URL</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> select::document::Document;</span><br><span class="line"><span class="keyword">use</span> select::predicate::Name;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">      foreign_links &#123;</span><br><span class="line">          <span class="title function_ invoke__">ReqError</span>(reqwest::Error);</span><br><span class="line">          <span class="title function_ invoke__">IoError</span>(std::io::Error);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::<span class="title function_ invoke__">get</span>(<span class="string">&quot;https://www.rust-lang.org/en-US/&quot;</span>)</span><br><span class="line">        .<span class="keyword">await</span>?</span><br><span class="line">        .<span class="title function_ invoke__">text</span>()</span><br><span class="line">        .<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    Document::<span class="title function_ invoke__">from</span>(res.<span class="title function_ invoke__">as_str</span>())</span><br><span class="line">        .<span class="title function_ invoke__">find</span>(<span class="title function_ invoke__">Name</span>(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|n| n.<span class="title function_ invoke__">attr</span>(<span class="string">&quot;href&quot;</span>))</span><br><span class="line">        .<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x));</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line">/tools/install</span><br><span class="line">/learn</span><br><span class="line">... <span class="comment"># 省略</span></span><br><span class="line">https://github.com/rust-lang/www.rust-lang.org/issues/new/choose</span><br><span class="line">https://prev.rust-lang.org</span><br></pre></td></tr></table></figure><h3 id="1-2-检查网页死链">1.2 检查网页死链</h3><p>  调用 <code>get_base_url</code> 方法检索 <code>base URL</code>，如果 <code>HTML</code> 文档有 <code>base</code> 标签，从 <code>base</code> 标记获取 <code>href attr</code>，初始 URL 的默认值是 <code>Position::BeforePath</code>。遍历 <code>HTML</code> 文档中的链接，并创建一个 <code>tokio::spawn</code> 任务，该任务将使用 <code>url::ParseOptions</code> 结构体和 <code>Url::parse</code> 方法解析单个链接。任务执行中，使用 <code>reqwest</code> 向链接发起请求，并验证状态码结构体 <code>StatusCode</code>。实例中使用 <code>await</code> 异步等待任务完成，然后结束程序。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> reqwest::StatusCode;</span><br><span class="line"><span class="keyword">use</span> select::document::Document;</span><br><span class="line"><span class="keyword">use</span> select::predicate::Name;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"><span class="keyword">use</span> url::&#123;Position, Url&#125;;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">  foreign_links &#123;</span><br><span class="line">      <span class="title function_ invoke__">ReqError</span>(reqwest::Error);</span><br><span class="line">      <span class="title function_ invoke__">IoError</span>(std::io::Error);</span><br><span class="line">      <span class="title function_ invoke__">UrlParseError</span>(url::ParseError);</span><br><span class="line">      <span class="title function_ invoke__">JoinError</span>(tokio::task::JoinError);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">get_base_url</span>(url: &amp;Url, doc: &amp;Document) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Url&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">base_tag_href</span> = doc.<span class="title function_ invoke__">find</span>(<span class="title function_ invoke__">Name</span>(<span class="string">&quot;base&quot;</span>)).<span class="title function_ invoke__">filter_map</span>(|n| n.<span class="title function_ invoke__">attr</span>(<span class="string">&quot;href&quot;</span>)).<span class="title function_ invoke__">nth</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">base_url</span> =</span><br><span class="line">        base_tag_href.<span class="title function_ invoke__">map_or_else</span>(|| Url::<span class="title function_ invoke__">parse</span>(&amp;url[..Position::BeforePath]), Url::parse)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(base_url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">check_link</span>(url: &amp;Url) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::<span class="title function_ invoke__">get</span>(url.<span class="title function_ invoke__">as_ref</span>()).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(res.<span class="title function_ invoke__">status</span>() != StatusCode::NOT_FOUND)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = Url::<span class="title function_ invoke__">parse</span>(<span class="string">&quot;https://www.taissan.com/&quot;</span>)?; <span class="comment">// 原文提供的Rust官网地址无死链，此处特别修改</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::<span class="title function_ invoke__">get</span>(url.<span class="title function_ invoke__">as_ref</span>()).<span class="keyword">await</span>?.<span class="title function_ invoke__">text</span>().<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">document</span> = Document::<span class="title function_ invoke__">from</span>(res.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">base_url</span> = <span class="title function_ invoke__">get_base_url</span>(&amp;url, &amp;document).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">base_parser</span> = Url::<span class="title function_ invoke__">options</span>().<span class="title function_ invoke__">base_url</span>(<span class="title function_ invoke__">Some</span>(&amp;base_url));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">links</span>: HashSet&lt;Url&gt; = document</span><br><span class="line">        .<span class="title function_ invoke__">find</span>(<span class="title function_ invoke__">Name</span>(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|n| n.<span class="title function_ invoke__">attr</span>(<span class="string">&quot;href&quot;</span>))</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|link| !link.<span class="title function_ invoke__">starts_with</span>(<span class="string">&quot;javascript:void(0);&quot;</span>)) <span class="comment">// 特别添加</span></span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|link| base_parser.<span class="title function_ invoke__">parse</span>(link).<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tasks</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">link</span> <span class="keyword">in</span> links &#123;</span><br><span class="line">        tasks.<span class="title function_ invoke__">push</span>(tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="title function_ invoke__">check_link</span>(&amp;link).<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 正常&quot;</span>, link);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 是死链&quot;</span>, link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">task</span> <span class="keyword">in</span> tasks &#123;</span><br><span class="line">        task.<span class="keyword">await</span>?</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://www.taissan.com/tags/minikube/ 正常</span><br><span class="line">https://www.taissan.com/music/ 是死链</span><br><span class="line">https://www.taissan.com/movies/ 是死链</span><br><span class="line">https://www.sino-lang.org/ 正常</span><br><span class="line">https://www.taissan.com/tags/python/ 正常</span><br><span class="line">... <span class="comment"># 省略</span></span><br></pre></td></tr></table></figure><h3 id="1-3-从-WikiPedia-标记页面提取所有唯一性链接">1.3 从 <code>WikiPedia</code> 标记页面提取所有唯一性链接</h3><p>  需要安装<code>regex</code>库和<code>lazy_static</code>库，可通过<code>cargo add regex</code>、<code>cargo add lazy_static</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br><span class="line"><span class="attr">lazy_static</span> = <span class="string">&quot;1.4.0&quot;</span></span><br><span class="line"><span class="attr">regex</span> = <span class="string">&quot;1.8.1&quot;</span></span><br><span class="line"><span class="attr">reqwest</span> = &#123; version = <span class="string">&quot;0.11.17&quot;</span>, features = [<span class="string">&quot;json&quot;</span>] &#125;</span><br><span class="line"><span class="attr">select</span> = <span class="string">&quot;0.6.0&quot;</span></span><br><span class="line"><span class="attr">tokio</span> = &#123; version = <span class="string">&quot;1.28.0&quot;</span>, features = [<span class="string">&quot;full&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><p>  使用 <code>reqwest::get</code> 获取 <code>MediaWiki</code> 页面的源代码，然后使用 <code>Regex::captures_iter</code> 查找内部和外部链接的所有条目。使用智能指针 <code>Cow</code> 可以提供对借用数据的不可变引用，避免分配过多的字符串。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> regex::Regex;</span><br><span class="line"><span class="keyword">use</span> std::borrow::Cow;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">extract_links</span>(content: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> HashSet&lt;Cow&lt;<span class="type">str</span>&gt;&gt; &#123;</span><br><span class="line">    lazy_static! &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">ref</span> WIKI_REGEX: Regex = Regex::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            <span class="string">r&quot;(?x)</span></span><br><span class="line"><span class="string">                \[\[(?P&lt;internal&gt;[^\[\]|]*)[^\[\]]*\]\]    # internal links</span></span><br><span class="line"><span class="string">                |</span></span><br><span class="line"><span class="string">                (url=|URL\||\[)(?P&lt;external&gt;http.*?)[ \|&#125;] # external links</span></span><br><span class="line"><span class="string">            &quot;</span></span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">links</span>: HashSet&lt;_&gt; = WIKI_REGEX</span><br><span class="line">        .<span class="title function_ invoke__">captures_iter</span>(content)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|c| <span class="title function_ invoke__">match</span> (c.<span class="title function_ invoke__">name</span>(<span class="string">&quot;internal&quot;</span>), c.<span class="title function_ invoke__">name</span>(<span class="string">&quot;external&quot;</span>)) &#123;</span><br><span class="line">            (<span class="title function_ invoke__">Some</span>(val), <span class="literal">None</span>) =&gt; Cow::<span class="title function_ invoke__">from</span>(val.<span class="title function_ invoke__">as_str</span>().<span class="title function_ invoke__">to_lowercase</span>()),</span><br><span class="line">            (<span class="literal">None</span>, <span class="title function_ invoke__">Some</span>(val)) =&gt; Cow::<span class="title function_ invoke__">from</span>(val.<span class="title function_ invoke__">as_str</span>()),</span><br><span class="line">            _ =&gt; <span class="built_in">unreachable!</span>(),</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    links</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = reqwest::<span class="title function_ invoke__">get</span>(</span><br><span class="line">        <span class="string">&quot;https://en.wikipedia.org/w/index.php?title=Rust_(programming_language)&amp;action=raw&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    .<span class="keyword">await</span>?</span><br><span class="line">    .<span class="title function_ invoke__">text</span>()</span><br><span class="line">    .<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, <span class="title function_ invoke__">extract_links</span>(content.<span class="title function_ invoke__">as_str</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;firewall (computing)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;conditional (computer programming)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;algebraic data types&quot;</span>,</span><br><span class="line">    ... <span class="comment"># 此处省略</span></span><br><span class="line">    <span class="string">&quot;affine type system&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reserved word&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-URL">2. <code>URL</code></h2><h3 id="2-1-解析-URL-字符串为-Url-类型">2.1 解析 <code>URL</code> 字符串为 <code>Url</code> 类型</h3><p>  <code>url</code> crate 中的 <code>parse</code> 方法验证并解析 <code>&amp;str</code> 切片为 <code>Url</code> 结构体。如果输入字符串的格式不正确，解析方法 <code>parse</code> 会返回 <code>Result&lt;Url, ParseError&gt;</code>。一旦 <code>URL</code> 被解析，它就可以使用 <code>Url</code> 结构体类型中的所有方法。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> url::&#123;ParseError, Url&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), ParseError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed</span> = Url::<span class="title function_ invoke__">parse</span>(s)?;</span><br><span class="line">    <span class="comment">// Url &#123; scheme: &quot;https&quot;, cannot_be_a_base: false, username: &quot;&quot;, password: None, host: Some(Domain(&quot;github.com&quot;)), port: None, path: &quot;/rust-lang/rust/issues&quot;, query: Some(&quot;labels=E-easy&amp;state=open&quot;), fragment: None &#125;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;URL 的路径部分是: &#123;&#125;&quot;</span>, parsed.<span class="title function_ invoke__">path</span>());</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">URL 的路径部分是: /rust-lang/rust/issues</span><br></pre></td></tr></table></figure><h3 id="2-2-通过移除路径段创建基本-URL">2.2 通过移除路径段创建基本 <code>URL</code></h3><p>  基本 <code>URL</code>（base URL）包括协议和域名。但基本 <code>URL</code>（base URL）不包括目录、文件或查询字符串，这些项都可以从给定的 <code>URL</code> 中剥离出来。创建基本 <code>URL</code>（base URL）时，通过 <code>PathSegmentsMut::clear</code> 方法移除目录和文件路径，通过方法 <code>Url::set_query</code> 移除查询字符串。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> url::Url;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">UrlParse</span>(url::ParseError);</span><br><span class="line">    &#125;</span><br><span class="line">    errors &#123;</span><br><span class="line">        CannotBeABase</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">full</span> = <span class="string">&quot;https://github.com/rust-lang/cargo?asdf&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = Url::<span class="title function_ invoke__">parse</span>(full)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">base</span> = <span class="title function_ invoke__">base_url</span>(url)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(base.<span class="title function_ invoke__">as_str</span>(), <span class="string">&quot;https://github.com/&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;基础URL是: &#123;&#125;&quot;</span>, base);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">base_url</span>(<span class="keyword">mut</span> url: Url) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Url&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> url.<span class="title function_ invoke__">path_segments_mut</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="keyword">mut</span> path) =&gt; &#123;</span><br><span class="line">            path.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">from_kind</span>(ErrorKind::CannotBeABase));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    url.<span class="title function_ invoke__">set_query</span>(<span class="literal">None</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验及输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">基础URL是: https://github.com/</span><br></pre></td></tr></table></figure><h3 id="2-3-从基本-URL-创建新-URLs">2.3 从基本 <code>URL</code> 创建新 <code>URLs</code></h3><p>  <code>join</code> 方法从基路径和相对路径创建新的 <code>URL</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> url::&#123;ParseError, Url&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), ParseError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = <span class="string">&quot;/rust-lang/cargo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gh</span> = <span class="title function_ invoke__">build_github_url</span>(path)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(gh.<span class="title function_ invoke__">as_str</span>(), <span class="string">&quot;https://github.com/rust-lang/cargo&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;加入的网址是: &#123;&#125;&quot;</span>, gh);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_github_url</span>(path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Url, ParseError&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> GITHUB: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;https://github.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">base</span> = Url::<span class="title function_ invoke__">parse</span>(GITHUB).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;已知硬编码 URL 是有效的&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">joined</span> = base.<span class="title function_ invoke__">join</span>(path)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(joined)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验及输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">加入的网址是: https://github.com/rust-lang/cargo</span><br></pre></td></tr></table></figure><h3 id="2-4-提取-URL-源（scheme-host-port）">2.4 提取 <code>URL</code> 源（<code>scheme/host/port</code>）</h3><ul><li><ol><li><code>Url</code> 结构体定义了多种方法，以便于提取有关它所表示的 <code>URL</code> 的信息。</li></ol></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> url::&#123;Host, ParseError, Url&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), ParseError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;ftp://rust-lang.org/examples&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = Url::<span class="title function_ invoke__">parse</span>(s)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(url.<span class="title function_ invoke__">scheme</span>(), <span class="string">&quot;ftp&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(url.<span class="title function_ invoke__">host</span>(), <span class="title function_ invoke__">Some</span>(Host::<span class="title function_ invoke__">Domain</span>(<span class="string">&quot;rust-lang.org&quot;</span>)));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(url.<span class="title function_ invoke__">port_or_known_default</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">21</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;出处果然不出所料！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出及校验</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">出处果然不出所料！</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li><code>origin</code> 方法产生相同的结果。</li></ol></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> url::&#123;Host, Origin, Url&#125;;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">UrlParse</span>(url::ParseError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;ftp://rust-lang.org/examples&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = Url::<span class="title function_ invoke__">parse</span>(s)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expected_scheme</span> = <span class="string">&quot;ftp&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expected_host</span> = Host::<span class="title function_ invoke__">Domain</span>(<span class="string">&quot;rust-lang.org&quot;</span>.<span class="title function_ invoke__">to_owned</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expected_port</span> = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expected</span> = Origin::<span class="title function_ invoke__">Tuple</span>(expected_scheme, expected_host, expected_port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = url.<span class="title function_ invoke__">origin</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(origin, expected);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;出处果然不出所料！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出及校验</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">出处果然不出所料！</span><br></pre></td></tr></table></figure><h3 id="2-5-从-URL-移除片段标识符和查询对">2.5 从 <code>URL</code> 移除片段标识符和查询对</h3><p>  解析 <code>Url</code> 结构体，并使用 <code>url::Position</code> 枚举对其进行切片，以去除不需要的 <code>URL</code> 片段。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> url::&#123;ParseError, Position, Url&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), ParseError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed</span> = Url::<span class="title function_ invoke__">parse</span>(<span class="string">&quot;https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cleaned</span>: &amp;<span class="type">str</span> = &amp;parsed[..Position::AfterPath];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;清理后的网址: &#123;&#125;&quot;</span>, cleaned);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">清理后的网址: https://github.com/rust-lang/rust/issues</span><br></pre></td></tr></table></figure><h2 id="3-媒介-MIME-类型">3. 媒介(<code>MIME</code>)类型</h2><p>  需要安装<code>mime</code>库，可通过<code>cargo add mime</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">mime</span> = <span class="string">&quot;0.3.17&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-从字符串获取-MIME-类型">3.1 从字符串获取 <code>MIME</code> 类型</h3><p>  下面的实例展示如何使用 <code>mime</code> crate 从字符串解析出 <code>MIME</code> 类型。<code>FromStrError</code> 结构体在 <code>unwrap_or</code> 子句中生成默认的 <code>MIME</code> 类型。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mime::&#123;Mime, APPLICATION_OCTET_STREAM&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">invalid_mime_type</span> = <span class="string">&quot;i n v a l i d&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">default_mime</span> = invalid_mime_type</span><br><span class="line">        .parse::&lt;Mime&gt;()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap_or</span>(APPLICATION_OCTET_STREAM);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;:?&#125; 的 MIME 使用默认值 &#123;:?&#125;&quot;</span>,</span><br><span class="line">        invalid_mime_type, default_mime</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">valid_mime_type</span> = <span class="string">&quot;TEXT/PLAIN&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed_mime</span> = valid_mime_type</span><br><span class="line">        .parse::&lt;Mime&gt;()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap_or</span>(APPLICATION_OCTET_STREAM);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;:?&#125; 的 MIME 被解析为 &#123;:?&#125;&quot;</span>,</span><br><span class="line">        valid_mime_type, parsed_mime</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;i n v a l i d&quot;</span> 的 MIME 使用默认值 <span class="string">&quot;application/octet-stream&quot;</span></span><br><span class="line"><span class="string">&quot;TEXT/PLAIN&quot;</span> 的 MIME 被解析为 <span class="string">&quot;text/plain&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-从文件名获取-MIME-类型">3.2 从文件名获取 <code>MIME</code> 类型</h3><p>  实例展示如何使用 <code>mime</code> crate 从给定的文件名返回正确的 <code>MIME</code> 类型。程序将检查文件扩展名并与已知的 <code>MIME</code> 类型列表匹配，返回值为 <code>mime:Mime</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mime::Mime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_mimetype</span>(filename: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> Mime &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parts</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = filename.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> parts.<span class="title function_ invoke__">last</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(v) =&gt; <span class="keyword">match</span> *v &#123;</span><br><span class="line">            <span class="string">&quot;png&quot;</span> =&gt; mime::IMAGE_PNG,</span><br><span class="line">            <span class="string">&quot;jpg&quot;</span> =&gt; mime::IMAGE_JPEG,</span><br><span class="line">            <span class="string">&quot;json&quot;</span> =&gt; mime::APPLICATION_JSON,</span><br><span class="line">            &amp;_ =&gt; mime::TEXT_PLAIN,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">None</span> =&gt; mime::TEXT_PLAIN,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filenames</span> = <span class="built_in">vec!</span>[<span class="string">&quot;foobar.jpg&quot;</span>, <span class="string">&quot;foo.bar&quot;</span>, <span class="string">&quot;foobar.png&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">file</span> <span class="keyword">in</span> filenames &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mime</span> = <span class="title function_ invoke__">find_mimetype</span>(&amp;file.<span class="title function_ invoke__">to_owned</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 文件的 MIME类型是：&#123;&#125;&quot;</span>, file, mime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">foobar.jpg 文件的 MIME类型是：image/jpeg</span><br><span class="line">foo.bar 文件的 MIME类型是：text/plain</span><br><span class="line">foobar.png 文件的 MIME类型是：image/png</span><br></pre></td></tr></table></figure><h3 id="3-3-解析-HTTP-响应的-MIME-类型">3.3 解析 <code>HTTP</code> 响应的 <code>MIME</code> 类型</h3><p>  当从 <code>reqwest</code> 接收到 <code>HTTP</code> 响应时，<code>MIME</code> 类型或媒体类型可以在实体头部的 <code>Content-Type</code> 标头中找到。<code>reqwest::header::HeaderMap::get</code> 方法将标头检索为结构体 <code>reqwest::header::HeaderValue</code>，结构体可以转换为字符串。然后 <code>mime</code> crate 可以解析它，生成 <code>mime::Mime</code> 值。<code>mime</code> crate 也定义了一些常用的 <code>MIME</code> 类型。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> mime::Mime;</span><br><span class="line"><span class="keyword">use</span> reqwest::header::CONTENT_TYPE;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">   foreign_links &#123;</span><br><span class="line">       <span class="title function_ invoke__">Reqwest</span>(reqwest::Error);</span><br><span class="line">       <span class="title function_ invoke__">Header</span>(reqwest::header::ToStrError);</span><br><span class="line">       <span class="title function_ invoke__">Mime</span>(mime::FromStrError);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = reqwest::<span class="title function_ invoke__">get</span>(<span class="string">&quot;https://www.rust-lang.org/logos/rust-logo-32x32.png&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">headers</span> = response.<span class="title function_ invoke__">headers</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> headers.<span class="title function_ invoke__">get</span>(CONTENT_TYPE) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;响应不包含 Content-Type 标头.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(content_type) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">content_type</span> = Mime::<span class="title function_ invoke__">from_str</span>(content_type.<span class="title function_ invoke__">to_str</span>()?)?;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">media_type</span> = <span class="title function_ invoke__">match</span> (content_type.<span class="title function_ invoke__">type_</span>(), content_type.<span class="title function_ invoke__">subtype</span>()) &#123;</span><br><span class="line">                (mime::TEXT, mime::HTML) =&gt; <span class="string">&quot;一个 HTML 文件&quot;</span>,</span><br><span class="line">                (mime::TEXT, _) =&gt; <span class="string">&quot;文本文档&quot;</span>,</span><br><span class="line">                (mime::IMAGE, mime::PNG) =&gt; <span class="string">&quot;一张PNG图片&quot;</span>,</span><br><span class="line">                (mime::IMAGE, _) =&gt; <span class="string">&quot;一个图像&quot;</span>,</span><br><span class="line">                _ =&gt; <span class="string">&quot;既不是文字也不是图像&quot;</span>,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;响应包含: &#123;&#125;.&quot;</span>, media_type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验及输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">响应包含: 一张PNG图片.</span><br></pre></td></tr></table></figure><h2 id="4-客户端">4. 客户端</h2><p>  需要安装<code>hyper</code>库和重新安装<code>reqwest</code>库，可通过<code>cargo add hyper</code>和<code>cargo add reqwest --features blocking</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">hyper</span> = <span class="string">&quot;0.14.26&quot;</span></span><br><span class="line"><span class="attr">reqwest</span> = &#123; version = <span class="string">&quot;0.11.17&quot;</span>, features = [<span class="string">&quot;blocking&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-请求处理">4.1 请求处理</h3><h4 id="4-1-1-发出-HTTP-GET-请求">4.1.1 发出 <code>HTTP GET</code> 请求</h4><p>  解析提供的 URL，并使用 <code>reqwest::blocking::get</code> 发起同步 <code>HTTP GET</code> 请求。打印获取的响应消息状态和标头 <code>reqwest::blocking::Response</code>。使用 <code>read_to_string</code> 将 <code>HTTP</code> 响应消息主体正文读入到指派的字符串 <code>String</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">HttpRequest</span>(reqwest::Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">res</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(<span class="string">&quot;http://httpbin.org/get&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">body</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    res.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> body)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;状态: &#123;&#125;&quot;</span>, res.<span class="title function_ invoke__">status</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;标头:\n&#123;:#?&#125;&quot;</span>, res.<span class="title function_ invoke__">headers</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;正文:\n&#123;&#125;&quot;</span>, body);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">状态: 200 OK</span><br><span class="line">标头:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;date&quot;</span>: <span class="string">&quot;Sun, 30 Apr 2023 07:51:57 GMT&quot;</span>,</span><br><span class="line">    <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="string">&quot;content-length&quot;</span>: <span class="string">&quot;221&quot;</span>,</span><br><span class="line">    <span class="string">&quot;connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span>,</span><br><span class="line">    <span class="string">&quot;server&quot;</span>: <span class="string">&quot;gunicorn/19.9.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;access-control-allow-origin&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    <span class="string">&quot;access-control-allow-credentials&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">正文:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-644e1e1d-0d67becf0590a0c6524831ff&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;192.168.1.1&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;http://httpbin.org/get&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异步</li></ul><p>  常见的方法是通过包含 <code>tokio</code> 在内的类似异步执行器，使主函数执行异步，但检索处理相同的信息。本实例中，<code>tokio::main</code> 处理所有繁重的执行器设置，并允许在 <code>.await</code> 之前不阻塞的按顺序执行代码。也可以使用 <code>reqwest</code> 的异步版本，其请求函数 <code>reqwest::get</code> 和响应结构体 <code>reqwest::Response</code> 都是异步的。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">HttpRequest</span>(reqwest::Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::<span class="title function_ invoke__">get</span>(<span class="string">&quot;http://httpbin.org/get&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;状态: &#123;&#125;&quot;</span>, res.<span class="title function_ invoke__">status</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;标头:\n&#123;:#?&#125;&quot;</span>, res.<span class="title function_ invoke__">headers</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">body</span> = res.<span class="title function_ invoke__">text</span>().<span class="keyword">await</span>?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;正文:\n&#123;&#125;&quot;</span>, body);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">状态: 200 OK</span><br><span class="line">标头:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;date&quot;</span>: <span class="string">&quot;Sun, 30 Apr 2023 07:57:31 GMT&quot;</span>,</span><br><span class="line">    <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="string">&quot;content-length&quot;</span>: <span class="string">&quot;221&quot;</span>,</span><br><span class="line">    <span class="string">&quot;connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span>,</span><br><span class="line">    <span class="string">&quot;server&quot;</span>: <span class="string">&quot;gunicorn/19.9.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;access-control-allow-origin&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    <span class="string">&quot;access-control-allow-credentials&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">正文:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-644e1f6b-088641ec6e919c6542c9c239&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;192.168.1.1&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;http://httpbin.org/get&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-为-REST-请求设置自定义消息标头和-URL-参数">4.1.2 为 <code>REST</code> 请求设置自定义消息标头和 <code>URL</code> 参数</h4><p>  需要安装<code>serde</code>库，可通过<code>cargo add serde --features derive</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">hyper</span> = <span class="string">&quot;0.14.26&quot;</span></span><br><span class="line"><span class="attr">reqwest</span> = &#123; version = <span class="string">&quot;0.11.17&quot;</span>, features = [<span class="string">&quot;blocking&quot;</span>] &#125;</span><br><span class="line"><span class="attr">serde</span> = &#123; version = <span class="string">&quot;1.0.160&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><p>  实例中为 <code>HTTP GET</code> 请求设置标准的和自定义的 <code>HTTP</code> 消息标头以及 <code>URL</code> 参数。使用 <s><code>hyper::header!</code> 宏</s>自定义<code>header</code>创建 <code>XPoweredBy</code> 类型的自定义消息标头。使用 <code>Url::parse_with_params</code> 构建复杂的 URL。使用 <code>RequestBuilder::header</code> 方法设置标准消息标头 <code>header::UserAgent</code>、<code>header::Authorization</code>，以及自定义类型 <code>XPoweredBy</code>，然后使用 <code>RequestBuilder::send</code> 发起请求。请求的服务目标为 <code>http://httpbin.org/headers</code>，其响应结果是包含所有请求的消息标头的 <code>JSON</code> 字典，易于验证。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> serde::Deserialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> reqwest::blocking::Client;</span><br><span class="line"><span class="keyword">use</span> reqwest::header::&#123;AUTHORIZATION, USER_AGENT&#125;;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> url::Url;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HeadersEcho</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headers: HashMap&lt;<span class="type">String</span>, <span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Reqwest</span>(reqwest::Error);</span><br><span class="line">        <span class="title function_ invoke__">UrlParse</span>(url::ParseError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = Url::<span class="title function_ invoke__">parse_with_params</span>(</span><br><span class="line">        <span class="string">&quot;http://httpbin.org/headers&quot;</span>,</span><br><span class="line">        &amp;[(<span class="string">&quot;lang&quot;</span>, <span class="string">&quot;rust&quot;</span>), (<span class="string">&quot;browser&quot;</span>, <span class="string">&quot;servo&quot;</span>)],</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = Client::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">get</span>(url)</span><br><span class="line">        .<span class="title function_ invoke__">header</span>(USER_AGENT, <span class="string">&quot;Rust-test&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">header</span>(</span><br><span class="line">            AUTHORIZATION,</span><br><span class="line">            <span class="built_in">format!</span>(<span class="string">&quot;Bearer &#123;&#125;&quot;</span>, <span class="string">&quot;DEadBEEfc001cAFeEDEcafBAd&quot;</span>),</span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">header</span>(<span class="string">&quot;X-Powered-By&quot;</span>, <span class="string">&quot;Guybrush Threepwood&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">send</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = response.<span class="title function_ invoke__">url</span>().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">out</span>: HeadersEcho = response.<span class="title function_ invoke__">json</span>()?;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        out.headers[<span class="string">&quot;Authorization&quot;</span>],</span><br><span class="line">        <span class="string">&quot;Bearer DEadBEEfc001cAFeEDEcafBAd&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">assert_eq!</span>(out.headers[<span class="string">&quot;User-Agent&quot;</span>], <span class="string">&quot;Rust-test&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(out.headers[<span class="string">&quot;X-Powered-By&quot;</span>], <span class="string">&quot;Guybrush Threepwood&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="comment">// response.url().as_str(),</span></span><br><span class="line">        url, <span class="comment">// 解决borrow of moved value: `response`</span></span><br><span class="line">        <span class="string">&quot;http://httpbin.org/headers?lang=rust&amp;browser=servo&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, out);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验及输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HeadersEcho &#123; headers: &#123;<span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Rust-test&quot;</span>, <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-644f6d07-335fc12037d78830043aa2aa&quot;</span>, <span class="string">&quot;Authorization&quot;</span>: <span class="string">&quot;Bearer DEadBEEfc001cAFeEDEcafBAd&quot;</span>, <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>, <span class="string">&quot;X-Powered-By&quot;</span>: <span class="string">&quot;Guybrush Threepwood&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Web-API-调用">4.2 <code>Web API</code> 调用</h3><h4 id="4-2-1-查询-GitHub-API">4.2.1 查询 GitHub <code>API</code></h4><p>  使用 <code>reqwest::get</code> 查询 点赞的用户 <code>API v3</code>，以获取某个 <code>GitHub</code> 项目的所有点赞用户的列表。使用 <code>Response::json</code> 将响应信息 <code>reqwest::Response</code> 反序列化为实现了 <code>serde::Deserialize</code> trait 的 User 对象。<code>tokio::main</code> 用于设置异步执行器，该进程异步等待 <code>reqwest::get</code> 完成，然后将响应信息反序列化到用户实例中。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> reqwest::Error;</span><br><span class="line"><span class="keyword">use</span> serde::Deserialize;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    login: <span class="type">String</span>,</span><br><span class="line">    id: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">request_url</span> = <span class="built_in">format!</span>(</span><br><span class="line">        <span class="string">&quot;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;/stargazers&quot;</span>,</span><br><span class="line">        owner = <span class="string">&quot;rust-lang-nursery&quot;</span>,</span><br><span class="line">        repo = <span class="string">&quot;rust-cookbook&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, request_url);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = reqwest::Client::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = client</span><br><span class="line">        .<span class="title function_ invoke__">get</span>(&amp;request_url)</span><br><span class="line">        .<span class="title function_ invoke__">header</span>(reqwest::header::USER_AGENT, <span class="string">&quot;My Rust App&quot;</span>) <span class="comment">// GitHub API 要求请求中必须包含一个 User-Agent 头，以便识别您的应用程序。</span></span><br><span class="line">        .<span class="title function_ invoke__">send</span>()</span><br><span class="line">        .<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">users</span>: <span class="type">Vec</span>&lt;User&gt; = response.<span class="title function_ invoke__">json</span>().<span class="keyword">await</span>?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, users);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://api.github.com/repos/rust-lang-nursery/rust-cookbook/stargazers</span><br><span class="line">[User &#123; login: <span class="string">&quot;trentspi&quot;</span>, <span class="built_in">id</span>: 20845184 &#125;, User &#123; login: <span class="string">&quot;charlesetc&quot;</span>, <span class="built_in">id</span>: 5167293 &#125;, User &#123; login: <span class="string">&quot;Ruin0x11&quot;</span>, <span class="built_in">id</span>: 6700637 &#125;, User &#123; login: <span class="string">&quot;gmcabrita&quot;</span>, <span class="built_in">id</span>: 957820 &#125;, User &#123; login: <span class="string">&quot;cnwalker&quot;</span>, <span class="built_in">id</span>: 8570077 &#125;, User &#123; login: <span class="string">&quot;k0pernicus&quot;</span>, <span class="built_in">id</span>: 3605451 &#125;, User &#123; login: <span class="string">&quot;jaxx&quot;</span>, <span class="built_in">id</span>: 723258 &#125;, User &#123; login: <span class="string">&quot;dhharris&quot;</span>, <span class="built_in">id</span>: 9009622 &#125;, User &#123; login: <span class="string">&quot;zhangsoledad&quot;</span>, <span class="built_in">id</span>: 3198439 &#125;, User &#123; login: <span class="string">&quot;ssebastianj&quot;</span>, <span class="built_in">id</span>: 309535 &#125;, User &#123; login: <span class="string">&quot;oclbdk&quot;</span>, <span class="built_in">id</span>: 136982 &#125;, User &#123; login: <span class="string">&quot;Latrasis&quot;</span>, <span class="built_in">id</span>: 4656227 &#125;, User &#123; login: <span class="string">&quot;narendasan&quot;</span>, <span class="built_in">id</span>: 1790613 &#125;, User &#123; login: <span class="string">&quot;rishabh92&quot;</span>, <span class="built_in">id</span>: 13951936 &#125;, User &#123; login: <span class="string">&quot;hueftl&quot;</span>, <span class="built_in">id</span>: 11706301 &#125;, User &#123; login: <span class="string">&quot;seeekr&quot;</span>, <span class="built_in">id</span>: 302886 &#125;, User &#123; login: <span class="string">&quot;krzyk&quot;</span>, <span class="built_in">id</span>: 105730 &#125;, User &#123; login: <span class="string">&quot;rjammala&quot;</span>, <span class="built_in">id</span>: 4990663 &#125;, User &#123; login: <span class="string">&quot;DaseinPhaos&quot;</span>, <span class="built_in">id</span>: 11028753 &#125;, User &#123; login: <span class="string">&quot;jryans&quot;</span>, <span class="built_in">id</span>: 279572 &#125;, User &#123; login: <span class="string">&quot;burdges&quot;</span>, <span class="built_in">id</span>: 680126 &#125;, User &#123; login: <span class="string">&quot;zaa&quot;</span>, <span class="built_in">id</span>: 5245 &#125;, User &#123; login: <span class="string">&quot;DenisKolodin&quot;</span>, <span class="built_in">id</span>: 418920 &#125;, User &#123; login: <span class="string">&quot;messense&quot;</span>, <span class="built_in">id</span>: 1556054 &#125;, User &#123; login: <span class="string">&quot;wdv4758h&quot;</span>, <span class="built_in">id</span>: 2716047 &#125;, User &#123; login: <span class="string">&quot;iblislin&quot;</span>, <span class="built_in">id</span>: 761623 &#125;, User &#123; login: <span class="string">&quot;realityone&quot;</span>, <span class="built_in">id</span>: 4059040 &#125;, User &#123; login: <span class="string">&quot;sebasmagri&quot;</span>, <span class="built_in">id</span>: 11137 &#125;, User &#123; login: <span class="string">&quot;sourcepirate&quot;</span>, <span class="built_in">id</span>: 5940286 &#125;, User &#123; login: <span class="string">&quot;king6cong&quot;</span>, <span class="built_in">id</span>: 302560 &#125;]</span><br></pre></td></tr></table></figure><h4 id="4-2-2-检查-API-资源是否存在">4.2.2 检查 <code>API</code> 资源是否存在</h4><p>  消息标头 HEAD 请求（(<code>Client::head</code>）查询 GitHub 用户端接口，然后检查响应代码以确定是否成功。这是一种无需接收 HTTP 响应消息主体，即可快速查询 rest 资源的方法。使用 <code>ClientBuilder::timeout</code> 方法配置的 <code>reqwest::Client</code> 结构体将确保请求不会超时。由于 <code>ClientBuilder::build</code> 和 <code>RequestBuilder::send</code> 都返回错误类型 <code>reqwest::Error</code>，所以便捷的 <code>reqwest::Result</code> 类型被用于主函数的返回类型。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> reqwest::ClientBuilder;</span><br><span class="line"><span class="keyword">use</span> reqwest::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user</span> = <span class="string">&quot;ferris-the-crab&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">request_url</span> = <span class="built_in">format!</span>(<span class="string">&quot;https://api.github.com/users/&#123;&#125;&quot;</span>, user);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, request_url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">timeout</span> = Duration::<span class="title function_ invoke__">new</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = ClientBuilder::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">timeout</span>(timeout).<span class="title function_ invoke__">build</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = client</span><br><span class="line">        .<span class="title function_ invoke__">head</span>(&amp;request_url)</span><br><span class="line">        .<span class="title function_ invoke__">header</span>(reqwest::header::USER_AGENT, <span class="string">&quot;My Rust App&quot;</span>) <span class="comment">// GitHub API 要求请求中必须包含一个 User-Agent 头，以便识别您的应用程序。</span></span><br><span class="line">        .<span class="title function_ invoke__">send</span>()</span><br><span class="line">        .<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> response.<span class="title function_ invoke__">status</span>().<span class="title function_ invoke__">is_success</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 是一个用户!&quot;</span>, user);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 不是一个用户!&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://api.github.com/users/ferris-the-crab</span><br><span class="line">ferris-the-crab 不是一个用户!</span><br></pre></td></tr></table></figure><h4 id="4-2-3-使用-GitHub-API-创建和删除-Gist">4.2.3 使用 GitHub <code>API</code> 创建和删除 Gist</h4><p>  需要安装<code>serde_json</code>库，可通过<code>cargo add serde_json</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0.96&quot;</span></span><br></pre></td></tr></table></figure><p>  使用 <code>Client::post</code> 创建一个 <code>POST</code> 请求提交到 <code>GitHub gists API v3</code> 接口的 gist，并使用 <code>Client::delete</code> 使用 <code>DELETE</code> 请求删除它。<code>reqwest::Client</code> 负责这两个请求的详细信息，包括：URL、消息体（body）和身份验证。<code>serde_json::json!</code> 宏的 <code>POST</code> 主体可以提供任意形式的 <code>JSON</code> 主体，通过调用 <code>RequestBuilder::json</code> 设置请求主体，<code>RequestBuilder::basic_auth</code> 处理身份验证。本实例中调用 <code>RequestBuilder::send</code> 方法同步执行请求(实例中使用 <code>HTTP</code> 基本认证 为了授权访问 GitHub <code>API</code>)。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> reqwest::Client;</span><br><span class="line"><span class="keyword">use</span> serde::Deserialize;</span><br><span class="line"><span class="keyword">use</span> serde_json::json;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">EnvVar</span>(env::VarError);</span><br><span class="line">        <span class="title function_ invoke__">HttpRequest</span>(reqwest::Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Gist</span> &#123;</span><br><span class="line">    id: <span class="type">String</span>,</span><br><span class="line">    html_url: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gh_user</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;GH_USER&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gh_pass</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;GH_PASS&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gist_body</span> = json!(&#123;</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;the description for this gist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;public&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;files&quot;</span>: &#123;</span><br><span class="line">         <span class="string">&quot;main.rs&quot;</span>: &#123;</span><br><span class="line">         <span class="string">&quot;content&quot;</span>: <span class="string">r#&quot;fn main() &#123; println!(&quot;hello world!&quot;);&#125;&quot;#</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">request_url</span> = <span class="string">&quot;https://api.github.com/gists&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = Client::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">post</span>(request_url)</span><br><span class="line">        .<span class="title function_ invoke__">basic_auth</span>(gh_user.<span class="title function_ invoke__">clone</span>(), <span class="title function_ invoke__">Some</span>(gh_pass.<span class="title function_ invoke__">clone</span>()))</span><br><span class="line">        .<span class="title function_ invoke__">json</span>(&amp;gist_body)</span><br><span class="line">        .<span class="title function_ invoke__">header</span>(reqwest::header::USER_AGENT, <span class="string">&quot;My Rust App&quot;</span>) <span class="comment">// GitHub API 要求请求中必须包含一个 User-Agent 头，以便识别您的应用程序。</span></span><br><span class="line">        .<span class="title function_ invoke__">send</span>()</span><br><span class="line">        .<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gist</span>: Gist = response.<span class="title function_ invoke__">json</span>().<span class="keyword">await</span>?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;创建 &#123;:?&#125;&quot;</span>, gist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">request_url</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;/&#123;&#125;&quot;</span>, request_url, gist.id);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = Client::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">delete</span>(&amp;request_url)</span><br><span class="line">        .<span class="title function_ invoke__">basic_auth</span>(gh_user, <span class="title function_ invoke__">Some</span>(gh_pass))</span><br><span class="line">        .<span class="title function_ invoke__">header</span>(reqwest::header::USER_AGENT, <span class="string">&quot;My Rust App&quot;</span>) <span class="comment">// GitHub API 要求请求中必须包含一个 User-Agent 头，以便识别您的应用程序。</span></span><br><span class="line">        .<span class="title function_ invoke__">send</span>()</span><br><span class="line">        .<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Gist &#123;&#125; 已删除！ 状态码：&#123;&#125;&quot;</span>, gist.id, response.<span class="title function_ invoke__">status</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行前需要设置环境变量</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GH_USER=xxxxx <span class="comment"># 填Github用户名</span></span><br><span class="line"><span class="built_in">export</span> GH_PASS=ghp_******************* <span class="comment"># 填Github 生成的token（生成时需要勾选Gist复选框）</span></span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">创建 Gist &#123; <span class="built_in">id</span>: <span class="string">&quot;d30b7ea925c570aaa59d22af83bd3f1a&quot;</span>, html_url: <span class="string">&quot;https://gist.github.com/xxxxx/d30b7ea925c570aaa59d22af83bd3f1a&quot;</span> &#125;</span><br><span class="line">Gist d30b7ea925c570aaa59d22af83bd3f1a 已删除！ 状态码：204 No Content</span><br></pre></td></tr></table></figure><h4 id="4-2-4-使用-RESTful-API-分页">4.2.4 使用 RESTful <code>API</code> 分页</h4><p>  可以将分页的 web <code>API</code> 方便地包裹在 Rust 迭代器中，当到达每一页的末尾时，迭代器会从远程服务器加载下一页结果。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> reqwest::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> serde::Deserialize;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ApiResponse</span> &#123;</span><br><span class="line">    dependencies: <span class="type">Vec</span>&lt;Dependency&gt;,</span><br><span class="line">    meta: Meta,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">    crate_id: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meta</span> &#123;</span><br><span class="line">    total: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReverseDependencies</span> &#123;</span><br><span class="line">    crate_id: <span class="type">String</span>,</span><br><span class="line">    dependencies: &lt;<span class="type">Vec</span>&lt;Dependency&gt; <span class="keyword">as</span> <span class="built_in">IntoIterator</span>&gt;::IntoIter,</span><br><span class="line">    client: reqwest::blocking::Client,</span><br><span class="line">    page: <span class="type">u32</span>,</span><br><span class="line">    per_page: <span class="type">u32</span>,</span><br><span class="line">    total: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ReverseDependencies</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">of</span>(crate_id: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(ReverseDependencies &#123;</span><br><span class="line">            crate_id: crate_id.<span class="title function_ invoke__">to_owned</span>(),</span><br><span class="line">            dependencies: <span class="built_in">vec!</span>[].<span class="title function_ invoke__">into_iter</span>(),</span><br><span class="line">            client: reqwest::blocking::Client::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            page: <span class="number">0</span>,</span><br><span class="line">            per_page: <span class="number">100</span>,</span><br><span class="line">            total: <span class="number">0</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">try_next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Option</span>&lt;Dependency&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(dep) = <span class="keyword">self</span>.dependencies.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Some</span>(dep));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.page &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">self</span>.page * <span class="keyword">self</span>.per_page &gt;= <span class="keyword">self</span>.total &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(<span class="literal">None</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.page += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">url</span> = <span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;https://crates.io/api/v1/crates/&#123;&#125;/reverse_dependencies?page=&#123;&#125;&amp;per_page=&#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.crate_id, <span class="keyword">self</span>.page, <span class="keyword">self</span>.per_page</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, url);</span><br><span class="line">        <span class="comment">// let response = self.client.get(&amp;url).send()?.json::&lt;ApiResponse&gt;()?;</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">response</span> = <span class="keyword">self</span></span><br><span class="line">            .client</span><br><span class="line">            .<span class="title function_ invoke__">get</span>(&amp;url)</span><br><span class="line">            .<span class="title function_ invoke__">header</span>(reqwest::header::USER_AGENT, <span class="string">&quot;My Rust App&quot;</span>) <span class="comment">// Crates.io API 要求请求中必须包含一个 User-Agent 头，以便识别您的应用程序。</span></span><br><span class="line">            .<span class="title function_ invoke__">send</span>()?</span><br><span class="line">            .json::&lt;ApiResponse&gt;()?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.dependencies = response.dependencies.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line">        <span class="keyword">self</span>.total = response.meta.total;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.total);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="keyword">self</span>.dependencies.<span class="title function_ invoke__">next</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">ReverseDependencies</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">Result</span>&lt;Dependency&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">try_next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Some</span>(dep)) =&gt; <span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">Ok</span>(dep)),</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="literal">None</span>) =&gt; <span class="literal">None</span>,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">Err</span>(err)),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">dep</span> <span class="keyword">in</span> ReverseDependencies::<span class="title function_ invoke__">of</span>(<span class="string">&quot;serde&quot;</span>)? &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;反向依赖: &#123;&#125;&quot;</span>, dep?.crate_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://crates.io/api/v1/crates/serde/reverse_dependencies?page=1&amp;per_page=100 <span class="comment"># 主要页数变化</span></span><br><span class="line">26183 </span><br><span class="line">反向依赖: serde</span><br><span class="line">反向依赖: serde</span><br><span class="line">... <span class="comment"># 省略</span></span><br><span class="line">https://crates.io/api/v1/crates/serde/reverse_dependencies?page=2&amp;per_page=100 <span class="comment"># 主要页数变化</span></span><br><span class="line">26183</span><br><span class="line">反向依赖: serde</span><br><span class="line">反向依赖: serde</span><br><span class="line">... <span class="comment"># 省略</span></span><br></pre></td></tr></table></figure><h4 id="4-2-5-处理速率受限-API">4.2.5 处理速率受限 API</h4><p>  实例使用 GitHub API - 速率限制展示如何处理远程服务器错误。本实例 <s>使用 hyper::header! 宏</s> 自定义解析响应头并检查 <code>reqwest::StatusCode::FORBIDDEN</code>。如果响应超过速率限制，则将等待并重试。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> reqwest::StatusCode;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, UNIX_EPOCH&#125;;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">   foreign_links &#123;</span><br><span class="line">       <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">       <span class="title function_ invoke__">Time</span>(std::time::SystemTimeError);</span><br><span class="line">       <span class="title function_ invoke__">Reqwest</span>(reqwest::Error);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">&quot;https://api.github.com/users/rust-lang-nursery &quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">client</span> = reqwest::blocking::Client::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">response</span> = client</span><br><span class="line">            .<span class="title function_ invoke__">get</span>(url)</span><br><span class="line">            .<span class="title function_ invoke__">header</span>(reqwest::header::USER_AGENT, <span class="string">&quot;My Rust App&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">send</span>()?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rate_limit</span> = response</span><br><span class="line">            .<span class="title function_ invoke__">headers</span>()</span><br><span class="line">            .<span class="title function_ invoke__">get</span>(<span class="string">&quot;X-RateLimit-Limit&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;响应不包含预期的 X-RateLimit-Limit 标头&quot;</span>)?</span><br><span class="line">            .<span class="title function_ invoke__">to_str</span>()</span><br><span class="line">            .<span class="title function_ invoke__">map_err</span>(|_| <span class="string">&quot;无法解析 X-RateLimit-Limit 标头值&quot;</span>)?</span><br><span class="line">            .parse::&lt;<span class="type">u64</span>&gt;()</span><br><span class="line">            .<span class="title function_ invoke__">map_err</span>(|_| <span class="string">&quot;无法解析 X-RateLimit-Limit 标头值&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rate_remaining</span> = response</span><br><span class="line">            .<span class="title function_ invoke__">headers</span>()</span><br><span class="line">            .<span class="title function_ invoke__">get</span>(<span class="string">&quot;X-RateLimit-Remaining&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;响应不包含预期的 X-RateLimit-Remaining 标头&quot;</span>)?</span><br><span class="line">            .<span class="title function_ invoke__">to_str</span>()</span><br><span class="line">            .<span class="title function_ invoke__">map_err</span>(|_| <span class="string">&quot;无法解析 X-RateLimit-Remaining 标头值&quot;</span>)?</span><br><span class="line">            .parse::&lt;<span class="type">u64</span>&gt;()</span><br><span class="line">            .<span class="title function_ invoke__">map_err</span>(|_| <span class="string">&quot;无法解析 X-RateLimit-Remaining 标头值&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rate_reset_at</span> = response</span><br><span class="line">            .<span class="title function_ invoke__">headers</span>()</span><br><span class="line">            .<span class="title function_ invoke__">get</span>(<span class="string">&quot;X-RateLimit-Reset&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;响应不包含预期的 X-RateLimit-Reset 标头&quot;</span>)?</span><br><span class="line">            .<span class="title function_ invoke__">to_str</span>()</span><br><span class="line">            .<span class="title function_ invoke__">map_err</span>(|_| <span class="string">&quot;无法解析 X-RateLimit-Reset 标头值&quot;</span>)?</span><br><span class="line">            .parse::&lt;<span class="type">u64</span>&gt;()</span><br><span class="line">            .<span class="title function_ invoke__">map_err</span>(|_| <span class="string">&quot;无法解析 X-RateLimit-Reset 标头值&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rate_reset_within</span> = Duration::<span class="title function_ invoke__">from_secs</span>(rate_reset_at) - UNIX_EPOCH.<span class="title function_ invoke__">elapsed</span>()?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> response.<span class="title function_ invoke__">status</span>() == StatusCode::FORBIDDEN &amp;&amp; rate_remaining == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;休眠 &#123;&#125; 秒。&quot;</span>, rate_reset_within.<span class="title function_ invoke__">as_secs</span>());</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(rate_reset_within);</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">main</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;速率限制当前为 &#123;&#125;/&#123;&#125;，此限制的重置将在 &#123;&#125; 秒内完成。&quot;</span>,</span><br><span class="line">                rate_remaining,</span><br><span class="line">                rate_limit,</span><br><span class="line">                rate_reset_within.<span class="title function_ invoke__">as_secs</span>(),</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">速率限制当前为 56/60，此限制的重置将在 1069 秒内完成。</span><br></pre></td></tr></table></figure><h3 id="4-3-下载">4.3 下载</h3><h4 id="4-3-1-下载文件到临时目录">4.3.1 下载文件到临时目录</h4><p>  需要安装<code>tempfile</code>库，可通过<code>cargo add tempfile</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">tempfile</span> = <span class="string">&quot;3.5.0&quot;</span></span><br></pre></td></tr></table></figure><p>  使用 <code>tempfile::Builder</code> 创建一个临时目录，并使用 <code>reqwest::get</code> 通过 HTTP 协议异步下载文件。使用 <code>Response::url</code> 方法内部的 <code>tempdir()</code> 方法获取文件名字，使用 <code>File</code> 结构体创建目标文件，并使用 <code>io::copy</code> 将下载的数据复制到文件中。程序退出时，会自动删除临时目录。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::copy;</span><br><span class="line"><span class="keyword">use</span> tempfile::Builder;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">     foreign_links &#123;</span><br><span class="line">         <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">         <span class="title function_ invoke__">HttpRequest</span>(reqwest::Error);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tmp_dir</span> = Builder::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">prefix</span>(<span class="string">&quot;example&quot;</span>).<span class="title function_ invoke__">tempdir</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">target</span> = <span class="string">&quot;https://www.rust-lang.org/logos/rust-logo-512x512.png&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = reqwest::<span class="title function_ invoke__">get</span>(target).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dest</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">fname</span> = response</span><br><span class="line">            .<span class="title function_ invoke__">url</span>()</span><br><span class="line">            .<span class="title function_ invoke__">path_segments</span>()</span><br><span class="line">            .<span class="title function_ invoke__">and_then</span>(|segments| segments.<span class="title function_ invoke__">last</span>())</span><br><span class="line">            .<span class="title function_ invoke__">and_then</span>(|name| <span class="keyword">if</span> name.<span class="title function_ invoke__">is_empty</span>() &#123; <span class="literal">None</span> &#125; <span class="keyword">else</span> &#123; <span class="title function_ invoke__">Some</span>(name) &#125;)</span><br><span class="line">            .<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;tmp.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;要下载的文件：“&#123;&#125;”&quot;</span>, fname);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">fname</span> = tmp_dir.<span class="title function_ invoke__">path</span>().<span class="title function_ invoke__">join</span>(fname);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;将位于：&#x27;&#123;:?&#125;&#x27;&quot;</span>, fname);</span><br><span class="line">        File::<span class="title function_ invoke__">create</span>(fname)?</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = response.<span class="title function_ invoke__">text</span>().<span class="keyword">await</span>?;</span><br><span class="line">    <span class="title function_ invoke__">copy</span>(&amp;<span class="keyword">mut</span> content.<span class="title function_ invoke__">as_bytes</span>(), &amp;<span class="keyword">mut</span> dest)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">要下载的文件：“rust-logo-512x512.png”</span><br><span class="line">将位于：<span class="string">&#x27;&quot;/tmp/examplelAjEDw/rust-logo-512x512.png&quot;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="4-3-2-使用-HTTP-range-请求头进行部分下载">4.3.2 使用 HTTP <code>range</code> 请求头进行部分下载</h4><p>  使用 <code>reqwest::blocking::Client::head</code> 获取响应的消息主体的大小（即消息主体内容长度）。然后，使用 <code>reqwest::blocking::Client::get</code> 下载（总计102400字节内容，单次下载 10240 字节的内容），同时打印进度消息。本实例使用同步的 <code>reqwest</code> 模块，消息范围标头指定响应的消息块大小和位置。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> reqwest::header::&#123;HeaderValue, CONTENT_LENGTH, RANGE&#125;;</span><br><span class="line"><span class="keyword">use</span> reqwest::StatusCode;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">Reqwest</span>(reqwest::Error);</span><br><span class="line">        <span class="title function_ invoke__">Header</span>(reqwest::header::ToStrError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PartialRangeIter</span> &#123;</span><br><span class="line">    start: <span class="type">u64</span>,</span><br><span class="line">    end: <span class="type">u64</span>,</span><br><span class="line">    buffer_size: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PartialRangeIter</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(start: <span class="type">u64</span>, end: <span class="type">u64</span>, buffer_size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> buffer_size == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(<span class="string">&quot;无效的 buffer_size，给出一个大于零的值。&quot;</span>)?;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(PartialRangeIter &#123;</span><br><span class="line">            start,</span><br><span class="line">            end,</span><br><span class="line">            buffer_size,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">PartialRangeIter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = HeaderValue;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.start &gt; <span class="keyword">self</span>.end &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">prev_start</span> = <span class="keyword">self</span>.start;</span><br><span class="line">            <span class="keyword">self</span>.start += std::cmp::<span class="title function_ invoke__">min</span>(<span class="keyword">self</span>.buffer_size <span class="keyword">as</span> <span class="type">u64</span>, <span class="keyword">self</span>.end - <span class="keyword">self</span>.start + <span class="number">1</span>);</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(</span><br><span class="line">                HeaderValue::<span class="title function_ invoke__">from_str</span>(&amp;<span class="built_in">format!</span>(<span class="string">&quot;bytes=&#123;&#125;-&#123;&#125;&quot;</span>, prev_start, <span class="keyword">self</span>.start - <span class="number">1</span>))</span><br><span class="line">                    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;提供格式化的字符串！&quot;</span>),</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">&quot;https://httpbin.org/range/102400?duration=2&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> CHUNK_SIZE: <span class="type">u32</span> = <span class="number">10240</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = reqwest::blocking::Client::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = client.<span class="title function_ invoke__">head</span>(url).<span class="title function_ invoke__">send</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = response</span><br><span class="line">        .<span class="title function_ invoke__">headers</span>()</span><br><span class="line">        .<span class="title function_ invoke__">get</span>(CONTENT_LENGTH)</span><br><span class="line">        .<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;响应不包括内容长度&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = <span class="type">u64</span>::<span class="title function_ invoke__">from_str</span>(length.<span class="title function_ invoke__">to_str</span>()?).<span class="title function_ invoke__">map_err</span>(|_| <span class="string">&quot;无效的 Content-Length 标头&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">output_file</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;download.bin&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;开始下载...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">range</span> <span class="keyword">in</span> PartialRangeIter::<span class="title function_ invoke__">new</span>(<span class="number">0</span>, length - <span class="number">1</span>, CHUNK_SIZE)? &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;范围 &#123;:?&#125;&quot;</span>, range);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">response</span> = client.<span class="title function_ invoke__">get</span>(url).<span class="title function_ invoke__">header</span>(RANGE, range).<span class="title function_ invoke__">send</span>()?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">status</span> = response.<span class="title function_ invoke__">status</span>();</span><br><span class="line">        <span class="keyword">if</span> !(status == StatusCode::OK || status == StatusCode::PARTIAL_CONTENT) &#123;</span><br><span class="line">            error_chain::bail!(<span class="string">&quot;意外的服务器响应: &#123;&#125;&quot;</span>, status)</span><br><span class="line">        &#125;</span><br><span class="line">        std::io::<span class="title function_ invoke__">copy</span>(&amp;<span class="keyword">mut</span> response, &amp;<span class="keyword">mut</span> output_file)?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = response.<span class="title function_ invoke__">text</span>()?;</span><br><span class="line">    std::io::<span class="title function_ invoke__">copy</span>(&amp;<span class="keyword">mut</span> content.<span class="title function_ invoke__">as_bytes</span>(), &amp;<span class="keyword">mut</span> output_file)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;成功完成下载！&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">开始下载...</span><br><span class="line">范围 <span class="string">&quot;bytes=0-10239&quot;</span></span><br><span class="line">范围 <span class="string">&quot;bytes=10240-20479&quot;</span></span><br><span class="line">范围 <span class="string">&quot;bytes=20480-30719&quot;</span></span><br><span class="line">范围 <span class="string">&quot;bytes=30720-40959&quot;</span></span><br><span class="line">范围 <span class="string">&quot;bytes=40960-51199&quot;</span></span><br><span class="line">范围 <span class="string">&quot;bytes=51200-61439&quot;</span></span><br><span class="line">范围 <span class="string">&quot;bytes=61440-71679&quot;</span></span><br><span class="line">范围 <span class="string">&quot;bytes=71680-81919&quot;</span></span><br><span class="line">范围 <span class="string">&quot;bytes=81920-92159&quot;</span></span><br><span class="line">范围 <span class="string">&quot;bytes=92160-102399&quot;</span></span><br><span class="line">成功完成下载！</span><br></pre></td></tr></table></figure><h4 id="4-3-3-POST-文件到-paste-rs">4.3.3 POST 文件到 <code>paste-rs</code></h4><p>  使用 <code>reqwest::Client</code> 建立与 <code>https://paste.rs</code> 的连接，遵循 <code>reqwest::RequestBuilder</code> 结构体模式。调用 <code>Client::post</code> 方法，以 <code>URL</code> 为参数连接目标，<code>RequestBuilder::body</code> 通过读取文件设置要发送的内容，<code>RequestBuilder::send</code> 方法在文件上传过程中将一直阻塞，直到返回响应消息。最后，<code>read_to_string</code> 返回响应消息并显示在控制台中。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">HttpRequest</span>(reqwest::Error);</span><br><span class="line">        <span class="title function_ invoke__">IoError</span>(::std::io::Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">paste_api</span> = <span class="string">&quot;https://paste.rs&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;message&quot;</span>)?; <span class="comment">//download.bin重命名为message</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = reqwest::Client::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = client.<span class="title function_ invoke__">post</span>(paste_api).<span class="title function_ invoke__">body</span>(contents).<span class="title function_ invoke__">send</span>().<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response_text</span> = res.<span class="title function_ invoke__">text</span>().<span class="keyword">await</span>?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;您的粘贴位于: &#123;&#125;&quot;</span>, response_text);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">您的粘贴位于: https://paste.rs/NZN</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】十八 文本处理</title>
      <link href="/news/1682928266057.html"/>
      <url>/news/1682928266057.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-正则表达式">1. 正则表达式</h2><p>  需要安装<code>regex</code>库和<code>lazy_static</code>库，可通过<code>cargo add regex</code>和<code>cargo add lazy_static</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">lazy_static</span> = <span class="string">&quot;1.4.0&quot;</span></span><br><span class="line"><span class="attr">regex</span> = <span class="string">&quot;1.8.1&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-1-验证并提取电子邮件登录信息">1.1 验证并提取电子邮件登录信息</h3><p>  验证电子邮件地址的格式是否正确，并提取 <code>@</code> 符号之前的所有内容。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> regex::Regex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">extract_login</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    lazy_static! &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">ref</span> RE: Regex = Regex::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            <span class="string">r&quot;(?x)</span></span><br><span class="line"><span class="string">            ^(?P&lt;login&gt;[^@\s]+)@</span></span><br><span class="line"><span class="string">            ([[:word:]]+\.)*</span></span><br><span class="line"><span class="string">            [[:word:]]+$</span></span><br><span class="line"><span class="string">            &quot;</span></span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    RE.<span class="title function_ invoke__">captures</span>(input)</span><br><span class="line">        .<span class="title function_ invoke__">and_then</span>(|cap| cap.<span class="title function_ invoke__">name</span>(<span class="string">&quot;login&quot;</span>).<span class="title function_ invoke__">map</span>(|login| login.<span class="title function_ invoke__">as_str</span>()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">extract_login</span>(<span class="string">r&quot;I❤email@example.com&quot;</span>), <span class="title function_ invoke__">Some</span>(<span class="string">r&quot;I❤email&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="title function_ invoke__">extract_login</span>(<span class="string">r&quot;sdf+sdsfsd.as.sdsd@jhkk.d.rl&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="string">r&quot;sdf+sdsfsd.as.sdsd&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">extract_login</span>(<span class="string">r&quot;唐三藏@tang.da&quot;</span>), <span class="title function_ invoke__">Some</span>(<span class="string">r&quot;唐三藏&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">extract_login</span>(<span class="string">r&quot;More@Than@One@at.com&quot;</span>), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">extract_login</span>(<span class="string">r&quot;Not an email@email&quot;</span>), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="1-2-从文本提取标签元素唯一的列表">1.2 从文本提取标签元素唯一的列表</h3><p>  展示从文本中提取、排序和去除标签列表的重复元素。这里给出的标签正则表达式只捕获以字母开头的拉丁语标签，完整的 twitter 标签正则表达式要复杂得多。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> regex::Regex;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">extract_hashtags</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> HashSet&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    lazy_static! &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">ref</span> HASHTAG_REGEX: Regex = Regex::<span class="title function_ invoke__">new</span>(<span class="string">r&quot;\#[a-zA-Z][0-9a-zA-Z_]*&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    HASHTAG_REGEX</span><br><span class="line">        .<span class="title function_ invoke__">find_iter</span>(text)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|mat| mat.<span class="title function_ invoke__">as_str</span>())</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tweet</span> = <span class="string">&quot;Hey #world, I just got my new #dog, say hello to Till. #dog #forever #2 #_ &quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tags</span> = <span class="title function_ invoke__">extract_hashtags</span>(tweet);</span><br><span class="line">    <span class="built_in">assert!</span>(tags.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;#dog&quot;</span>) &amp;&amp; tags.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;#forever&quot;</span>) &amp;&amp; tags.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;#world&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(tags.<span class="title function_ invoke__">len</span>(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="1-3-从文本提取电话号码">1.3 从文本提取电话号码</h3><p>  需要安装<code>error-chain</code>库，可通过<code>cargo add error-chain</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br><span class="line"><span class="attr">regex</span> = <span class="string">&quot;1.8.1&quot;</span></span><br></pre></td></tr></table></figure><p>  使用 <code>Regex::captures_iter</code> 处理一个文本字符串，以捕获多个电话号码。这里的例子中是美国电话号码格式。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> regex::Regex;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Regex</span>(regex::Error);</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PhoneNumber</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    area: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    exchange: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    subscriber: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; fmt::Display <span class="keyword">for</span> <span class="title class_">PhoneNumber</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;1 (&#123;&#125;) &#123;&#125;-&#123;&#125;&quot;</span>, <span class="keyword">self</span>.area, <span class="keyword">self</span>.exchange, <span class="keyword">self</span>.subscriber)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">phone_text</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">    +1 505 881 9292 (v) +1 505 778 2212 (c) +1 505 881 9297 (f)</span></span><br><span class="line"><span class="string">    (202) 991 9534</span></span><br><span class="line"><span class="string">    Alex 5553920011</span></span><br><span class="line"><span class="string">    1 (800) 233-2010</span></span><br><span class="line"><span class="string">    1.299.339.1020&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">re</span> = Regex::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        <span class="string">r#&quot;(?x)</span></span><br><span class="line"><span class="string">          (?:\+?1)?                       # 国家代码，可选项</span></span><br><span class="line"><span class="string">          [\s\.]?</span></span><br><span class="line"><span class="string">          (([2-9]\d&#123;2&#125;)|\(([2-9]\d&#123;2&#125;)\)) # 地区代码</span></span><br><span class="line"><span class="string">          [\s\.\-]?</span></span><br><span class="line"><span class="string">          ([2-9]\d&#123;2&#125;)                    # 交换代码</span></span><br><span class="line"><span class="string">          [\s\.\-]?</span></span><br><span class="line"><span class="string">          (\d&#123;4&#125;)                         # 用户号码&quot;#</span>,</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">phone_numbers</span> = re.<span class="title function_ invoke__">captures_iter</span>(phone_text).<span class="title function_ invoke__">filter_map</span>(|cap| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">groups</span> = (cap.<span class="title function_ invoke__">get</span>(<span class="number">2</span>).<span class="title function_ invoke__">or</span>(cap.<span class="title function_ invoke__">get</span>(<span class="number">3</span>)), cap.<span class="title function_ invoke__">get</span>(<span class="number">4</span>), cap.<span class="title function_ invoke__">get</span>(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">match</span> groups &#123;</span><br><span class="line">            (<span class="title function_ invoke__">Some</span>(area), <span class="title function_ invoke__">Some</span>(ext), <span class="title function_ invoke__">Some</span>(sub)) =&gt; <span class="title function_ invoke__">Some</span>(PhoneNumber &#123;</span><br><span class="line">                area: area.<span class="title function_ invoke__">as_str</span>(),</span><br><span class="line">                exchange: ext.<span class="title function_ invoke__">as_str</span>(),</span><br><span class="line">                subscriber: sub.<span class="title function_ invoke__">as_str</span>(),</span><br><span class="line">            &#125;),</span><br><span class="line">            _ =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        phone_numbers.<span class="title function_ invoke__">map</span>(|m| m.<span class="title function_ invoke__">to_string</span>()).collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;(),</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="string">&quot;1 (505) 881-9292&quot;</span>,</span><br><span class="line">            <span class="string">&quot;1 (505) 778-2212&quot;</span>,</span><br><span class="line">            <span class="string">&quot;1 (505) 881-9297&quot;</span>,</span><br><span class="line">            <span class="string">&quot;1 (202) 991-9534&quot;</span>,</span><br><span class="line">            <span class="string">&quot;1 (555) 392-0011&quot;</span>,</span><br><span class="line">            <span class="string">&quot;1 (800) 233-2010&quot;</span>,</span><br><span class="line">            <span class="string">&quot;1 (299) 339-1020&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="1-4-通过匹配多个正则表达式来筛选日志文件">1.4 通过匹配多个正则表达式来筛选日志文件</h3><p>  读取名为 <code>application.log</code>(可以根据以下输出的内容自建) 的文件，并且只输出包含下列内容的行：“<code>version X.X.X</code>”、端口为 <code>443</code> 的 IP 地址（如 “<code>192.168.0.1:443</code>”）、特定警告。正则表达集构造器 <code>regex::RegexSetBuilder</code> 构建了正则表达式集 <code>regex::RegexSet</code>。由于反斜杠在正则表达式中非常常见，因此使用原始字符串字面量可以使它们更具可读性。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;BufReader, BufRead&#125;;</span><br><span class="line"><span class="keyword">use</span> regex::RegexSetBuilder;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">Regex</span>(regex::Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">log_path</span> = <span class="string">&quot;application.log&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">buffered</span> = BufReader::<span class="title function_ invoke__">new</span>(File::<span class="title function_ invoke__">open</span>(log_path)?);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">set</span> = RegexSetBuilder::<span class="title function_ invoke__">new</span>(&amp;[</span><br><span class="line">        <span class="string">r#&quot;version &quot;\d\.\d\.\d&quot;&quot;#</span>,</span><br><span class="line">        <span class="string">r#&quot;\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;:443&quot;#</span>,</span><br><span class="line">        <span class="string">r#&quot;warning.*timeout expired&quot;#</span>,</span><br><span class="line">    ]).<span class="title function_ invoke__">case_insensitive</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="title function_ invoke__">build</span>()?;</span><br><span class="line"></span><br><span class="line">    buffered</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|line| line.<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| set.<span class="title function_ invoke__">is_match</span>(line.<span class="title function_ invoke__">as_str</span>()))</span><br><span class="line">        .<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x));</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出：</li></ul><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">fasfsafad version 1.2.1 afsadfwew 163.211.115.56:443 asfasdfsfsdfas warning</span><br><span class="line">fasfsafad version 1.2.2 afsadfwew 63.211.115.56:443 asfasdfsfsdfas</span><br><span class="line">fasfsafad version 1.2.3 afsadfwew 13.211.115.56:443 asfasdfsfsdfas timeout expired</span><br></pre></td></tr></table></figure><h3 id="1-5-文本模式替换">1.5 文本模式替换</h3><p>  将所有出现的国际标准 <code>ISO 8601</code> 日期模式 <code>YYYY-MM-DD</code> 替换为美式英语及中式日期模式。例如： <code>2013-01-15</code> 替换为 <code>01/15/2013</code>。<code>Regex::replace_all</code> 方法将替换整个正则表示匹配的所有内容。<code>&amp;str</code> 实现了 <code>Replacer</code> trait，它允许类似 <code>$abcde</code> 的变量引用相应的搜索匹配模式（search regex）中的命名捕获组 (<code>?P&lt;abcde&gt;REGEX</code>)。有关示例和转义的详细信息，请参阅替换字符串语法。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> regex::Regex;</span><br><span class="line"><span class="keyword">use</span> std::borrow::Cow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">reformat_dates_us</span>(before: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Cow&lt;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    lazy_static! &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">ref</span> ISO8601_DATE_REGEX: Regex =</span><br><span class="line">            Regex::<span class="title function_ invoke__">new</span>(<span class="string">r&quot;(?P&lt;y&gt;\d&#123;4&#125;)-(?P&lt;m&gt;\d&#123;2&#125;)-(?P&lt;d&gt;\d&#123;2&#125;)&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ISO8601_DATE_REGEX.<span class="title function_ invoke__">replace_all</span>(before, <span class="string">&quot;$m/$d/$y&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">reformat_dates_cn</span>(before: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Cow&lt;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    lazy_static! &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">ref</span> ISO8601_DATE_REGEX: Regex =</span><br><span class="line">            Regex::<span class="title function_ invoke__">new</span>(<span class="string">r&quot;(?P&lt;y&gt;\d&#123;4&#125;)-(?P&lt;m&gt;\d&#123;2&#125;)-(?P&lt;d&gt;\d&#123;2&#125;)&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ISO8601_DATE_REGEX.<span class="title function_ invoke__">replace_all</span>(before, <span class="string">&quot;$y年$m月$d日&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">before</span> = <span class="string">&quot;2012-03-14, 2013-01-15 and 2014-07-05&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">after_us</span> = <span class="title function_ invoke__">reformat_dates_us</span>(before);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(after_us, <span class="string">&quot;03/14/2012, 01/15/2013 and 07/05/2014&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">after_cn</span> = <span class="title function_ invoke__">reformat_dates_cn</span>(before);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        after_cn,</span><br><span class="line">        <span class="string">&quot;2012年03月14日, 2013年01月15日 and 2014年07月05日&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h2 id="2-字符串解析">2. 字符串解析</h2><h3 id="2-1-收集-Unicode-字符">2.1 收集 <code>Unicode</code> 字符</h3><p>  需要安装<code>unicode-segmentation</code>库，可通过<code>cargo add unicode-segmentation</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">unicode-segmentation</span> = <span class="string">&quot;1.10.1&quot;</span></span><br></pre></td></tr></table></figure><p>  使用 <code>unicode-segmentation</code> crate 中的 <code>UnicodeSegmentation::graphemes</code> 函数，从 <code>UTF-8</code> 字符串中收集个别的 <code>Unicode</code> 字符。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> unicode_segmentation::UnicodeSegmentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="string">&quot;José Guimarães 大胃王\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">graphemes</span> = UnicodeSegmentation::<span class="title function_ invoke__">graphemes</span>(name, <span class="literal">true</span>).collect::&lt;<span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt;&gt;();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, graphemes);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(graphemes[<span class="number">3</span>], <span class="string">&quot;é&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="2-2-自定义结构体并实现-FromStr-trait">2.2 自定义结构体并实现 <code>FromStr</code> trait</h3><p>  实例中，创建一个自定义结构体 <code>RGB</code> 并实现 <code>FromStr</code> trait，以将提供的颜色十六进制代码转换为其 <code>RGB</code> 颜色代码。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RGB</span> &#123;</span><br><span class="line">    r: <span class="type">u8</span>,</span><br><span class="line">    g: <span class="type">u8</span>,</span><br><span class="line">    b: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FromStr</span> <span class="keyword">for</span> <span class="title class_">RGB</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Err</span> = std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析格式为 &#x27;#rRgGbB..&#x27; 的颜色十六进制代码</span></span><br><span class="line">    <span class="comment">// 将其转换为 &#x27;RGB&#x27; 实例</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from_str</span>(hex_code: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, <span class="keyword">Self</span>::<span class="literal">Err</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// u8::from_str_radix(src: &amp;str, radix: u32)</span></span><br><span class="line">        <span class="comment">// 将给定的字符串切片转换为 u8</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r</span>: <span class="type">u8</span> = <span class="type">u8</span>::<span class="title function_ invoke__">from_str_radix</span>(&amp;hex_code[<span class="number">1</span>..<span class="number">3</span>], <span class="number">16</span>)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">g</span>: <span class="type">u8</span> = <span class="type">u8</span>::<span class="title function_ invoke__">from_str_radix</span>(&amp;hex_code[<span class="number">3</span>..<span class="number">5</span>], <span class="number">16</span>)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u8</span> = <span class="type">u8</span>::<span class="title function_ invoke__">from_str_radix</span>(&amp;hex_code[<span class="number">5</span>..<span class="number">7</span>], <span class="number">16</span>)?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(RGB &#123; r, g, b &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">code</span>: &amp;<span class="type">str</span> = &amp;<span class="string">r&quot;#fa7268&quot;</span>;</span><br><span class="line">    <span class="keyword">match</span> RGB::<span class="title function_ invoke__">from_str</span>(code) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(rgb) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">r&quot;RGB颜色代码是: R: &#123;&#125; G: &#123;&#125; B: &#123;&#125;&quot;</span>, rgb.r, rgb.g, rgb.b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 不是有效的颜色十六进制代码！&quot;</span>, code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 from_str 函数执行是否符合预期</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        RGB::<span class="title function_ invoke__">from_str</span>(&amp;<span class="string">r&quot;#fa7268&quot;</span>).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        RGB &#123;</span><br><span class="line">            r: <span class="number">250</span>,</span><br><span class="line">            g: <span class="number">114</span>,</span><br><span class="line">            b: <span class="number">104</span></span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出及校验</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RGB颜色代码是: R: 250 G: 114 B: 104</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】十七 科学计算</title>
      <link href="/news/1682928144687.html"/>
      <url>/news/1682928144687.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-数学">1. 数学</h2><h3 id="1-1-线性代数">1.1 线性代数</h3><p>  需要安装<code>ndarray</code>库，可通过<code>cargo add ndarray</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">ndarray</span> = <span class="string">&quot;0.15.6&quot;</span></span><br></pre></td></tr></table></figure><h4 id="1-1-1-矩阵相加">1.1.1 矩阵相加</h4><p>  使用 <code>ndarray::arr2</code> 创建两个二维（2-D）矩阵，并按元素方式求和。注意：<code>sum</code> 的计算方式为 <code>let sum = &amp;a + &amp;b</code>，借用 <code>&amp;</code> 运算符获得 <code>a</code> 和 <code>b</code> 的引用，可避免销毁他们，使它们可以稍后显示。这样，就创建了一个包含其和的新数组。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ndarray::arr2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">arr2</span>(&amp;[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">arr2</span>(&amp;[[<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = &amp;a + &amp;b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[1, 2, 3],</span><br><span class="line"> [4, 5, 6]]</span><br><span class="line">+</span><br><span class="line">[[6, 5, 4],</span><br><span class="line"> [3, 2, 1]]</span><br><span class="line">=</span><br><span class="line">[[7, 7, 7],</span><br><span class="line"> [7, 7, 7]]</span><br></pre></td></tr></table></figure><h4 id="1-1-2-矩阵相乘">1.1.2 矩阵相乘</h4><p>  使用 <code>ndarray::arr2</code> 创建两个矩阵，并使用 <code>ndarray::ArrayBase::dot</code> 对它们执行矩阵乘法。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ndarray::arr2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">arr2</span>(&amp;[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">arr2</span>(&amp;[[<span class="number">6</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">2</span>], [<span class="number">4</span>, <span class="number">1</span>]]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">dot</span>(&amp;b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[28, 10], <span class="comment"># 28 = a[1][1] * b[1][1] + a[1][2] * b[2][1] + a[1][3] * b[3][1]</span></span><br><span class="line"> [73, 28]]</span><br></pre></td></tr></table></figure><h4 id="1-1-3-标量、向量Vector、矩阵相乘">1.1.3 标量、向量<code>Vector</code>、矩阵相乘</h4><p>  使用 <code>ndarray::arr1</code> 创建一维（1-D）数组或向量（<code>vector</code>），使用 <code>ndarray::arr2</code> 创建二维（2-D）数组（矩阵）。首先，一个标量乘以一个 <code>vector</code> 得到另一个 <code>vector</code>。然后，使用 <code>ndarray::Array2::dot</code> 将矩阵乘以新的 <code>vector</code>（矩阵相乘使用 <code>dot</code> 函数，而 <code>*</code> 运算符执行元素方式的乘法）。在 <code>ndarray</code> crate 中，根据上下文，一维数组可以解释为行 <code>vector</code> 或列 <code>vector</code>。如果 <code>vector</code> 表示的方向很重要，则必须使用只有一行或一列的二维（2-D）数组。在本实例中，<code>vector</code> 是右侧的一维（1-D）数组，因此 <code>dot</code> 函数将其处理为列 <code>vector</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ndarray::&#123;arr1, arr2, Array1&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scalar</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vector</span> = <span class="title function_ invoke__">arr1</span>(&amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">matrix</span> = <span class="title function_ invoke__">arr2</span>(&amp;[[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                        [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_vector</span>: Array1&lt;_&gt; = scalar * vector;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, new_vector);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_matrix</span> = matrix.<span class="title function_ invoke__">dot</span>(&amp;new_vector);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, new_matrix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[4, 8, 12] <span class="comment"># new_vector 列</span></span><br><span class="line">[128, 200] <span class="comment"># new_matrix 列</span></span><br></pre></td></tr></table></figure><h4 id="1-1-4-向量Vector比较">1.1.4 向量<code>Vector</code>比较</h4><p>  需要调整<code>ndarray</code>库和approx库，可通过<code>cargo add ndarray --features approx</code> 命令重新安装及安装<code>cargo add approx</code></p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">approx</span> = <span class="string">&quot;0.4&quot;</span> <span class="comment"># 代码目前在0.4版本测试通过，最新0.5.1上测试未通过</span></span><br><span class="line"><span class="attr">ndarray</span> = &#123; version = <span class="string">&quot;0.15.6&quot;</span>, features = [<span class="string">&quot;approx&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><p>  <code>ndarray</code> crate 支持多种创建数组的方法——此实例使用 <code>from</code> 从 <code>std::Vec</code> 创建数组 <code>ndarray::Array</code>。然后，对数组以元素方式求和。下面的实例按元素方式比较两个浮点型 <code>vector</code>。浮点数的存储通常不精确，因此很难进行精确的比较。但是，<code>approx</code> crate 中的 <code>assert_abs_diff_eq!</code> 宏允许方便地比较浮点型元素。要将 <code>approx</code> 和 <code>ndarray</code> 两个 crate一起使用，必须在 <code>Cargo.toml</code> 文件中的 <code>ndarray</code> 依赖项添加 <code>approx</code> 特性。例如：<code>ndarray = &#123; version = &quot;0.13&quot;, features = [&quot;approx&quot;] &#125;</code>。此实例还包含其他所有权示例。在这里，<code>let z = a + b</code> 执行后，会销毁<code>a and b</code>，然后所有权会转移到 <code>z</code>。或者，<code>let w = &amp;c + &amp;d</code> 创建一个新的 <code>vector</code>，而不销毁 <code>c</code> 或者 <code>d</code>，允许以后对它们进行修改。有关其他详细信息，请参见带有两个数组的二进制运算符。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ndarray::Array;</span><br><span class="line"><span class="keyword">use</span> approx::assert_abs_diff_eq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Array::<span class="title function_ invoke__">from</span>(<span class="built_in">vec!</span>[<span class="number">1</span>., <span class="number">2</span>., <span class="number">3</span>., <span class="number">4</span>., <span class="number">5</span>.]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Array::<span class="title function_ invoke__">from</span>(<span class="built_in">vec!</span>[<span class="number">5</span>., <span class="number">4</span>., <span class="number">3</span>., <span class="number">2</span>., <span class="number">1</span>.]);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = Array::<span class="title function_ invoke__">from</span>(<span class="built_in">vec!</span>[<span class="number">1</span>., <span class="number">2</span>., <span class="number">3</span>., <span class="number">4</span>., <span class="number">5</span>.]);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">d</span> = Array::<span class="title function_ invoke__">from</span>(<span class="built_in">vec!</span>[<span class="number">5</span>., <span class="number">4</span>., <span class="number">3</span>., <span class="number">2</span>., <span class="number">1</span>.]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = a + b;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = &amp;c + &amp;d;</span><br><span class="line"></span><br><span class="line">    assert_abs_diff_eq!(z, Array::<span class="title function_ invoke__">from</span>(<span class="built_in">vec!</span>[<span class="number">6</span>., <span class="number">6</span>., <span class="number">6</span>., <span class="number">6</span>., <span class="number">6</span>.]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c = &#123;&#125;&quot;</span>, c);</span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">10</span>.;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">10</span>.;</span><br><span class="line"></span><br><span class="line">    assert_abs_diff_eq!(w, Array::<span class="title function_ invoke__">from</span>(<span class="built_in">vec!</span>[<span class="number">6</span>., <span class="number">6</span>., <span class="number">6</span>., <span class="number">6</span>., <span class="number">6</span>.]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[4, 8, 12] <span class="comment"># new_vector 列</span></span><br><span class="line">[128, 200] <span class="comment"># new_matrix 列</span></span><br></pre></td></tr></table></figure><h4 id="1-1-5-向量Vector范数">1.1.5 向量<code>Vector</code>范数</h4><p>  范数，是具有“长度”概念的函数。在线性代数、泛函分析及相关的数学领域，范数是一个函数，是矢量空间内的所有矢量赋予非零的正长度或大小。半范数可以为非零的矢量赋予零长度。<br>  示例展示了 <code>Array1</code> 类型、<code>ArrayView1</code> 类型、<code>fold</code> 方法，以及 <code>dot</code> 方法在计算给定 <code>vector</code> 的 <code>l1</code> 和 <code>l2</code> 范数时的用法。 <code>l2_norm</code> 函数是两者中较简单的，它计算一个 <code>vector</code> 与自身的点积（<code>dot</code> product，数量积）的平方根。 <code>l1_norm</code> 函数通过 <code>fold</code> 运算来计算元素的绝对值（也可以通过 <code>x.mapv(f64::abs).scalar_sum()</code> 执行，但是会为 <code>mapv</code> 的结果分配一个新的数组）。请注意：<code>l1_norm</code> 和 <code>l2_norm</code> 都采用 <code>ArrayView1</code> 类型。这个实例考虑了 <code>vector</code> 范数，所以范数函数只需要接受一维视图（<code>ArrayView1</code>）。虽然函数可以使用类型为 <code>&amp;Array1&lt;f64&gt;</code> 的参数，但这将要求调用方引用拥有所有权的数组，这比访问视图更为严格（因为视图可以从任意数组或视图创建，而不仅仅是从拥有所有权的数组创建）。<code>Array</code> 和 <code>ArrayView</code> 都是 <code>ArrayBase</code> 的类型别名。于是，大多数的调用方参数类型可以是 <code>&amp;ArrayBase&lt;S, Ix1&gt; where S: Data</code>，这样调用方就可以使用 <code>&amp;array</code> 或者 <code>&amp;view</code> 而不是 <code>x.view()</code>。如果该函数是公共 API 的一部分，那么对于用户来说，这可能是一个更好的选择。对于内部函数，更简明的 <code>ArrayView1&lt;f64&gt;</code> 或许更合适。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ndarray::&#123;array, Array1, ArrayView1&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">l1_norm</span>(x: ArrayView1&lt;<span class="type">f64</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">fold</span>(<span class="number">0</span>., |acc, elem| acc + elem.<span class="title function_ invoke__">abs</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">l2_norm</span>(x: ArrayView1&lt;<span class="type">f64</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">dot</span>(&amp;x).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">normalize</span>(<span class="keyword">mut</span> x: Array1&lt;<span class="type">f64</span>&gt;) <span class="punctuation">-&gt;</span> Array1&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">norm</span> = <span class="title function_ invoke__">l2_norm</span>(x.<span class="title function_ invoke__">view</span>());</span><br><span class="line">    x.<span class="title function_ invoke__">mapv_inplace</span>(|e| e / norm);</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = array![<span class="number">1</span>., <span class="number">2</span>., <span class="number">3</span>., <span class="number">4</span>., <span class="number">5</span>.];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;||x||_2 = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">l2_norm</span>(x.<span class="title function_ invoke__">view</span>()));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;||x||_1 = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">l1_norm</span>(x.<span class="title function_ invoke__">view</span>()));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;标准化 x 收益率 &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">normalize</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">||x||_2 = 7.416198487095663</span><br><span class="line">||x||_1 = 15</span><br><span class="line">标准化 x 收益率 [0.13483997249264842, 0.26967994498529685, 0.40451991747794525, 0.5393598899705937, 0.674199862463242], shape=[5], strides=[1], layout=CFcf (0xf), const ndim=1</span><br></pre></td></tr></table></figure><h4 id="1-1-6-矩阵求逆">1.1.6 矩阵求逆</h4><p>  需要安装<code>nalgebra</code>库，可通过<code>cargo add nalgebra</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nalgebra</span> = <span class="string">&quot;0.32.2&quot;</span></span><br></pre></td></tr></table></figure><p>  用 <code>nalgebra::Matrix3</code> 创建一个 3x3 的矩阵，如果可能的话，将其求逆。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> nalgebra::Matrix3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m1</span> = Matrix3::<span class="title function_ invoke__">new</span>(<span class="number">2.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">3.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;矩阵m1 = &#123;&#125;&quot;</span>, m1);</span><br><span class="line">    <span class="keyword">match</span> m1.<span class="title function_ invoke__">try_inverse</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(inv) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;m1 的逆矩阵是: &#123;&#125;&quot;</span>, inv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;m1不可逆！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">矩阵m1 = </span><br><span class="line">  ┌       ┐</span><br><span class="line">  │ 2 1 1 │</span><br><span class="line">  │ 3 2 1 │</span><br><span class="line">  │ 2 1 2 │</span><br><span class="line">  └       ┘</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m1 的逆矩阵是: </span><br><span class="line">  ┌          ┐</span><br><span class="line">  │  3 -1 -1 │</span><br><span class="line">  │ -4  2  1 │</span><br><span class="line">  │ -1  0  1 │</span><br><span class="line">  └          ┘</span><br></pre></td></tr></table></figure><h4 id="1-1-7-（反）序列化矩阵">1.1.7 （反）序列化矩阵</h4><p>  实例实现将矩阵序列化为 <code>JSON</code>，以及从 <code>JSON</code> 反序列化出矩阵。序列化由 <code>serde_json::to_string</code> 处理，<code>serde_json::from_str</code> 则执行反序列化。请注意：序列化后再反序列化将返回原始矩阵。</p><p>  需要调整<code>nalgebra</code>和安装<code>serde_json</code>库，可通过<code>cargo add nalgebra --features serde-serialize</code>添加序列化特征,<code>cargo add serde_json</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nalgebra</span> = &#123; version = <span class="string">&quot;0.32.2&quot;</span>, features = [<span class="string">&quot;serde-serialize&quot;</span>] &#125;</span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0.96&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> nalgebra;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> serde_json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> nalgebra::DMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">row_slice</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = (<span class="number">1</span>..<span class="number">5001</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">matrix</span> = DMatrix::<span class="title function_ invoke__">from_row_slice</span>(<span class="number">50</span>, <span class="number">100</span>, &amp;row_slice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化矩阵</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">serialized_matrix</span> = serde_json::<span class="title function_ invoke__">to_string</span>(&amp;matrix)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化出矩阵</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">deserialized_matrix</span>: DMatrix&lt;<span class="type">i32</span>&gt; = serde_json::<span class="title function_ invoke__">from_str</span>(&amp;serialized_matrix)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证反序列化出的矩阵 `deserialized_matrix` 等同于原始矩阵 `matrix`</span></span><br><span class="line">    <span class="built_in">assert!</span>(deserialized_matrix == matrix);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="1-2-三角学">1.2 三角学</h3><h4 id="1-2-1-计算三角形的边长">1.2.1 计算三角形的边长</h4><p>  计算直角三角形斜边的长度，其中斜边的角度为 <code>2</code> 弧度，对边长度为 <code>80</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">angle</span>: <span class="type">f64</span> = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">side_length</span> = <span class="number">80.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hypotenuse</span> = side_length / angle.<span class="title function_ invoke__">sin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;斜边: &#123;&#125;&quot;</span>, hypotenuse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">斜边: 87.98001362356932</span><br></pre></td></tr></table></figure><h4 id="1-2-2-验证正切（tan）等于正弦（sin）除以余弦（cos）">1.2.2 验证正切（<code>tan</code>）等于正弦（<code>sin</code>）除以余弦（<code>cos</code>）</h4><p>  验证 <code>tan(x)</code> 是否等于 <code>sin(x)/cos(x)</code>，其中 <code>x=6</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">f64</span> = <span class="number">6.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = x.<span class="title function_ invoke__">tan</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = x.<span class="title function_ invoke__">sin</span>() / x.<span class="title function_ invoke__">cos</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h4 id="1-2-3-地球上两点之间的距离">1.2.3 地球上两点之间的距离</h4><p>  实例使用<strong>半正矢公式</strong>计算地球上两点之间的距离（以公里为单位）。两个点用一对经纬度表示，然后，<code>to_radians</code> 将它们转换为弧度。<code>sin</code>、<code>cos</code>、<code>powi</code> 以及 <code>sqrt</code> 计算中心角。最终，可以计算出距离。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">earth_radius_kilometer</span> = <span class="number">6371.0_f64</span>;</span><br><span class="line">    <span class="keyword">let</span> (paris_latitude_degrees, paris_longitude_degrees) = (<span class="number">48.85341_f64</span>, -<span class="number">2.34880_f64</span>);</span><br><span class="line">    <span class="keyword">let</span> (london_latitude_degrees, london_longitude_degrees) = (<span class="number">51.50853_f64</span>, -<span class="number">0.12574_f64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">paris_latitude</span> = paris_latitude_degrees.<span class="title function_ invoke__">to_radians</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">london_latitude</span> = london_latitude_degrees.<span class="title function_ invoke__">to_radians</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">delta_latitude</span> = (paris_latitude_degrees - london_latitude_degrees).<span class="title function_ invoke__">to_radians</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">delta_longitude</span> = (paris_longitude_degrees - london_longitude_degrees).<span class="title function_ invoke__">to_radians</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">central_angle_inner</span> = (delta_latitude / <span class="number">2.0</span>).<span class="title function_ invoke__">sin</span>().<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)</span><br><span class="line">        + paris_latitude.<span class="title function_ invoke__">cos</span>() * london_latitude.<span class="title function_ invoke__">cos</span>() * (delta_longitude / <span class="number">2.0</span>).<span class="title function_ invoke__">sin</span>().<span class="title function_ invoke__">powi</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">central_angle</span> = <span class="number">2.0</span> * central_angle_inner.<span class="title function_ invoke__">sqrt</span>().<span class="title function_ invoke__">asin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">distance</span> = earth_radius_kilometer * central_angle;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;地球表面巴黎和伦敦之间的距离是 &#123;:.1&#125; 公里&quot;</span>, distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">地球表面巴黎和伦敦之间的距离是 335.0 公里</span><br></pre></td></tr></table></figure><h3 id="1-3-复数">1.3 复数</h3><p>  需要安装<code>num</code>库，可通过<code>cargo add num</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">num</span> = <span class="string">&quot;0.4.0&quot;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-1-创建复数">1.3.1 创建复数</h4><p>  创建类型<code>num::complex::Complex</code> 的复数，复数的实部和虚部必须是同一类型</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">complex_integer</span> = num::complex::Complex::<span class="title function_ invoke__">new</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">complex_float</span> = num::complex::Complex::<span class="title function_ invoke__">new</span>(<span class="number">10.1</span>, <span class="number">20.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;复整数: &#123;&#125;&quot;</span>, complex_integer);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;复浮点数: &#123;&#125;&quot;</span>, complex_float);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">复整数: 10+20i</span><br><span class="line">复浮点数: 10.1+20.1i</span><br></pre></td></tr></table></figure><h4 id="1-3-2-复数相加">1.3.2 复数相加</h4><p>  对复数执行数学运算与对内置类型执行数学运算是一样的：计算的数字必须是相同的类型（如浮点数或整数）</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">complex_num1</span> = num::complex::Complex::<span class="title function_ invoke__">new</span>(<span class="number">10.0</span>, <span class="number">20.0</span>); <span class="comment">// 必须为浮点数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">complex_num2</span> = num::complex::Complex::<span class="title function_ invoke__">new</span>(<span class="number">3.1</span>, -<span class="number">4.2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = complex_num1 + complex_num2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;和: &#123;&#125;&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">和: 13.1+15.8i</span><br></pre></td></tr></table></figure><h4 id="1-3-3-复数的数学函数">1.3.3 复数的数学函数</h4><p>  对复数执行数学运算与对内置类型执行数学运算是一样的：计算的数字必须是相同的类型（如浮点数或整数）</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> num::complex::Complex;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">f64</span>::consts::PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Complex::<span class="title function_ invoke__">new</span>(<span class="number">0.0</span>, <span class="number">2.0</span> * PI);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;e^(2i * pi) = &#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">exp</span>()); <span class="comment">// = -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">e^(2i * pi) = 1-0.00000000000000024492935982947064i <span class="comment"># 输出不是精确的 1 而是带有一个小的虚部，这是由于浮点数的有限精度造成的。</span></span><br></pre></td></tr></table></figure><h3 id="1-4-统计学">1.4 统计学</h3><h4 id="1-4-1-集中趋势度量">1.4.1 集中趋势度量</h4><p>  本节实例计算 Rust 数组中包含的数据集的集中趋势度量。对于一个空的数据集，可能没有平均数、中位数或众数去计算，因此每个函数都返回 <code>[Option]</code> ，由调用者处理。</p><ul><li>实例1: 是通过对数据引用生成一个迭代器，然后计算平均数（所有测量值的总和除以测量值的计数），并使用 <code>[sum]</code> 和 <code>[len]</code> 函数分别确定值的总和及值的计数。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = data.<span class="title function_ invoke__">iter</span>().sum::&lt;<span class="type">i32</span>&gt;() <span class="keyword">as</span> <span class="type">f32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = data.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mean</span> = <span class="keyword">match</span> count &#123;</span><br><span class="line">        positive <span class="keyword">if</span> positive &gt; <span class="number">0</span> =&gt; <span class="title function_ invoke__">Some</span>(sum / count <span class="keyword">as</span> <span class="type">f32</span>),</span><br><span class="line">        _ =&gt; <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;数据的平均值是 &#123;:?&#125;&quot;</span>, mean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">数据的平均值是 Some(5.4)</span><br></pre></td></tr></table></figure><ul><li>实例2: 使用快速选择算法（Quick Select Algorithm）计算中位数，该算法只对已知可能包含中位数的数据集的分区进行排序，从而避免了完整[排序]<code>[sort]</code>。该算法使用 <code>[cmp]</code> 和 <code>[Ordering]</code> 简便地地决定要检查的下一个分区，并使用 <code>[split_at]</code> 为每个步骤的下一个分区选择一个任意的枢轴量。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">partition</span>(data: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, <span class="type">i32</span>, <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;)&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> data.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> (pivot_slice, tail) = data.<span class="title function_ invoke__">split_at</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pivot</span> = pivot_slice[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">let</span> (left, right) = tail.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>((<span class="built_in">vec!</span>[], <span class="built_in">vec!</span>[]), |<span class="keyword">mut</span> splits, next| &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">let</span> (<span class="keyword">ref</span> <span class="keyword">mut</span> left, <span class="keyword">ref</span> <span class="keyword">mut</span> right) = &amp;<span class="keyword">mut</span> splits;</span><br><span class="line">                    <span class="keyword">if</span> next &lt; &amp;pivot &#123;</span><br><span class="line">                        left.<span class="title function_ invoke__">push</span>(*next);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right.<span class="title function_ invoke__">push</span>(*next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                splits</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Some</span>((left, pivot, right))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">select</span>(data: &amp;[<span class="type">i32</span>], k: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">part</span> = <span class="title function_ invoke__">partition</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> part &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>((left, pivot, right)) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pivot_idx</span> = left.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">match</span> pivot_idx.<span class="title function_ invoke__">cmp</span>(&amp;k) &#123;</span><br><span class="line">                Ordering::Equal =&gt; <span class="title function_ invoke__">Some</span>(pivot),</span><br><span class="line">                Ordering::Greater =&gt; <span class="title function_ invoke__">select</span>(&amp;left, k),</span><br><span class="line">                Ordering::Less =&gt; <span class="title function_ invoke__">select</span>(&amp;right, k - (pivot_idx + <span class="number">1</span>)),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">median</span>(data: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">size</span> = data.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> size &#123;</span><br><span class="line">        even <span class="keyword">if</span> even % <span class="number">2</span> == <span class="number">0</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">fst_med</span> = <span class="title function_ invoke__">select</span>(data, (even / <span class="number">2</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">snd_med</span> = <span class="title function_ invoke__">select</span>(data, even / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">match</span> (fst_med, snd_med) &#123;</span><br><span class="line">                (<span class="title function_ invoke__">Some</span>(fst), <span class="title function_ invoke__">Some</span>(snd)) =&gt; <span class="title function_ invoke__">Some</span>((fst + snd) <span class="keyword">as</span> <span class="type">f32</span> / <span class="number">2.0</span>),</span><br><span class="line">                _ =&gt; <span class="literal">None</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        odd =&gt; <span class="title function_ invoke__">select</span>(data, odd / <span class="number">2</span>).<span class="title function_ invoke__">map</span>(|x| x <span class="keyword">as</span> <span class="type">f32</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">part</span> = <span class="title function_ invoke__">partition</span>(&amp;data);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;分区是 &#123;:?&#125;&quot;</span>, part);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sel</span> = <span class="title function_ invoke__">select</span>(&amp;data, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;有序索引 &#123;&#125; 处的选择是 &#123;:?&#125;&quot;</span>, <span class="number">5</span>, sel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">med</span> = <span class="title function_ invoke__">median</span>(&amp;data);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;中位数是 &#123;:?&#125;&quot;</span>, med);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">分区是 Some(([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="number">3</span>, [<span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>]))</span><br><span class="line">有序索引 5 处的选择是 Some(6)</span><br><span class="line">中位数是 Some(5.5)</span><br></pre></td></tr></table></figure><ul><li>实例3: 使用可变的 <code>[HashMap]</code> 来计算众数，<code>[fold]</code> 和 <code>[entry]</code> API 用来从集合中收集每个不同整数的计数。<code>[HashMap]</code> 中最常见的值可以用 <code>[max_by_key]</code> 取得。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">frequencies</span> = data.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(HashMap::<span class="title function_ invoke__">new</span>(), |<span class="keyword">mut</span> freqs, value| &#123;</span><br><span class="line">        *freqs.<span class="title function_ invoke__">entry</span>(value).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>) += <span class="number">1</span>;</span><br><span class="line">        freqs</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mode</span> = frequencies</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">max_by_key</span>(|&amp;(_, count)| count)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(value, _)| *value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;众数是 &#123;:?&#125;&quot;</span>, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">众数是 Some(1)</span><br></pre></td></tr></table></figure><h4 id="1-4-2-计算标准偏差">1.4.2 计算标准偏差</h4><p>  计算一组测量值的标准偏差和 <code>z</code> 分数（z-score）。标准偏差定义为方差的平方根（用 <code>f32</code> 浮点型的 <code>[sqrt]</code> 计算），其中方差是每个测量值与平均数之间的平方差的和除以测量次数。<code>z</code>分数（z-score）是指单个测量值偏离数据集平均数的标准差数，<code>z = (x - μ) / σ</code>，其中 <code>x</code> 是数据点的值，<code>μ</code> 是数据集的平均值，<code>σ</code> 是数据集的标准差。。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mean</span>(data: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = data.<span class="title function_ invoke__">iter</span>().sum::&lt;<span class="type">i32</span>&gt;() <span class="keyword">as</span> <span class="type">f32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = data.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> count &#123;</span><br><span class="line">        positive <span class="keyword">if</span> positive &gt; <span class="number">0</span> =&gt; <span class="title function_ invoke__">Some</span>(sum / count <span class="keyword">as</span> <span class="type">f32</span>),</span><br><span class="line">        _ =&gt; <span class="literal">None</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">std_deviation</span>(data: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">match</span> (<span class="title function_ invoke__">mean</span>(data), data.<span class="title function_ invoke__">len</span>()) &#123;</span><br><span class="line">        (<span class="title function_ invoke__">Some</span>(data_mean), count) <span class="keyword">if</span> count &gt; <span class="number">0</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">variance</span> = data</span><br><span class="line">                .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">                .<span class="title function_ invoke__">map</span>(|value| &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">diff</span> = data_mean - (*value <span class="keyword">as</span> <span class="type">f32</span>);</span><br><span class="line"></span><br><span class="line">                    diff * diff</span><br><span class="line">                &#125;)</span><br><span class="line">                .sum::&lt;<span class="type">f32</span>&gt;()</span><br><span class="line">                / count <span class="keyword">as</span> <span class="type">f32</span>;</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Some</span>(variance.<span class="title function_ invoke__">sqrt</span>())</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; <span class="literal">None</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_mean</span> = <span class="title function_ invoke__">mean</span>(&amp;data);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;平均数是 &#123;:?&#125;&quot;</span>, data_mean);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_std_deviation</span> = <span class="title function_ invoke__">std_deviation</span>(&amp;data);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;标准差是 &#123;:?&#125;&quot;</span>, data_std_deviation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">zscore</span> = <span class="title function_ invoke__">match</span> (data_mean, data_std_deviation) &#123;</span><br><span class="line">        (<span class="title function_ invoke__">Some</span>(mean), <span class="title function_ invoke__">Some</span>(std_deviation)) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">diff</span> = data[<span class="number">4</span>] <span class="keyword">as</span> <span class="type">f32</span> - mean;</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Some</span>(diff / std_deviation)</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;索引 4 处数据的 Z 分数（值为 &#123;&#125;）为 &#123;:?&#125;&quot;</span>, data[<span class="number">4</span>], zscore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">平均数是 Some(5.4)</span><br><span class="line">标准差是 Some(3.6110942)</span><br><span class="line">索引 4 处数据的 Z 分数（值为 5）为 Some(-0.11076978)</span><br></pre></td></tr></table></figure><h3 id="1-5-其它数学计算">1.5 其它数学计算</h3><h4 id="1-5-1-大数">1.5.1 大数</h4><p>  <code>BigInt</code> 使得超过 128 位的大整数计算成为可能。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> num::bigint::&#123;BigInt, ToBigInt&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">factorial</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> BigInt &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">mut</span> factorial) = <span class="number">1</span>.<span class="title function_ invoke__">to_bigint</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..(x + <span class="number">1</span>) &#123;</span><br><span class="line">            factorial = factorial * i;</span><br><span class="line">        &#125;</span><br><span class="line">        factorial</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;计算阶乘失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;! 等于 &#123;&#125;&quot;</span>, <span class="number">100</span>, <span class="title function_ invoke__">factorial</span>(<span class="number">100</span>)); <span class="comment">// 约为 9.332622e+157</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">100! 等于 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】十六 操作系统</title>
      <link href="/news/1682928047228.html"/>
      <url>/news/1682928047228.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-外部命令">1. 外部命令</h2><p>  需要安装<code>regex</code>库和<code>error-chain</code>库，可通过<code>cargo add regex</code>和<code>cargo add error-chain</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">regex</span> = <span class="string">&quot;1.8.1&quot;</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-1-运行外部命令并处理-stdout">1.1 运行外部命令并处理 <code>stdout</code></h3><p>  将 <code>git log --oneline</code> 作为外部命令 <code>Command</code> 运行，并使用 <code>Regex</code> 检查其 <code>Output</code>，以获取最后 5 次提交的哈希值和消息。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> regex::Regex;</span><br><span class="line"><span class="keyword">use</span> std::process::Command;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">Regex</span>(regex::Error);</span><br><span class="line">        <span class="title function_ invoke__">Utf8</span>(std::string::FromUtf8Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(PartialEq, Default, Clone, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Commit</span> &#123;</span><br><span class="line">    hash: <span class="type">String</span>,</span><br><span class="line">    message: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span> = Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;git&quot;</span>).<span class="title function_ invoke__">arg</span>(<span class="string">&quot;log&quot;</span>).<span class="title function_ invoke__">arg</span>(<span class="string">&quot;--oneline&quot;</span>).<span class="title function_ invoke__">output</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !output.status.<span class="title function_ invoke__">success</span>() &#123;</span><br><span class="line">        error_chain::bail!(<span class="string">&quot;Command executed with failing error code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pattern</span> = Regex::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        <span class="string">r&quot;(?x)</span></span><br><span class="line"><span class="string">                               ([0-9a-fA-F]+) # 提交的哈希值</span></span><br><span class="line"><span class="string">                               (.*)           # 提交信息&quot;</span>,</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(output.stdout)?</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|line| pattern.<span class="title function_ invoke__">captures</span>(line))</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|cap| Commit &#123;</span><br><span class="line">            hash: cap[<span class="number">1</span>].<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            message: cap[<span class="number">2</span>].<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">take</span>(<span class="number">5</span>)</span><br><span class="line">        .<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x));</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Commit &#123; <span class="built_in">hash</span>: <span class="string">&quot;f307002&quot;</span>, message: <span class="string">&quot;test11&quot;</span> &#125;</span><br><span class="line">Commit &#123; <span class="built_in">hash</span>: <span class="string">&quot;60d4e16&quot;</span>, message: <span class="string">&quot;test12&quot;</span> &#125;</span><br><span class="line">Commit &#123; <span class="built_in">hash</span>: <span class="string">&quot;7335ab9&quot;</span>, message: <span class="string">&quot;test13&quot;</span> &#125;</span><br><span class="line">Commit &#123; <span class="built_in">hash</span>: <span class="string">&quot;e545eef&quot;</span>, message: <span class="string">&quot;test14&quot;</span> &#125;</span><br><span class="line">Commit &#123; <span class="built_in">hash</span>: <span class="string">&quot;9ed33ac&quot;</span>, message: <span class="string">&quot;test15&quot;</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-运行传递-stdin-的外部命令，并检查错误代码">1.2 运行传递 <code>stdin</code> 的外部命令，并检查错误代码</h3><p>  使用外部命令 <code>Command</code> 打开 <code>python</code>(注：Linux下可能是<code>python3</code>) 解释器，并传递一条 <code>python</code> 语句供其执行，然后解析语句的输出结构体 <code>Output</code></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"><span class="keyword">use</span> std::process::&#123;Command, Stdio&#125;;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    errors &#123; CmdError &#125;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">Utf8</span>(std::string::FromUtf8Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">child</span> = Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;python3&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">stdin</span>(Stdio::<span class="title function_ invoke__">piped</span>())</span><br><span class="line">        .<span class="title function_ invoke__">stderr</span>(Stdio::<span class="title function_ invoke__">piped</span>())</span><br><span class="line">        .<span class="title function_ invoke__">stdout</span>(Stdio::<span class="title function_ invoke__">piped</span>())</span><br><span class="line">        .<span class="title function_ invoke__">spawn</span>()?;</span><br><span class="line"></span><br><span class="line">    child</span><br><span class="line">        .stdin</span><br><span class="line">        .<span class="title function_ invoke__">as_mut</span>()</span><br><span class="line">        .<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;Child process stdin has not been captured!&quot;</span>)?</span><br><span class="line">        .<span class="title function_ invoke__">write_all</span>(<span class="string">b&quot;import this; copyright(); credits(); exit()&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span> = child.<span class="title function_ invoke__">wait_with_output</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> output.status.<span class="title function_ invoke__">success</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">raw_output</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(output.stdout)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">words</span> = raw_output</span><br><span class="line">            .<span class="title function_ invoke__">split_whitespace</span>()</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|s| s.<span class="title function_ invoke__">to_lowercase</span>())</span><br><span class="line">            .collect::&lt;HashSet&lt;_&gt;&gt;();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;找到 &#123;&#125; 个独特的词:&quot;</span>, words.<span class="title function_ invoke__">len</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, words);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">err</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(output.stderr)?;</span><br><span class="line">        error_chain::bail!(<span class="string">&quot;外部命令失败:\n &#123;&#125;&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">找到 127 个独特的词:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;now.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;1995-2001&quot;</span>,</span><br><span class="line">    <span class="string">&quot;purity.&quot;</span>,</span><br><span class="line">    ... <span class="comment"># 此处省略</span></span><br><span class="line">    <span class="string">&quot;complex.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;may&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-运行管道传输的外部命令">1.3 运行管道传输的外部命令</h3><p>  显示当前工作目录中前 10 大的文件和子目录，它等同于运行： <code>du -ah . | sort -hr | head -n 10</code>。每个命令 <code>Command</code> 代表一个进程，子进程的输出是通过父进程和子进程之间的管道 <code>Stdio::piped</code> 捕获的。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::process::&#123;Command, Stdio&#125;;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">Utf8</span>(std::string::FromUtf8Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">directory</span> = std::env::<span class="title function_ invoke__">current_dir</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">du_output_child</span> = Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;du&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">arg</span>(<span class="string">&quot;-ah&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">arg</span>(&amp;directory)</span><br><span class="line">        .<span class="title function_ invoke__">stdout</span>(Stdio::<span class="title function_ invoke__">piped</span>())</span><br><span class="line">        .<span class="title function_ invoke__">spawn</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(du_output) = du_output_child.stdout.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sort_output_child</span> = Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;sort&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">arg</span>(<span class="string">&quot;-hr&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">stdin</span>(du_output)</span><br><span class="line">            .<span class="title function_ invoke__">stdout</span>(Stdio::<span class="title function_ invoke__">piped</span>())</span><br><span class="line">            .<span class="title function_ invoke__">spawn</span>()?;</span><br><span class="line"></span><br><span class="line">        du_output_child.<span class="title function_ invoke__">wait</span>()?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(sort_output) = sort_output_child.stdout.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">head_output_child</span> = Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;head&quot;</span>)</span><br><span class="line">                .<span class="title function_ invoke__">args</span>(&amp;[<span class="string">&quot;-n&quot;</span>, <span class="string">&quot;10&quot;</span>])</span><br><span class="line">                .<span class="title function_ invoke__">stdin</span>(sort_output)</span><br><span class="line">                .<span class="title function_ invoke__">stdout</span>(Stdio::<span class="title function_ invoke__">piped</span>())</span><br><span class="line">                .<span class="title function_ invoke__">spawn</span>()?;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">head_stdout</span> = head_output_child.<span class="title function_ invoke__">wait_with_output</span>()?;</span><br><span class="line"></span><br><span class="line">            sort_output_child.<span class="title function_ invoke__">wait</span>()?;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;“&#123;&#125;”中的前 10 个最大文件和目录:\n&#123;&#125;&quot;</span>,</span><br><span class="line">                directory.<span class="title function_ invoke__">display</span>(),</span><br><span class="line">                <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(head_stdout.stdout).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">“/root/rustcookbook/ostest”中的前 10 个最大文件和目录:</span><br><span class="line">160M    /root/rustcookbook/ostest/target/debug</span><br><span class="line">160M    /root/rustcookbook/ostest/target</span><br><span class="line">160M    /root/rustcookbook/ostest</span><br><span class="line">124M    /root/rustcookbook/ostest/target/debug/deps</span><br><span class="line">18M     /root/rustcookbook/ostest/target/debug/build</span><br><span class="line">17M     /root/rustcookbook/ostest/target/debug/deps/libregex_syntax-6ee924d67e38f866.rlib</span><br><span class="line">13M     /root/rustcookbook/ostest/target/debug/ostest</span><br><span class="line">11M     /root/rustcookbook/ostest/target/debug/deps/libregex-62f85974b4cf0dcb.rlib</span><br><span class="line">11M     /root/rustcookbook/ostest/target/debug/deps/libaho_corasick-6fc38c3e1c0e1b2d.rlib</span><br><span class="line">9.7M    /root/rustcookbook/ostest/target/debug/deps/libbacktrace-75169ab568ebd602.rlib</span><br></pre></td></tr></table></figure><h3 id="1-4-将子进程的-stdout-和-stderr-重定向到同一个文件">1.4 将子进程的 <code>stdout</code> 和 <code>stderr</code> 重定向到同一个文件</h3><p>  生成子进程并将 <code>stdout</code> 和 <code>stderr</code> 重定向到同一个文件。它遵循与运行管道传输的外部命令相同的思想，但是 <code>process::Stdio</code> 会将输出写入指定的文件。对 <code>stdout</code> 和 <code>stderr</code> 而言，<code>File::try_clone</code> 引用相同的文件句柄。它将确保两个句柄使用相同的光标位置进行写入。下面的实例等同于运行 Unix shell 命令 <code>ls . oops &gt;out.txt 2&gt;&amp;1</code>（命令用于将标准输出和标准错误都重定向到名为 <code>out.txt</code> 的文件中）。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"><span class="keyword">use</span> std::process::&#123;Command, Stdio&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">outputs</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;out.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">errors</span> = outputs.<span class="title function_ invoke__">try_clone</span>()?;</span><br><span class="line"></span><br><span class="line">    Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">args</span>(&amp;[<span class="string">&quot;.&quot;</span>, <span class="string">&quot;oops&quot;</span>])</span><br><span class="line">        .<span class="title function_ invoke__">stdout</span>(Stdio::<span class="title function_ invoke__">from</span>(outputs))</span><br><span class="line">        .<span class="title function_ invoke__">stderr</span>(Stdio::<span class="title function_ invoke__">from</span>(errors))</span><br><span class="line">        .<span class="title function_ invoke__">spawn</span>()?</span><br><span class="line">        .<span class="title function_ invoke__">wait_with_output</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>将创建<code>out.txt</code>,文件内容如下：</li></ul><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ls: cannot access &#x27;oops&#x27;: No such file or directory</span><br><span class="line">.:</span><br><span class="line">Cargo.lock</span><br><span class="line">Cargo.toml</span><br><span class="line">learn.md</span><br><span class="line">out.txt</span><br><span class="line">src</span><br><span class="line">target</span><br></pre></td></tr></table></figure><h3 id="1-5-持续处理子进程的输出">1.5 持续处理子进程的输出</h3><p>  在运行外部命令并处理 <code>stdout</code> 实例中，直到外部命令 <code>Command</code> 完成，<code>stdout</code> 的处理才开始。下面的实例调用 <code>Stdio::piped</code> 创建管道，并在 <code>BufReader</code> 被更新后立即读取 <code>stdout</code>，持续不断地处理。下面的实例等同于 Unix shell 命令 <code>journalctl | grep usb</code>.</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;BufRead, BufReader, Error, ErrorKind&#125;;</span><br><span class="line"><span class="keyword">use</span> std::process::&#123;Command, Stdio&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stdout</span> = Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;journalctl&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">stdout</span>(Stdio::<span class="title function_ invoke__">piped</span>())</span><br><span class="line">        .<span class="title function_ invoke__">spawn</span>()?</span><br><span class="line">        .stdout</span><br><span class="line">        .<span class="title function_ invoke__">ok_or_else</span>(|| Error::<span class="title function_ invoke__">new</span>(ErrorKind::Other, <span class="string">&quot;无法捕获标准输出。&quot;</span>))?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reader</span> = BufReader::<span class="title function_ invoke__">new</span>(stdout);</span><br><span class="line"></span><br><span class="line">    reader</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|line| line.<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">find</span>(<span class="string">&quot;usb&quot;</span>).<span class="title function_ invoke__">is_some</span>())</span><br><span class="line">        .<span class="title function_ invoke__">for_each</span>(|line| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line));</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>将输出：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Feb 25 10:51:07 dynasty sshd[917191]: Invalid user ...</span><br><span class="line">Feb 25 10:51:09 dynasty sshd[917191]: Failed password ...</span><br><span class="line">Feb 25 10:51:11 dynasty sshd[917191]: Disconnected ...</span><br><span class="line">Feb 25 10:55:44 dynasty sshd[917239]: Invalid user ...</span><br><span class="line">Feb 25 10:55:45 dynasty sshd[917239]: Failed password ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="1-6-读取环境变量">1.6 读取环境变量</h3><p>  通过 <code>std::env::var</code> 读取环境变量。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="comment">// 从环境变量 `CONFIG` 读取配置路径 `config_path`。</span></span><br><span class="line">    <span class="comment">// 如果 `CONFIG` 未设置，采用默认配置路径。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config_path</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CONFIG&quot;</span>).<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;/etc/myapp/config&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span>: <span class="type">String</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config_path)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Config: &#123;&#125;&quot;</span>, config);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol><li>首先设置一个环境变量：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CONFIG=out.txt <span class="comment"># 将要读取的文件</span></span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>运行<code>cargo run</code>将输出：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Config: <span class="built_in">ls</span>: cannot access <span class="string">&#x27;oops&#x27;</span>: No such file or directory</span><br><span class="line">.:</span><br><span class="line">Cargo.lock</span><br><span class="line">Cargo.toml</span><br><span class="line">learn.md</span><br><span class="line">out.txt</span><br><span class="line">src</span><br><span class="line">target</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】十五 网络</title>
      <link href="/news/1682605314170.html"/>
      <url>/news/1682605314170.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-服务器">1. 服务器</h2><h3 id="1-1-监听未使用的-TCP-IP-端口">1.1 监听未使用的 <code>TCP/IP</code> 端口</h3><p>  实例中，程序将监听显示在控制台上的端口，直到一个请求被发出。当将端口设置为 0 时，<code>SocketAddrV4</code> 会分配一个随机端口。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;Error, Read&#125;;</span><br><span class="line"><span class="keyword">use</span> std::net::&#123;Ipv4Addr, SocketAddrV4, TcpListener&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">loopback</span> = Ipv4Addr::<span class="title function_ invoke__">new</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">socket</span> = SocketAddrV4::<span class="title function_ invoke__">new</span>(loopback, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(socket)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">port</span> = listener.<span class="title function_ invoke__">local_addr</span>()?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;在&#123;&#125;上监听，访问这个端口结束程序&quot;</span>, port);</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> tcp_stream, addr) = listener.<span class="title function_ invoke__">accept</span>()?; <span class="comment">// 阻塞，直到被请求</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;收到连接！ &#123;:?&#125; 正在发送数据。&quot;</span>, addr);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = tcp_stream.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> input)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; 说 &#123;&#125;&quot;</span>, addr, input);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  交互步骤如下：</p><ul><li><ol><li>运行<code>cargo run</code>输出（设命令终端为A）</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在127.0.0.1:35963上监听，访问这个端口结束程序</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>新启命令终端，运行<code>telnet 127.0.0.1 35963</code>（设命令终端为B）,输出</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>此时服务端收到请求，终端A输出如下：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在127.0.0.1:35963上监听，访问这个端口结束程序</span><br><span class="line">收到连接！ 127.0.0.1:56962 正在发送数据。</span><br></pre></td></tr></table></figure><ul><li><ol start="4"><li>在客户端（即终端B）上输入信息“你好”后，按<code>Ctrl+]</code>键进入 <code>telnet</code> 的命令模式，然后输入 <code>quit</code> 关闭连接。这样，<code>telnet</code> 客户端会发送一个正常的关闭连接请求，服务器就能收到数据并打印出来了：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line">你好</span><br><span class="line">^]</span><br><span class="line">telnet&gt; quit</span><br><span class="line">Connection closed.</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>此时服务端的输入如下：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在127.0.0.1:35963上监听，访问这个端口结束程序</span><br><span class="line">收到连接！ 127.0.0.1:56962 正在发送数据。</span><br><span class="line">127.0.0.1:56962 说 你好</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】十四 内存管理</title>
      <link href="/news/1682605267219.html"/>
      <url>/news/1682605267219.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-常量">1. 常量</h2><p>  需要安装<code>lazy_static</code>库，可通过<code>cargo add lazy_static</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">lazy_static</span> = <span class="string">&quot;1.4.0&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-1-声明延迟计算常量">1.1 声明延迟计算常量</h3><p>  声明延迟计算的常量 <code>HashMap</code>。<code>HashMap</code> 将被计算一次，随后存储在全局静态（全局堆栈）引用。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> PRIVILEGES: HashMap&lt;&amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>, <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt;&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;James&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;user&quot;</span>, <span class="string">&quot;admin&quot;</span>]);</span><br><span class="line">        map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Jim&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;user&quot;</span>]);</span><br><span class="line">        map</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show_access</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">access</span> = PRIVILEGES.<span class="title function_ invoke__">get</span>(name);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, name, access);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">access</span> = PRIVILEGES.<span class="title function_ invoke__">get</span>(<span class="string">&quot;James&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;James: &#123;:?&#125;&quot;</span>, access);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">show_access</span>(<span class="string">&quot;Jim&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">James: Some([<span class="string">&quot;user&quot;</span>, <span class="string">&quot;admin&quot;</span>])</span><br><span class="line">Jim: Some([<span class="string">&quot;user&quot;</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】十三 硬件支持</title>
      <link href="/news/1682605206734.html"/>
      <url>/news/1682605206734.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-处理器">1. 处理器</h2><p>  需要安装<code>num_cpus</code>库，可通过<code>cargo add num_cpus</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">num_cpus</span> = <span class="string">&quot;1.15.0&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-1-检查逻辑-cpu-内核的数量">1.1 检查逻辑 cpu 内核的数量</h3><p>  使用 <code>[num_cpus::get]</code> 显示当前机器中的逻辑 <code>CPU</code> 内核的数量。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;逻辑核心数为 &#123;&#125;&quot;</span>, num_cpus::<span class="title function_ invoke__">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">逻辑核心数为 2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】十二 文件系统</title>
      <link href="/news/1682515447413.html"/>
      <url>/news/1682515447413.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-文件读写">1. 文件读写</h2><h3 id="1-1-读取文件的字符串行">1.1 读取文件的字符串行</h3><p>  向文件写入三行信息，然后使用 <code>BufRead::lines</code> 创建的迭代器 <code>Lines</code> 读取文件，一次读回一行。<code>File</code> 模块实现了提供 <code>BufReader</code> 结构体的 <code>Read</code> trait。<code>File::create</code> 打开文件 File 进行写入，<code>File::open</code> 则进行读取。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;BufRead, BufReader, Error, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = <span class="string">&quot;lines.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">output</span> = File::<span class="title function_ invoke__">create</span>(path)?;</span><br><span class="line">    <span class="built_in">write!</span>(output, <span class="string">&quot;Rust\n💖\n呵呵&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span> = File::<span class="title function_ invoke__">open</span>(path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">buffered</span> = BufReader::<span class="title function_ invoke__">new</span>(input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> buffered.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line?);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Rust</span><br><span class="line">💖</span><br><span class="line">呵呵</span><br></pre></td></tr></table></figure><h3 id="1-2-避免读取写入同一文件">1.2 避免读取写入同一文件</h3><p>  需要安装<code>same-file</code>库，可通过<code>cargo add same-file</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">same-file</span> = <span class="string">&quot;1.0.6&quot;</span></span><br></pre></td></tr></table></figure><p>  对文件使用 <code>same_file::Handle</code> 结构体，可以测试文件句柄是否等同。在本实例中，将对要读取和写入的文件句柄进行相等性测试。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> same_file::Handle;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;BufRead, BufReader, Error, ErrorKind&#125;;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path_to_read</span> = Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;new.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stdout_handle</span> = Handle::<span class="title function_ invoke__">stdout</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = Handle::<span class="title function_ invoke__">from_path</span>(path_to_read)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> stdout_handle == handle &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">new</span>(ErrorKind::Other, <span class="string">&quot;您正在读取和写入同一个文件&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(&amp;path_to_read)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">file</span> = BufReader::<span class="title function_ invoke__">new</span>(file);</span><br><span class="line">        <span class="title function_ invoke__">for</span> (num, line) <span class="keyword">in</span> file.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; : &#123;&#125;&quot;</span>, num, line?.<span class="title function_ invoke__">to_uppercase</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行<code>cargo run</code>输出显示文件 <code>new.txt</code> 的内容。</p></li><li><p>运行<code>cargo run &gt;&gt; ./new.txt</code>报错，因为是同一文件。输出</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: Custom &#123; kind: Other, error: <span class="string">&quot;您正在读取和写入同一个文件&quot;</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-使用内存映射随机访问文件">1.3 使用内存映射随机访问文件</h3><p>  需要安装<code>memmap</code>库，可通过<code>cargo add memmap</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">memmap</span> = <span class="string">&quot;0.7.0&quot;</span></span><br></pre></td></tr></table></figure><p>  使用 <code>memmap</code> 创建文件的内存映射，并模拟文件的一些非序列读取。使用内存映射意味着您仅需索引一个切片，而不是使用 <code>seek</code> 方法来导航整个文件。<code>Mmap::map</code> 函数假定内存映射后的文件没有被另一个进程同时更改，否则会出现竞态条件。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> memmap::Mmap;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Write, Error&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="built_in">write!</span>(File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;content.txt&quot;</span>)?, <span class="string">&quot;My hovercraft is full of eels!&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;content.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">map</span> = <span class="keyword">unsafe</span> &#123; Mmap::<span class="title function_ invoke__">map</span>(&amp;file)? &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">random_indexes</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">29</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;map[<span class="number">3</span>..<span class="number">13</span>], <span class="string">b&quot;hovercraft&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">random_bytes</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = random_indexes.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|&amp;idx| map[idx])</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;random_bytes[..], <span class="string">b&quot;My loaf!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h2 id="2-目录遍历">2 目录遍历</h2><h3 id="2-1-过去-24-小时内修改过的文件名">2.1 过去 24 小时内修改过的文件名</h3><p>  需要安装<code>error_chain</code>库，可通过<code>cargo add error_chain</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br></pre></td></tr></table></figure><p>  通过调用 <code>env::current_dir</code> 获取当前工作目录，然后通过 <code>fs::read_dir</code> 读取目录中的每个条目，通过 <code>DirEntry::path</code> 提取条目路径，以及通过通过 <code>fs::Metadata</code> 获取条目元数据。<code>Metadata::modified</code> 返回条目自上次更改以来的运行时间 <code>SystemTime::elapsed。Duration::as_secs</code> 将时间转换为秒，并与 24 小时（24 <em>60</em> 60 秒）进行比较。<code>Metadata::is_file</code> 用于筛选出目录。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::&#123;env, fs&#125;;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">SystemTimeError</span>(std::time::SystemTimeError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current_dir</span> = env::<span class="title function_ invoke__">current_dir</span>()?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;在过去 24 小时内修改的条目&#123;:?&#125;:&quot;</span>, current_dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">entry</span> <span class="keyword">in</span> fs::<span class="title function_ invoke__">read_dir</span>(current_dir)? &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">entry</span> = entry?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">path</span> = entry.<span class="title function_ invoke__">path</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">metadata</span> = fs::<span class="title function_ invoke__">metadata</span>(&amp;path)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">last_modified</span> = metadata.<span class="title function_ invoke__">modified</span>()?.<span class="title function_ invoke__">elapsed</span>()?.<span class="title function_ invoke__">as_secs</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> last_modified &lt; <span class="number">24</span> * <span class="number">3600</span> &amp;&amp; metadata.<span class="title function_ invoke__">is_file</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;最后修改：&#123;:?&#125; 秒，只读：&#123;:?&#125;，大小：&#123;:?&#125; 字节，文件名：&#123;:?&#125;&quot;</span>,</span><br><span class="line">                last_modified,</span><br><span class="line">                metadata.<span class="title function_ invoke__">permissions</span>().<span class="title function_ invoke__">readonly</span>(),</span><br><span class="line">                metadata.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">                path.<span class="title function_ invoke__">file_name</span>().<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;没有文件名&quot;</span>)?</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在过去 24 小时内修改的条目<span class="string">&quot;/root/rustcookbook/filetest&quot;</span>:</span><br><span class="line">最后修改：118 秒，只读：<span class="literal">false</span>，大小：237 字节，文件名：<span class="string">&quot;Cargo.toml&quot;</span></span><br><span class="line">最后修改：107 秒，只读：<span class="literal">false</span>，大小：4336 字节，文件名：<span class="string">&quot;Cargo.lock&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-查找给定路径的循环">2.2 查找给定路径的循环</h3><p>  使用 <code>same_file::is_same_file</code> 检测给定路径的循环。例如，可以通过软连接（符号链接）在 <code>Unix</code> 系统上创建循环：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /tmp/foo/bar/baz</span><br><span class="line"><span class="built_in">ln</span> -s /tmp/foo/  /tmp/foo/bar/baz/qux</span><br></pre></td></tr></table></figure><ul><li>下面的实例将断言存在一个循环。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> same_file::is_same_file;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::path::&#123;Path, PathBuf&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">contains_loop</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(path: P) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;<span class="type">Option</span>&lt;(PathBuf, PathBuf)&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = path.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">path_buf</span> = path.<span class="title function_ invoke__">to_path_buf</span>();</span><br><span class="line">    <span class="keyword">while</span> path_buf.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">is_same_file</span>(&amp;path_buf, path)? &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Some</span>((path_buf, path.<span class="title function_ invoke__">to_path_buf</span>())));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(looped_paths) = <span class="title function_ invoke__">contains_loop</span>(&amp;path_buf)? &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Some</span>(looped_paths));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="title function_ invoke__">contains_loop</span>(<span class="string">&quot;/tmp/foo/bar/baz/qux/bar/baz&quot;</span>).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>((</span><br><span class="line">            PathBuf::<span class="title function_ invoke__">from</span>(<span class="string">&quot;/tmp/foo&quot;</span>),</span><br><span class="line">            PathBuf::<span class="title function_ invoke__">from</span>(<span class="string">&quot;/tmp/foo/bar/baz/qux&quot;</span>)</span><br><span class="line">        ))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="2-3-递归查找重名文件">2.3 递归查找重名文件</h3><p>  需要安装<code>walkdir</code>库，可通过<code>cargo add walkdir</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">walkdir</span> = <span class="string">&quot;2.3.3&quot;</span></span><br></pre></td></tr></table></figure><p>  在当前目录中递归查找重复的文件名，只打印一次。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> walkdir::WalkDir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">filenames</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">entry</span> <span class="keyword">in</span> WalkDir::<span class="title function_ invoke__">new</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(<span class="type">Result</span>::ok)</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|e| !e.<span class="title function_ invoke__">file_type</span>().<span class="title function_ invoke__">is_dir</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">f_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(entry.<span class="title function_ invoke__">file_name</span>().<span class="title function_ invoke__">to_string_lossy</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = filenames.<span class="title function_ invoke__">entry</span>(f_name.<span class="title function_ invoke__">clone</span>()).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">        *counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> *counter == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出(基本上是<code>target</code>目录下的文件)</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">invoked.timestamp</span><br><span class="line">root-output</span><br><span class="line">output</span><br><span class="line">stderr</span><br><span class="line">...</span><br><span class="line">dep-lib-adler</span><br></pre></td></tr></table></figure><h3 id="2-4-使用给定断言递归查找所有文件">2.4 使用给定断言递归查找所有文件</h3><p>  在当前目录中查找最近一天内修改的 <code>JSON</code> 文件。使用 <code>follow_links</code> 确保软链接（符号链接）像普通目录和文件一样被按照当前查找规则执行。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> walkdir::WalkDir;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">WalkDir</span>(walkdir::Error);</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">SystemTime</span>(std::time::SystemTimeError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">entry</span> <span class="keyword">in</span> WalkDir::<span class="title function_ invoke__">new</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">follow_links</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|e| e.<span class="title function_ invoke__">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">f_name</span> = entry.<span class="title function_ invoke__">file_name</span>().<span class="title function_ invoke__">to_string_lossy</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">sec</span> = entry.<span class="title function_ invoke__">metadata</span>()?.<span class="title function_ invoke__">modified</span>()?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> f_name.<span class="title function_ invoke__">ends_with</span>(<span class="string">&quot;.json&quot;</span>) &amp;&amp; sec.<span class="title function_ invoke__">elapsed</span>()?.<span class="title function_ invoke__">as_secs</span>() &lt; <span class="number">86400</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出(基本上是<code>target</code>目录下的文件)</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.rustc_info.json</span><br><span class="line">lib-gimli.json</span><br><span class="line">...</span><br><span class="line">lib-adler.json</span><br><span class="line">bin-filetest.json</span><br></pre></td></tr></table></figure><h3 id="2-5-跳过隐藏文件遍历目录">2.5 跳过隐藏文件遍历目录</h3><p>  递归下行到子目录的过程中，使用 <code>filter_entry</code> 对目录中的条目传递 <code>is_not_hidden</code> 断言，从而跳过隐藏的文件和目录。<code>Iterator::filter</code> 可应用到要检索的任何目录 <code>WalkDir::DirEntry</code>，即使父目录是隐藏目录。根目录 “.” 的检索结果，通过在断言 <code>is_not_hidden</code> 中使用 <code>WalkDir::depth</code> 参数生成。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> walkdir::&#123;DirEntry, WalkDir&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_not_hidden</span>(entry: &amp;DirEntry) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    entry</span><br><span class="line">        .<span class="title function_ invoke__">file_name</span>()</span><br><span class="line">        .<span class="title function_ invoke__">to_str</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|s| entry.<span class="title function_ invoke__">depth</span>() == <span class="number">0</span> || !s.<span class="title function_ invoke__">starts_with</span>(<span class="string">&quot;.&quot;</span>))</span><br><span class="line">        .<span class="title function_ invoke__">unwrap_or</span>(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    WalkDir::<span class="title function_ invoke__">new</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_entry</span>(|e| <span class="title function_ invoke__">is_not_hidden</span>(e))</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|v| v.<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">path</span>().<span class="title function_ invoke__">display</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出(基本上是<code>target</code>目录下的文件)</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./Cargo.toml</span><br><span class="line">./src</span><br><span class="line">./src/main.rs</span><br><span class="line">./target</span><br><span class="line">./target/debug</span><br><span class="line">./target/debug/build</span><br><span class="line">...</span><br><span class="line">./Cargo.lock</span><br></pre></td></tr></table></figure><h3 id="2-6-在给定深度的目录，递归计算文件大小">2.6 在给定深度的目录，递归计算文件大小</h3><p>  通过<code>WalkDir::min_depth</code> 和 <code>WalkDir::max_depth</code> 方法，可以灵活设置目录的递归深度。下面的实例计算了 3 层子文件夹深度的所有文件的大小总和，计算中忽略根文件夹中的文件。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> walkdir::WalkDir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total_size</span> = WalkDir::<span class="title function_ invoke__">new</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">min_depth</span>(<span class="number">1</span>)</span><br><span class="line">        .<span class="title function_ invoke__">max_depth</span>(<span class="number">3</span>)</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|entry| entry.<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|entry| entry.<span class="title function_ invoke__">metadata</span>().<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|metadata| metadata.<span class="title function_ invoke__">is_file</span>())</span><br><span class="line">        .<span class="title function_ invoke__">fold</span>(<span class="number">0</span>, |acc, m| acc + m.<span class="title function_ invoke__">len</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;总大小: &#123;&#125; bytes.&quot;</span>, total_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">总大小: 5247240 bytes.</span><br></pre></td></tr></table></figure><h3 id="2-7-递归查找所有-png-文件">2.7 递归查找所有 <code>png</code> 文件</h3><p>  需要安装<code>glob&quot;</code>库，可通过<code>cargo add glob</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">glob</span> = <span class="string">&quot;0.3.1&quot;</span></span><br></pre></td></tr></table></figure><p>  递归地查找当前目录中的所有 <code>PNG</code> 文件。在本实例中，<code>**</code> 模式用于匹配当前目录及其所有子目录。在路径任意部分使用 <code>**</code> 模式，例如，<code>/media/**/*.png</code> 匹配 <code>media</code> 及其子目录中的所有 <code>PNG</code> 文件。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> glob::glob;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Glob</span>(glob::GlobError);</span><br><span class="line">        <span class="title function_ invoke__">Pattern</span>(glob::PatternError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">entry</span> <span class="keyword">in</span> <span class="title function_ invoke__">glob</span>(<span class="string">&quot;**/*.png&quot;</span>)? &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, entry?.<span class="title function_ invoke__">display</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src/test.png</span><br><span class="line">test.png</span><br></pre></td></tr></table></figure><h3 id="2-8-忽略文件名大小写，使用给定模式查找所有文件">2.8 忽略文件名大小写，使用给定模式查找所有文件</h3><p>  在当前目录中查找与正则表达模式 <code>img_[0-9]*.png</code> 匹配的所有图像文件。一个自定义 <code>MatchOptions</code> 结构体被传递给 <code>glob_with</code> 函数，使全局命令模式下不区分大小写，同时保持其他选项的默认值 <code>Default</code>，注：原教程查看<code>/media/</code>目录下的图片。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> glob::&#123;glob_with, MatchOptions&#125;;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Glob</span>(glob::GlobError);</span><br><span class="line">        <span class="title function_ invoke__">Pattern</span>(glob::PatternError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">options</span> = MatchOptions &#123;</span><br><span class="line">        case_sensitive: <span class="literal">false</span>,</span><br><span class="line">        ..<span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">entry</span> <span class="keyword">in</span> <span class="title function_ invoke__">glob_with</span>(<span class="string">&quot;./**/img_[0-9]*.png&quot;</span>, options)? &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, entry?.<span class="title function_ invoke__">display</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">img_0.png</span><br><span class="line">src/img_9.png</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】十一 错误处理</title>
      <link href="/news/1682254869915.html"/>
      <url>/news/1682254869915.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-处理错误变量">1. 处理错误变量</h2><p>  需要安装<code>error-chain</code>库，可通过<code>cargo add error-chain</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-1-在-main-方法中对错误适当处理">1.1 在 <code>main</code> 方法中对错误适当处理</h3><p>  处理尝试打开不存在的文件时发生的错误，是通过使用 <code>error-chain</code> crate 来实现的。<code>error-chain</code> crate 包含大量的模板代码，用于 Rust 中的错误处理。<code>foreign_links</code> 代码块内的 <code>Io(std::io::Error)</code> 函数允许由 <code>std::io::Error</code> 所报错误信息到 <code>error_chain!</code> 所定义错误类型的自动转换，<code>error_chain!</code> 所定义错误类型将实现 <code>Error</code> trait。下文的实例将通过打开 Unix 文件 <code>/proc/uptime</code> 并解析内容以获得其中第一个数字，从而告诉系统运行了多长时间。除非出现错误，否则返回正常运行时间。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">ParseInt</span>(::std::num::ParseIntError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_uptime</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">u64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">uptime</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;/proc/uptime&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> uptime)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(uptime</span><br><span class="line">        .<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">next</span>()</span><br><span class="line">        .<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;无法解析正常运行时间数据&quot;</span>)?</span><br><span class="line">        .<span class="title function_ invoke__">parse</span>()?)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">read_uptime</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(uptime) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;正常运行时间: &#123;&#125; 秒&quot;</span>, uptime),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; eprintln!(<span class="string">&quot;错误: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">正常运行时间: 3204645 秒</span><br></pre></td></tr></table></figure><h3 id="1-2-避免在错误转变过程中遗漏错误">1.2 避免在错误转变过程中遗漏错误</h3><p>  需要安装<code>reqwest</code>库，可通过<code>cargo add reqwest --features blocking</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br><span class="line"><span class="attr">reqwest</span> = &#123; version = <span class="string">&quot;0.11.16&quot;</span>, features = [<span class="string">&quot;blocking&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><p>  <code>error-chain</code> crate 使得匹配函数返回的不同错误类型成为可能，并且相对简洁。<code>ErrorKind</code> 是枚举类型，可以确定错误类型。下文实例使用 <code>reqwest::blocking</code> 来查询一个随机整数生成器的 web 服务，并将服务器响应的字符串转换为整数。Rust 标准库 <code>reqwest</code> 和 web 服务都可能会产生错误，所以使用 <code>foreign_links</code> 定义易于辨认理解的 Rust 错误。另外，用于 web 服务错误信息的 <code>ErrorKind</code> 变量，使用 <code>error_chain!</code> 宏的 <code>errors</code> 代码块定义。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">Reqwest</span>(reqwest::Error);</span><br><span class="line">        <span class="title function_ invoke__">ParseIntError</span>(std::num::ParseIntError);</span><br><span class="line">    &#125;</span><br><span class="line">    errors &#123; <span class="title function_ invoke__">RandomResponseError</span>(t: <span class="type">String</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_response</span>(response: reqwest::blocking::Response) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">body</span> = response.<span class="title function_ invoke__">text</span>()?;</span><br><span class="line">    body.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">    body.parse::&lt;<span class="type">u32</span>&gt;()</span><br><span class="line">        .<span class="title function_ invoke__">chain_err</span>(|| ErrorKind::<span class="title function_ invoke__">RandomResponseError</span>(body))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> =</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;https://www.random.org/integers/?num=1&amp;min=0&amp;max=10&amp;col=1&amp;base=10&amp;format=plain&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(&amp;url)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">random_value</span>: <span class="type">u32</span> = <span class="title function_ invoke__">parse_response</span>(response)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0 到 10 之间的随机数: &#123;&#125;&quot;</span>, random_value);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(error) = <span class="title function_ invoke__">run</span>() &#123;</span><br><span class="line">        <span class="keyword">match</span> *error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::<span class="title function_ invoke__">Io</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;标准 IO 错误: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">            ErrorKind::<span class="title function_ invoke__">Reqwest</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;reqwest 请求错误: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">            ErrorKind::<span class="title function_ invoke__">ParseIntError</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;标准解析 int 错误: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">            ErrorKind::<span class="title function_ invoke__">RandomResponseError</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;用户定义错误: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">            _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;其他错误: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 到 10 之间的随机数: 6</span><br></pre></td></tr></table></figure><h3 id="1-3-获取复杂错误场景的回溯">1.3 获取复杂错误场景的回溯</h3><p>  需要安装<code>csv</code>和<code>serde</code>库，可通过<code>cargo add csv</code>和<code>cargo add serde --features derive</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br><span class="line"><span class="attr">csv</span> = <span class="string">&quot;1.2.1&quot;</span></span><br><span class="line"><span class="attr">serde</span> = &#123; version = <span class="string">&quot;1.0.160&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><p>  本实例展示了如何处理一个复杂的错误场景，并且打印出错误回溯。依赖于 <code>chain_err</code>，通过附加新的错误来扩展错误信息。从而可以展开错误堆栈，这样提供了更好的上下文来理解错误的产生原因。下述代码尝试将值 <code>256</code> 反序列化为 <code>u8</code>。首先 <code>Serde</code> 产生错误，然后是 <code>csv</code>，最后是用户代码。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> serde::Deserialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Reader</span>(csv::Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rgb</span> &#123;</span><br><span class="line">    red: <span class="type">u8</span>,</span><br><span class="line">    blue: <span class="type">u8</span>,</span><br><span class="line">    green: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rgb</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from_reader</span>(csv_data: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Rgb&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">color</span>: Rgb = csv::Reader::<span class="title function_ invoke__">from_reader</span>(csv_data)</span><br><span class="line">            .<span class="title function_ invoke__">deserialize</span>()</span><br><span class="line">            .<span class="title function_ invoke__">nth</span>(<span class="number">0</span>)</span><br><span class="line">            .<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;无法反序列化第一个 CSV 记录&quot;</span>)?</span><br><span class="line">            .<span class="title function_ invoke__">chain_err</span>(|| <span class="string">&quot;无法反序列化 RGB 颜色&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(color)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::UpperHex <span class="keyword">for</span> <span class="title class_">Rgb</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">hexa</span> = <span class="type">u32</span>::<span class="title function_ invoke__">from</span>(<span class="keyword">self</span>.red) &lt;&lt; <span class="number">16</span> | <span class="type">u32</span>::<span class="title function_ invoke__">from</span>(<span class="keyword">self</span>.blue) &lt;&lt; <span class="number">8</span> | <span class="type">u32</span>::<span class="title function_ invoke__">from</span>(<span class="keyword">self</span>.green);</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;:X&#125;&quot;</span>, hexa)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">csv</span> = <span class="string">&quot;red,blue,green</span></span><br><span class="line"><span class="string">102,256,204&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rgb</span> = Rgb::<span class="title function_ invoke__">from_reader</span>(csv.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">chain_err</span>(|| <span class="string">&quot;无法读取 CSV 数据&quot;</span>)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; 十六进制 #&#123;:X&#125;&quot;</span>, rgb, rgb);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(<span class="keyword">ref</span> errors) = <span class="title function_ invoke__">run</span>() &#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;错误级别 - 描述&quot;</span>);</span><br><span class="line">        errors</span><br><span class="line">            .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">            .<span class="title function_ invoke__">enumerate</span>()</span><br><span class="line">            .<span class="title function_ invoke__">for_each</span>(|(index, error)| eprintln!(<span class="string">&quot;└&gt; &#123;&#125; - &#123;&#125;&quot;</span>, index, error));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(backtrace) = errors.<span class="title function_ invoke__">backtrace</span>() &#123;</span><br><span class="line">            eprintln!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, backtrace);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在实际用例中，应该处理错误。 例如：</span></span><br><span class="line">        std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">错误级别 - 描述</span><br><span class="line">└&gt; 0 - 无法读取 CSV 数据</span><br><span class="line">└&gt; 1 - 无法反序列化 RGB 颜色</span><br><span class="line">└&gt; 2 - CSV deserialize error: record 1 (line: 2, byte: 15): field 1: number too large to fit <span class="keyword">in</span> target <span class="built_in">type</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】十 编码</title>
      <link href="/news/1682091000481.html"/>
      <url>/news/1682091000481.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-字符集">1. 字符集</h2><h3 id="1-1-百分比编码（URL-编码）字符串">1.1 百分比编码（<code>URL</code> 编码）字符串</h3><p>  需要安装<code>percent-encoding</code>库，可通过<code>cargo add percent-encoding</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">percent-encoding</span> = <span class="string">&quot;2.2.0&quot;</span></span><br></pre></td></tr></table></figure><p>  使用 <code>percent-encoding</code> crate 中的 <code>utf8_percent_encode</code> 函数对输入字符串进行百分比编码（<code>URL</code> 编码）。解码使用 <code>percent_decode</code> 函数。编码集定义哪些字节（除了非 <code>ASCII</code> 字节和控制键之外）需要进行百分比编码（<code>URL</code> 编码），这个集合的选择取决于上下文。例如，<code>url</code>对 <code>URL</code> 路径中的 <code>?</code> 编码，而不对查询字符串中的 <code>?</code> 编码。编码的返回值是 <code>&amp;str</code> 切片的迭代器，然后聚集为一个字符串 <code>String</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> percent_encoding::&#123;percent_decode, utf8_percent_encode, AsciiSet, CONTROLS&#125;;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::Utf8Error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// https://url.spec.whatwg.org/#fragment-percent-encode-set</span></span><br><span class="line"><span class="keyword">const</span> FRAGMENT: &amp;AsciiSet = &amp;CONTROLS</span><br><span class="line">    .<span class="title function_ invoke__">add</span>(<span class="string">b&#x27; &#x27;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">add</span>(<span class="string">b&#x27;&quot;&#x27;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">add</span>(<span class="string">b&#x27;&lt;&#x27;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">add</span>(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">add</span>(<span class="string">b&#x27;`&#x27;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">add</span>(<span class="string">b&#x27;,&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Utf8Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span> = <span class="string">&quot;confident, productive systems programming&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">iter</span> = <span class="title function_ invoke__">utf8_percent_encode</span>(input, FRAGMENT);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">encoded</span>: <span class="type">String</span> = iter.<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(encoded, <span class="string">&quot;confident%2C%20productive%20systems%20programming&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">iter</span> = <span class="title function_ invoke__">percent_decode</span>(encoded.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">decoded</span> = iter.<span class="title function_ invoke__">decode_utf8</span>()?;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(decoded, <span class="string">&quot;confident, productive systems programming&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="1-2-将字符串编码为-application-x-www-form-urlencoded">1.2 将字符串编码为 <code>application/x-www-form-urlencoded</code></h3><p>  需要安装<code>url</code>库，可通过<code>cargo add url</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">url</span> = <span class="string">&quot;2.3.1&quot;</span></span><br></pre></td></tr></table></figure><p>  如下实例使用 <code>form_urlencoded::byte_serialize</code> 将字符串编码为 <code>application/x-www-form-urlencoded</code> 表单语法，随后使用 <code>form_urlencoded::parse</code> 对其进行解码。这两个函数都返回迭代器，然后这些迭代器聚集为 <code>String</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> url::form_urlencoded::&#123;byte_serialize, parse&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">urlencoded</span>: <span class="type">String</span> = <span class="title function_ invoke__">byte_serialize</span>(<span class="string">&quot;What is ❤?&quot;</span>.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(urlencoded, <span class="string">&quot;What+is+%E2%9D%A4%3F&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;urlencoded:&#x27;&#123;&#125;&#x27;&quot;</span>, urlencoded);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">decoded</span>: <span class="type">String</span> = <span class="title function_ invoke__">parse</span>(urlencoded.<span class="title function_ invoke__">as_bytes</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(key, val)| [key, val].<span class="title function_ invoke__">concat</span>())</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(decoded, <span class="string">&quot;What is ❤?&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;decoded:&#x27;&#123;&#125;&#x27;&quot;</span>, decoded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">urlencoded:<span class="string">&#x27;What+is+%E2%9D%A4%3F&#x27;</span></span><br><span class="line">decoded:<span class="string">&#x27;What is ❤?&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-编码和解码十六进制">1.3 编码和解码十六进制</h3><p>  需要安装<code>data_encoding</code>库，可通过<code>cargo add data_encoding</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">data-encoding</span> = <span class="string">&quot;2.3.3&quot;</span></span><br></pre></td></tr></table></figure><p>  <code>data_encoding</code> crate 提供了 <code>HEXUPPER::encode</code> 方法，该方法接受 <code>&amp;[u8]</code> 参数并返回十六进制数据的字符串 <code>String</code>。类似地，<code>data_encoding</code>crate 提供了 <code>HEXUPPER::decode</code> 方法，该方法接受 <code>&amp;[u8]</code> 参数。如果输入数据被成功解码，则返回 <code>Vec&lt;u8&gt;</code>。下面的实例将 <code>&amp;[u8]</code> 数据转换为等效的十六进制数据，然后将此值与预期值进行比较。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> data_encoding::&#123;HEXUPPER, DecodeError&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), DecodeError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">original</span> = <span class="string">b&quot;The quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expected</span> = <span class="string">&quot;54686520717569636B2062726F776E20666F78206A756D7073206F76\</span></span><br><span class="line"><span class="string">        657220746865206C617A7920646F672E&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">encoded</span> = HEXUPPER.<span class="title function_ invoke__">encode</span>(original);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(encoded, expected);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">decoded</span> = HEXUPPER.<span class="title function_ invoke__">decode</span>(&amp;encoded.<span class="title function_ invoke__">into_bytes</span>())?;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;decoded[..], &amp;original[..]);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="1-4-编码和解码-base64">1.4 编码和解码 <code>base64</code></h3><p>  需要安装<code>base64</code>、<code>error-chain</code>库，可通过<code>cargo add base64</code>、<code>cargo add error-chain</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">base64</span> = <span class="string">&quot;0.21.0&quot;</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br></pre></td></tr></table></figure><p>  使用 <code>encode</code> 将字节切片编码为 <code>base64</code> 字符串，对 <code>base64</code> 字符串解码使用 <code>decode</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> base64::&#123;engine::general_purpose, Engine <span class="keyword">as</span> _&#125;;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Base64</span>(base64::DecodeError);</span><br><span class="line">        <span class="title function_ invoke__">Utf8Error</span>(<span class="type">str</span>::Utf8Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">b&quot;hello rustaceans&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">encoded</span> = general_purpose::STANDARD_NO_PAD.<span class="title function_ invoke__">encode</span>(hello);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">decoded</span> = general_purpose::STANDARD_NO_PAD.<span class="title function_ invoke__">decode</span>(&amp;encoded)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;原始: &#123;&#125;&quot;</span>, <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(hello)?);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;base64 编码后: &#123;&#125;&quot;</span>, encoded);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;解码到原始: &#123;&#125;&quot;</span>, <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;decoded)?);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">原始: hello rustaceans</span><br><span class="line"><span class="built_in">base64</span> 编码后: aGVsbG8gcnVzdGFjZWFucw</span><br><span class="line">解码到原始: hello rustaceans</span><br></pre></td></tr></table></figure><h2 id="2-CSV-处理">2. <code>CSV</code> 处理</h2><p>  需要安装<code>csv</code>、<code>serde</code>库，可通过<code>cargo add csv</code>、<code>cargo add serde --features derive</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">csv</span> = <span class="string">&quot;1.2.1&quot;</span></span><br><span class="line"><span class="attr">serde</span> = &#123; version = <span class="string">&quot;1.0.160&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-读取-CSV-记录">2.1 读取 <code>CSV</code> 记录</h3><p>  将标准的 <code>CSV</code> 记录读入 <code>csv::StringRecord</code>——一种弱类型的数据表示方式，它需要 <code>CSV</code> 中的行数据是有效的 <code>UTF-8</code> 字符编码。另外，<code>csv::ByteRecord</code> 对 UTF-8 不做任何预设。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> csv::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">csv</span> = <span class="string">&quot;year,make,model,description</span></span><br><span class="line"><span class="string">1948,Porsche,356,Luxury sports car</span></span><br><span class="line"><span class="string">1967,Ford,Mustang fastback 1967,American car&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reader</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(csv.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">record</span> <span class="keyword">in</span> reader.<span class="title function_ invoke__">records</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">record</span> = record?;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;在 &#123;&#125;, &#123;&#125; 建立了&#123;&#125;模型, 是 &#123;&#125;.&quot;</span>,</span><br><span class="line">            &amp;record[<span class="number">0</span>], &amp;record[<span class="number">1</span>], &amp;record[<span class="number">2</span>], &amp;record[<span class="number">3</span>]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在 1948, Porsche 建立了356模型, 是 Luxury sports car.</span><br><span class="line">在 1967, Ford 建立了Mustang fastback 1967模型, 是 American car.</span><br></pre></td></tr></table></figure><p>  <code>Serde</code> 将数据反序列化为强类型结构体。具体查阅 <code>csv::Reader::deserialize</code> 方法</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::Deserialize;</span><br><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    year: <span class="type">u16</span>,</span><br><span class="line">    make: <span class="type">String</span>,</span><br><span class="line">    model: <span class="type">String</span>,</span><br><span class="line">    description: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), csv::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">csv</span> = <span class="string">&quot;year,make,model,description</span></span><br><span class="line"><span class="string">1948,Porsche,356,Luxury sports car</span></span><br><span class="line"><span class="string">1967,Ford,Mustang fastback 1967,American car&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reader</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(csv.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">record</span> <span class="keyword">in</span> reader.<span class="title function_ invoke__">deserialize</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">record</span>: Record = record?;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;在 &#123;&#125;, &#123;&#125; 建立了&#123;&#125;模型, 是 &#123;&#125;.&quot;</span>,</span><br><span class="line">            record.year, record.make, record.model, record.description</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在 1948, Porsche 建立了356模型, 是 Luxury sports car.</span><br><span class="line">在 1967, Ford 建立了Mustang fastback 1967模型, 是 American car.</span><br></pre></td></tr></table></figure><h3 id="2-2-读取有不同分隔符的-CSV-记录">2.2 读取有不同分隔符的 <code>CSV</code> 记录</h3><p>  使用制表（tab）分隔符 <code>delimiter</code> 读取 <code>CSV</code> 记录。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> csv::Error;</span><br><span class="line"><span class="keyword">use</span> serde::Deserialize;</span><br><span class="line"><span class="meta">#[derive(Debug, Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    place: <span class="type">String</span>,</span><br><span class="line">    <span class="meta">#[serde(deserialize_with = <span class="string">&quot;csv::invalid_option&quot;</span>)]</span></span><br><span class="line">    id: <span class="type">Option</span>&lt;<span class="type">u64</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> csv::ReaderBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;name\tplace\tid</span></span><br><span class="line"><span class="string">Mark\tMelbourne\t46</span></span><br><span class="line"><span class="string">Ashley\tZurich\t92&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reader</span> = ReaderBuilder::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">delimiter</span>(<span class="string">b&#x27;\t&#x27;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">from_reader</span>(data.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">result</span> <span class="keyword">in</span> reader.deserialize::&lt;Record&gt;() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, result?);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Record &#123; name: <span class="string">&quot;Mark&quot;</span>, place: <span class="string">&quot;Melbourne&quot;</span>, <span class="built_in">id</span>: Some(46) &#125;</span><br><span class="line">Record &#123; name: <span class="string">&quot;Ashley&quot;</span>, place: <span class="string">&quot;Zurich&quot;</span>, <span class="built_in">id</span>: Some(92) &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-筛选匹配断言的-CSV-记录">2.3 筛选匹配断言的 CSV 记录</h3><p>  仅仅 返回 <code>data</code> 中字段（<code>field</code>）与 <code>query</code> 匹配的的行。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">CsvError</span>(csv::Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;CA&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">City,State,Population,Latitude,Longitude</span></span><br><span class="line"><span class="string">Kenai,AK,7610,60.5544444,-151.2583333</span></span><br><span class="line"><span class="string">Oakman,AL,,33.7133333,-87.3886111</span></span><br><span class="line"><span class="string">Sandfort,AL,,32.3380556,-85.2233333</span></span><br><span class="line"><span class="string">West Hollywood,CA,37031,34.0900000,-118.3608333&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::ReaderBuilder::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">from_reader</span>(data.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">wtr</span> = csv::Writer::<span class="title function_ invoke__">from_writer</span>(io::<span class="title function_ invoke__">stdout</span>());</span><br><span class="line"></span><br><span class="line">    wtr.<span class="title function_ invoke__">write_record</span>(rdr.<span class="title function_ invoke__">headers</span>()?)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">result</span> <span class="keyword">in</span> rdr.<span class="title function_ invoke__">records</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">record</span> = result?;</span><br><span class="line">        <span class="keyword">if</span> record.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|field| field == query) &#123;</span><br><span class="line">            wtr.<span class="title function_ invoke__">write_record</span>(&amp;record)?;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wtr.<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">City,State,Population,Latitude,Longitude</span><br><span class="line">West Hollywood,CA,37031,34.0900000,-118.3608333</span><br></pre></td></tr></table></figure><h3 id="2-4-用-Serde-处理无效的-CSV-数据">2.4 用 <code>Serde</code> 处理无效的 <code>CSV</code> 数据</h3><p>  <code>CSV</code> 文件通常包含无效数据。对于这些情形，<code>csv</code> crate 提供了一个自定义的反序列化程序 <code>csv::invalid_option</code>，它自动将无效数据转换为 <code>None</code> 值。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> csv::Error;</span><br><span class="line"><span class="keyword">use</span> serde::Deserialize;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    place: <span class="type">String</span>,</span><br><span class="line">    <span class="meta">#[serde(deserialize_with = <span class="string">&quot;csv::invalid_option&quot;</span>)]</span></span><br><span class="line">    id: <span class="type">Option</span>&lt;<span class="type">u64</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;name,place,id</span></span><br><span class="line"><span class="string">mark,sydney,46.5 </span></span><br><span class="line"><span class="string">ashley,zurich,92</span></span><br><span class="line"><span class="string">akshat,delhi,37</span></span><br><span class="line"><span class="string">alisha,colombo,xyz&quot;</span>; <span class="comment">//46.5,xyz-&gt;None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(data.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">result</span> <span class="keyword">in</span> rdr.<span class="title function_ invoke__">deserialize</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">record</span>: Record = result?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Record &#123; name: <span class="string">&quot;mark&quot;</span>, place: <span class="string">&quot;sydney&quot;</span>, <span class="built_in">id</span>: None &#125;</span><br><span class="line">Record &#123; name: <span class="string">&quot;ashley&quot;</span>, place: <span class="string">&quot;zurich&quot;</span>, <span class="built_in">id</span>: Some(92) &#125;</span><br><span class="line">Record &#123; name: <span class="string">&quot;akshat&quot;</span>, place: <span class="string">&quot;delhi&quot;</span>, <span class="built_in">id</span>: Some(37) &#125;</span><br><span class="line">Record &#123; name: <span class="string">&quot;alisha&quot;</span>, place: <span class="string">&quot;colombo&quot;</span>, <span class="built_in">id</span>: None &#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-将记录序列化为-CSV">2.5 将记录序列化为 <code>CSV</code></h3><p>  本实例展示了如何序列化 Rust 元组。<code>csv::writer</code> 支持从 Rust 类型到 <code>CSV</code> 记录的自动序列化。<code>write_record</code> 只写入包含字符串数据的简单记录。具有更复杂值（如数字、浮点和选项）的数据使用 <code>serialize</code> 进行序列化。因为 <code>csv::writer</code> 使用内部缓冲区，所以在完成时总是显式刷新 <code>flush</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">CSVError</span>(csv::Error);</span><br><span class="line">        <span class="title function_ invoke__">IOError</span>(std::io::Error);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">wtr</span> = csv::Writer::<span class="title function_ invoke__">from_writer</span>(io::<span class="title function_ invoke__">stdout</span>());</span><br><span class="line"></span><br><span class="line">    wtr.<span class="title function_ invoke__">write_record</span>(&amp;[<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Place&quot;</span>, <span class="string">&quot;ID&quot;</span>])?;</span><br><span class="line"></span><br><span class="line">    wtr.<span class="title function_ invoke__">serialize</span>((<span class="string">&quot;Mark&quot;</span>, <span class="string">&quot;Sydney&quot;</span>, <span class="number">87</span>))?;</span><br><span class="line">    wtr.<span class="title function_ invoke__">serialize</span>((<span class="string">&quot;Ashley&quot;</span>, <span class="string">&quot;Dublin&quot;</span>, <span class="number">32</span>))?;</span><br><span class="line">    wtr.<span class="title function_ invoke__">serialize</span>((<span class="number">456</span>, <span class="string">&quot;Delhi&quot;</span>, <span class="string">&quot;A11&quot;</span>))?;</span><br><span class="line"></span><br><span class="line">    wtr.<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Name,Place,ID</span><br><span class="line">Mark,Sydney,87</span><br><span class="line">Ashley,Dublin,32</span><br><span class="line">456,Delhi,A11</span><br></pre></td></tr></table></figure><h3 id="2-6-转换-CSV-文件的列">2.6 转换 <code>CSV</code> 文件的列</h3><p>  将包含颜色名称和十六进制颜色值的 <code>CSV</code> 文件转换为具有颜色名称和 <code>rgb</code> 颜色值的 <code>CSV</code> 文件。使用 <code>csv</code> crate 读写 <code>csv</code> 文件，使用 <code>serde</code> crate 对行输入字节进行反序列化，对行输出字节进行序列化。详细请参阅 <code>csv::Reader::deserialize</code>、<code>serde::Deserialize</code>，以及 <code>std::str::FromStr</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> csv::&#123;Reader, Writer&#125;;</span><br><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> serde::&#123;de, Deserialize, Deserializer&#125;;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">   foreign_links &#123;</span><br><span class="line">       <span class="title function_ invoke__">CsvError</span>(csv::Error);</span><br><span class="line">       <span class="title function_ invoke__">ParseInt</span>(std::num::ParseIntError);</span><br><span class="line">       <span class="title function_ invoke__">CsvInnerError</span>(csv::IntoInnerError&lt;Writer&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt;&gt;);</span><br><span class="line">       <span class="title function_ invoke__">IO</span>(std::fmt::Error);</span><br><span class="line">       <span class="title function_ invoke__">UTF8</span>(std::string::FromUtf8Error);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HexColor</span> &#123;</span><br><span class="line">    red: <span class="type">u8</span>,</span><br><span class="line">    green: <span class="type">u8</span>,</span><br><span class="line">    blue: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Row</span> &#123;</span><br><span class="line">    color_name: <span class="type">String</span>,</span><br><span class="line">    color: HexColor,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FromStr</span> <span class="keyword">for</span> <span class="title class_">HexColor</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Err</span> = Error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from_str</span>(hex_color: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> std::result::<span class="type">Result</span>&lt;<span class="keyword">Self</span>, <span class="keyword">Self</span>::<span class="literal">Err</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">trimmed</span> = hex_color.<span class="title function_ invoke__">trim_matches</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> trimmed.<span class="title function_ invoke__">len</span>() != <span class="number">6</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Invalid length of hex string&quot;</span>.<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(HexColor &#123;</span><br><span class="line">                red: <span class="type">u8</span>::<span class="title function_ invoke__">from_str_radix</span>(&amp;trimmed[..<span class="number">2</span>], <span class="number">16</span>)?,</span><br><span class="line">                green: <span class="type">u8</span>::<span class="title function_ invoke__">from_str_radix</span>(&amp;trimmed[<span class="number">2</span>..<span class="number">4</span>], <span class="number">16</span>)?,</span><br><span class="line">                blue: <span class="type">u8</span>::<span class="title function_ invoke__">from_str_radix</span>(&amp;trimmed[<span class="number">4</span>..<span class="number">6</span>], <span class="number">16</span>)?,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;de</span>&gt; Deserialize&lt;<span class="symbol">&#x27;de</span>&gt; <span class="keyword">for</span> <span class="title class_">HexColor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deserialize</span>&lt;D&gt;(deserializer: D) <span class="punctuation">-&gt;</span> std::result::<span class="type">Result</span>&lt;<span class="keyword">Self</span>, D::Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        D: Deserializer&lt;<span class="symbol">&#x27;de</span>&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">deserialize</span>(deserializer)?;</span><br><span class="line">        FromStr::<span class="title function_ invoke__">from_str</span>(&amp;s).<span class="title function_ invoke__">map_err</span>(de::Error::custom)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;color_name,color</span></span><br><span class="line"><span class="string">红色,#ff0000</span></span><br><span class="line"><span class="string">绿色,#00ff00</span></span><br><span class="line"><span class="string">蓝色,#0000FF</span></span><br><span class="line"><span class="string">长春花色,#ccccff</span></span><br><span class="line"><span class="string">品红色,#ff00ff&quot;</span></span><br><span class="line">        .<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">out</span> = Writer::<span class="title function_ invoke__">from_writer</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reader</span> = Reader::<span class="title function_ invoke__">from_reader</span>(data.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">result</span> <span class="keyword">in</span> reader.deserialize::&lt;Row&gt;() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = result?;</span><br><span class="line">        out.<span class="title function_ invoke__">serialize</span>((</span><br><span class="line">            res.color_name,</span><br><span class="line">            res.color.red,</span><br><span class="line">            res.color.green,</span><br><span class="line">            res.color.blue,</span><br><span class="line">        ))?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">written</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(out.<span class="title function_ invoke__">into_inner</span>()?)?;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Some</span>(<span class="string">&quot;品红色,255,0,255&quot;</span>), written.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">last</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, written);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">红色,255,0,0</span><br><span class="line">绿色,0,255,0</span><br><span class="line">蓝色,0,0,255</span><br><span class="line">长春花色,204,204,255</span><br><span class="line">品红色,255,0,255</span><br></pre></td></tr></table></figure><h2 id="3-结构化数据">3. 结构化数据</h2><h3 id="3-1-对非结构化-JSON-序列化和反序列化">3.1 对非结构化 <code>JSON</code> 序列化和反序列化</h3><p>  需要安装<code>serde_json</code>库，可通过<code>cargo add serde_json</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0.96&quot;</span></span><br></pre></td></tr></table></figure><p>  <code>serde_json</code> crate 提供了 <code>from_str</code> 函数来解析 <code>JSON</code> 切片 <code>&amp;str</code>。非结构化 <code>JSON</code> 可以被解析为一个通用的 <code>serde_json::Value</code> 类型，该类型能够表示任何有效的 <code>JSON</code> 数据。下面的实例展示如何解析 <code>JSON</code> 切片 <code>&amp;str</code>，期望值被 <code>json!</code> 宏声明。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde_json::json;</span><br><span class="line"><span class="keyword">use</span> serde_json::&#123;Error, Value&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">j</span> = <span class="string">r#&quot;&#123;</span></span><br><span class="line"><span class="string">                 &quot;userid&quot;: 103609,</span></span><br><span class="line"><span class="string">                 &quot;verified&quot;: true,</span></span><br><span class="line"><span class="string">                 &quot;access_privileges&quot;: [</span></span><br><span class="line"><span class="string">                   &quot;用户&quot;,</span></span><br><span class="line"><span class="string">                   &quot;管理员&quot;</span></span><br><span class="line"><span class="string">                 ]</span></span><br><span class="line"><span class="string">               &#125;&quot;#</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed</span>: Value = serde_json::<span class="title function_ invoke__">from_str</span>(j)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expected</span> = json!(&#123;</span><br><span class="line">        <span class="string">&quot;userid&quot;</span>: <span class="number">103609</span>,</span><br><span class="line">        <span class="string">&quot;verified&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;access_privileges&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;用户&quot;</span>,</span><br><span class="line">            <span class="string">&quot;管理员&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(parsed, expected);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="3-2-反序列化-TOML-配置文件">3.2 反序列化 <code>TOML</code> 配置文件</h3><p>  需要安装<code>toml</code>库，可通过<code>cargo add toml</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">toml</span> = <span class="string">&quot;0.7.3&quot;</span></span><br></pre></td></tr></table></figure><p>  将一些 <code>TOML</code> 配置项解析为一个通用的值 <code>toml::Value</code>，该值能够表示任何有效的 <code>TOML</code> 数据。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> toml::&#123;Value, de::Error&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">toml_content</span> = <span class="string">r#&quot;</span></span><br><span class="line"><span class="string">          [package]</span></span><br><span class="line"><span class="string">          name = &quot;your_package&quot;</span></span><br><span class="line"><span class="string">          version = &quot;0.1.0&quot;</span></span><br><span class="line"><span class="string">          authors = [&quot;You! &lt;you@example.org&gt;&quot;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          [dependencies]</span></span><br><span class="line"><span class="string">          serde = &quot;1.0&quot;</span></span><br><span class="line"><span class="string">          &quot;#</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">package_info</span>: Value = toml::<span class="title function_ invoke__">from_str</span>(toml_content)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(package_info[<span class="string">&quot;dependencies&quot;</span>][<span class="string">&quot;serde&quot;</span>].<span class="title function_ invoke__">as_str</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;1.0&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(package_info[<span class="string">&quot;package&quot;</span>][<span class="string">&quot;name&quot;</span>].<span class="title function_ invoke__">as_str</span>(),</span><br><span class="line">               <span class="title function_ invoke__">Some</span>(<span class="string">&quot;your_package&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><p>  使用 <code>Serde</code> crate 将 <code>TOML</code> 解析为自定义的结构体。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::Deserialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> toml::de::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    package: Package,</span><br><span class="line">    dependencies: HashMap&lt;<span class="type">String</span>, <span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    version: <span class="type">String</span>,</span><br><span class="line">    authors: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">toml_content</span> = <span class="string">r#&quot;</span></span><br><span class="line"><span class="string">          [package]</span></span><br><span class="line"><span class="string">          name = &quot;your_package&quot;</span></span><br><span class="line"><span class="string">          version = &quot;0.1.0&quot;</span></span><br><span class="line"><span class="string">          authors = [&quot;You! &lt;you@example.org&gt;&quot;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          [dependencies]</span></span><br><span class="line"><span class="string">          serde = &quot;1.0&quot;</span></span><br><span class="line"><span class="string">          &quot;#</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">package_info</span>: Config = toml::<span class="title function_ invoke__">from_str</span>(toml_content)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(package_info.package.name, <span class="string">&quot;your_package&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(package_info.package.version, <span class="string">&quot;0.1.0&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(package_info.package.authors, <span class="built_in">vec!</span>[<span class="string">&quot;You! &lt;you@example.org&gt;&quot;</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(package_info.dependencies[<span class="string">&quot;serde&quot;</span>], <span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="3-3-以小端模式（低位模式）字节顺序读写整数">3.3 以小端模式（低位模式）字节顺序读写整数</h3><p>  需要安装<code>byteorder</code>库，可通过<code>cargo add byteorder</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">byteorder</span> = <span class="string">&quot;1.4.3&quot;</span></span><br></pre></td></tr></table></figure><p>  字节序 <code>byteorder</code> 可以反转结构化数据的有效字节。当通过网络接收信息时，这可能是必要的，例如接收到的字节来自另一个系统。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> byteorder::&#123;LittleEndian, ReadBytesExt, WriteBytesExt&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default, PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Payload</span> &#123;</span><br><span class="line">    kind: <span class="type">u8</span>,</span><br><span class="line">    value: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">original_payload</span> = Payload::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">encoded_bytes</span> = <span class="title function_ invoke__">encode</span>(&amp;original_payload)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">decoded_payload</span> = <span class="title function_ invoke__">decode</span>(&amp;encoded_bytes)?;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(original_payload, decoded_payload);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">encode</span>(payload: &amp;Payload) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bytes</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    bytes.<span class="title function_ invoke__">write_u8</span>(payload.kind)?;</span><br><span class="line">    bytes.write_u16::&lt;LittleEndian&gt;(payload.value)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(bytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">decode</span>(<span class="keyword">mut</span> bytes: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Payload, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">payload</span> = Payload &#123;</span><br><span class="line">        kind: bytes.<span class="title function_ invoke__">read_u8</span>()?,</span><br><span class="line">        value: bytes.read_u16::&lt;LittleEndian&gt;()?,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(payload)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】九 开发工具</title>
      <link href="/news/1681997809879.html"/>
      <url>/news/1681997809879.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-调试工具">1. 调试工具</h2><h3 id="1-1-日志信息">1.1 日志信息</h3><p>  需要安装<code>log</code>、<code>env_logger</code>2个库，可通过<code>cargo add log</code>、<code>cargo add env_logger</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">env_logger</span> = <span class="string">&quot;0.10.0&quot;</span> <span class="comment"># 半年未更新</span></span><br><span class="line"><span class="attr">log</span> = <span class="string">&quot;0.4.17&quot;</span> <span class="comment"># 一年未更新</span></span><br></pre></td></tr></table></figure><h4 id="1-1-1-记录调试信息到控制台">1.1.1 记录调试信息到控制台</h4><p>  <code>log</code> crate 提供了日志工具，<code>env_logger</code> crate 通过环境变量配置日志记录。<code>log::debug!</code> 宏的工作方式类似于其它 <code>std::fmt</code> 格式化的字符串。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">execute_query</span>(query: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    log::debug!(<span class="string">&quot;执行操作: &#123;&#125;&quot;</span>, query);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    env_logger::<span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">execute_query</span>(<span class="string">&quot;删除学生表&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>RUST_LOG=debug cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2023-04-17T13:03:21Z DEBUG development] 执行操作: 删除学生表</span><br></pre></td></tr></table></figure><h4 id="1-1-2-记录错误信息到控制台">1.1.2 记录错误信息到控制台</h4><p>  正确的错误处理会将异常视为错误。下述实例中，通过 <code>log</code> 便捷宏 <code>log::error!</code>，将错误记录到 <code>stderr</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">execute_query</span>(_query: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(<span class="string">&quot;恐怕做不到&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    env_logger::<span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="title function_ invoke__">execute_query</span>(<span class="string">&quot;DROP TABLE students&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(err) = response &#123;</span><br><span class="line">        log::error!(<span class="string">&quot;执行操作失败: &#123;&#125;&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2023-04-17T13:07:33Z ERROR development] 执行操作失败: 恐怕做不到</span><br></pre></td></tr></table></figure><h4 id="1-1-3-记录信息时，用标准输出-stdout-替换标准错误-stderr">1.1.3 记录信息时，用标准输出 <code>stdout</code> 替换标准错误 <code>stderr</code></h4><p>  使用 <code>Builder::target</code> 创建自定义的日志记录器配置，将日志输出的目标设置为 <code>Target::Stdout</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> env_logger::&#123;Builder, Target&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Builder::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">target</span>(Target::Stdout).<span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">    log::error!(<span class="string">&quot;此错误已打印到标准输出&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2023-04-17T13:10:37Z ERROR development] 此错误已打印到标准输出</span><br></pre></td></tr></table></figure><h4 id="1-1-4-记录信息时，用标准输出-stdout-替换标准错误-stderr">1.1.4 记录信息时，用标准输出 <code>stdout</code> 替换标准错误 <code>stderr</code></h4><p>  实现一个打印到 <code>stdout</code> 的自定义记录器 <code>ConsoleLogger</code>。为了使用日志宏，<code>ConsoleLogger</code>实现了 <code>log::Log trait</code>，通过 <code>log::set_logger</code> 安置。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> log::&#123;Level, LevelFilter, Metadata, Record, SetLoggerError&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> CONSOLE_LOGGER: ConsoleLogger = ConsoleLogger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConsoleLogger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">log</span>::Log <span class="keyword">for</span> <span class="title class_">ConsoleLogger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">enabled</span>(&amp;<span class="keyword">self</span>, metadata: &amp;Metadata) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        metadata.<span class="title function_ invoke__">level</span>() &lt;= Level::Info</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">log</span>(&amp;<span class="keyword">self</span>, record: &amp;Record) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">enabled</span>(record.<span class="title function_ invoke__">metadata</span>()) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Rust says: &#123;&#125; - &#123;&#125;&quot;</span>, record.<span class="title function_ invoke__">level</span>(), record.<span class="title function_ invoke__">args</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">flush</span>(&amp;<span class="keyword">self</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), SetLoggerError&gt; &#123;</span><br><span class="line">    log::<span class="title function_ invoke__">set_logger</span>(&amp;CONSOLE_LOGGER)?;</span><br><span class="line">    log::<span class="title function_ invoke__">set_max_level</span>(LevelFilter::Info);</span><br><span class="line"></span><br><span class="line">    log::info!(<span class="string">&quot;信息日志&quot;</span>);</span><br><span class="line">    log::warn!(<span class="string">&quot;警告日志&quot;</span>);</span><br><span class="line">    log::error!(<span class="string">&quot;错误日志&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Rust says: INFO - 信息日志</span><br><span class="line">Rust says: WARN - 警告日志</span><br><span class="line">Rust says: ERROR - 错误日志</span><br></pre></td></tr></table></figure><h4 id="1-1-5-记录到-Unix-系统日志">1.1.5 记录到 Unix 系统日志</h4><p>  需要额外安装<code>syslog</code>库，可通过<code>cargo add syslog</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">env_logger</span> = <span class="string">&quot;0.10.0&quot;</span> <span class="comment"># 半年未更新</span></span><br><span class="line"><span class="attr">log</span> = <span class="string">&quot;0.4.17&quot;</span> <span class="comment"># 一年未更新</span></span><br><span class="line"><span class="attr">syslog</span> = <span class="string">&quot;6.0.1&quot;</span> <span class="comment"># 一年未更新</span></span><br></pre></td></tr></table></figure><p>  实现将信息记录到 <code>UNIX</code> <code>syslog</code>。使用 <code>syslog::init</code> 初始化记录器后端。<code>syslog::Facility</code> 记录提交日志项分类的程序，<code>log::LevelFilter</code> 表示欲记录日志的等级，<code>Option&lt;&amp;str&gt;</code> 定义应用程序名称（可选）。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(target_os = <span class="string">&quot;linux&quot;</span>)]</span></span><br><span class="line"><span class="meta">#[cfg(target_os = <span class="string">&quot;linux&quot;</span>)]</span></span><br><span class="line"><span class="keyword">use</span> syslog::&#123;Error, Facility&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(target_os = <span class="string">&quot;linux&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    syslog::<span class="title function_ invoke__">init</span>(</span><br><span class="line">        Facility::LOG_USER,</span><br><span class="line">        log::LevelFilter::<span class="built_in">Debug</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="string">&quot;测试系统日志&quot;</span>),</span><br><span class="line">    )?;</span><br><span class="line">    log::debug!(<span class="string">&quot;这是debug信息 &#123;&#125;&quot;</span>, <span class="string">&quot;message&quot;</span>);</span><br><span class="line">    log::error!(<span class="string">&quot;这是一个Error信息!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(not(target_os = <span class="string">&quot;linux&quot;</span>))]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;So far, only Linux systems are supported.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出到系统日志，可通过<code>tail -f /var/log/syslog</code>系统命令查看输出的日志内容，如下</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Apr 17 14:50:34 dynasty dynasty 测试系统日志[838264]: 这是debug信息 message</span><br><span class="line">Apr 17 14:50:34 dynasty dynasty 测试系统日志[838264]: 这是一个Error信息!</span><br></pre></td></tr></table></figure><h3 id="1-2-日志配置">1.2 日志配置</h3><h4 id="1-2-1-启用每个模块的日志级别">1.2.1 启用每个模块的日志级别</h4><p>  创建两个模块：<code>foo</code> 和其嵌套的 <code>foo::bar</code>，日志记录指令分别由 <code>RUST_LOG</code> 环境变量控制。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> foo &#123;</span><br><span class="line">    <span class="keyword">mod</span> bar &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>() &#123;</span><br><span class="line">            log::warn!(<span class="string">&quot;[bar] warn&quot;</span>);</span><br><span class="line">            log::info!(<span class="string">&quot;[bar] info&quot;</span>);</span><br><span class="line">            log::debug!(<span class="string">&quot;[bar] debug&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>() &#123;</span><br><span class="line">        log::warn!(<span class="string">&quot;[foo] warn&quot;</span>);</span><br><span class="line">        log::info!(<span class="string">&quot;[foo] info&quot;</span>);</span><br><span class="line">        log::debug!(<span class="string">&quot;[foo] debug&quot;</span>);</span><br><span class="line">        bar::<span class="title function_ invoke__">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    env_logger::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    log::warn!(<span class="string">&quot;[root] warn&quot;</span>);</span><br><span class="line">    log::info!(<span class="string">&quot;[root] info&quot;</span>);</span><br><span class="line">    log::debug!(<span class="string">&quot;[root] debug&quot;</span>);</span><br><span class="line">    foo::<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>RUST_LOG=&quot;warn,development::foo=info,development::foo::bar=debug&quot; cargo run</code>(注意这块的<code>development</code>为项目名称)命令，输出如下:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2023-04-17T15:00:37Z WARN  development] [root] warn</span><br><span class="line">[2023-04-17T15:00:37Z WARN  development::foo] [foo] warn</span><br><span class="line">[2023-04-17T15:00:37Z INFO  development::foo] [foo] info</span><br><span class="line">[2023-04-17T15:00:37Z WARN  development::foo::bar] [bar] warn</span><br><span class="line">[2023-04-17T15:00:37Z INFO  development::foo::bar] [bar] info</span><br><span class="line">[2023-04-17T15:00:37Z DEBUG development::foo::bar] [bar] debug</span><br></pre></td></tr></table></figure><h4 id="1-2-2-用自定义环境变量设置日志记录">1.2.2 用自定义环境变量设置日志记录</h4><p>  <code>Builder</code> 配置日志记录。<code>Builder::parse</code> 以 <code>RUST_LOG</code> 语法的形式解析 <code>MY_APP_LOG</code> 环境变量的内容。然后，<code>Builder::init</code> 初始化记录器。所有这些步骤通常由 <code>env_logger::init</code> 在内部完成。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> env_logger::Builder;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Builder::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">parse_filters</span>(&amp;env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;MY_APP_LOG&quot;</span>).<span class="title function_ invoke__">unwrap_or_default</span>()) <span class="comment">//parse_filters代替parse方法</span></span><br><span class="line">        .<span class="title function_ invoke__">init</span>();</span><br><span class="line">    log::info!(<span class="string">&quot;信息消息&quot;</span>);</span><br><span class="line">    log::warn!(<span class="string">&quot;警告消息&quot;</span>);</span><br><span class="line">    log::error!(<span class="string">&quot;这是个错误 &#123;&#125;&quot;</span>, <span class="string">&quot;message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>MY_APP_LOG=info cargo run</code>命令，输出如下:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2023-04-18T13:41:21Z INFO  development] 信息消息</span><br><span class="line">[2023-04-18T13:41:21Z WARN  development] 警告消息</span><br><span class="line">[2023-04-18T13:41:21Z ERROR development] 这是个错误 message</span><br></pre></td></tr></table></figure><h4 id="1-2-3-在日志信息中包含时间戳">1.2.3 在日志信息中包含时间戳</h4><p>  需要额外安装<code>chrono</code>库，可通过<code>cargo add chrono</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">env_logger</span> = <span class="string">&quot;0.10.0&quot;</span> <span class="comment"># 半年未更新</span></span><br><span class="line"><span class="attr">log</span> = <span class="string">&quot;0.4.17&quot;</span> <span class="comment"># 一年未更新</span></span><br><span class="line"><span class="attr">chrono</span> = <span class="string">&quot;0.4.24&quot;</span></span><br></pre></td></tr></table></figure><p>  使用 <code>Builder</code> 创建自定义记录器配置。每个日志项调用 <code>Local::now</code> 以获取本地时区中的当前 <code>DateTime</code>，并使用 <code>DateTime::format</code> 和 <code>strftime::specifiers</code> 来格式化最终日志中使用的时间戳。如下实例调用 <code>Builder::format</code> 设置一个闭包，该闭包用时间戳、<code>Record::level</code> 和正文（<code>Record::args</code>）对每个信息文本进行格式化。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> chrono::Local;</span><br><span class="line"><span class="keyword">use</span> env_logger::Builder;</span><br><span class="line"><span class="keyword">use</span> log::LevelFilter;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Builder::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">format</span>(|buf, record| &#123;</span><br><span class="line">            <span class="built_in">writeln!</span>(</span><br><span class="line">                buf,</span><br><span class="line">                <span class="string">&quot;&#123;&#125; [&#123;&#125;] - &#123;&#125;&quot;</span>,</span><br><span class="line">                Local::<span class="title function_ invoke__">now</span>().<span class="title function_ invoke__">format</span>(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>),</span><br><span class="line">                record.<span class="title function_ invoke__">level</span>(),</span><br><span class="line">                record.<span class="title function_ invoke__">args</span>()</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(<span class="literal">None</span>, LevelFilter::Info)</span><br><span class="line">        .<span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">    log::warn!(<span class="string">&quot;warn&quot;</span>);</span><br><span class="line">    log::info!(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    log::debug!(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>命令，输出如下:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2023-04-18 13:47:50 [WARN] - warn</span><br><span class="line">2023-04-18 13:47:50 [INFO] - info</span><br></pre></td></tr></table></figure><h4 id="1-2-4-将信息记录到自定义位置">1.2.4 将信息记录到自定义位置</h4><p>  需要额外安装<code>log4rs</code>和<code>error_chain</code>库，可通过<code>cargo add log4rs</code>、<code>cargo add error_chain</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br><span class="line"><span class="attr">log</span> = <span class="string">&quot;0.4.17&quot;</span> <span class="comment"># 一年未更新</span></span><br><span class="line"><span class="attr">log4rs</span> = <span class="string">&quot;1.2.0&quot;</span></span><br></pre></td></tr></table></figure><p>  使用 <code>Builder</code> 创建自定义记录器配置。每个日志项调用 <code>Local::now</code> 以获取本地时区中的当前 <code>DateTime</code>，并使用 <code>DateTime::format</code> 和 <code>strftime::specifiers</code> 来格式化最终日志中使用的时间戳。如下实例调用 <code>Builder::format</code> 设置一个闭包，该闭包用时间戳、<code>Record::level</code> 和正文（<code>Record::args</code>）对每个信息文本进行格式化。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> log::LevelFilter;</span><br><span class="line"><span class="keyword">use</span> log4rs::append::file::FileAppender;</span><br><span class="line"><span class="keyword">use</span> log4rs::config::&#123;Appender, Config, Root&#125;;</span><br><span class="line"><span class="keyword">use</span> log4rs::encode::pattern::PatternEncoder;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">LogConfig</span>(log4rs::config::FormatError);</span><br><span class="line">        <span class="title function_ invoke__">SetLogger</span>(log::SetLoggerError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">logfile</span> = FileAppender::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">        .<span class="title function_ invoke__">encoder</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PatternEncoder::<span class="title function_ invoke__">new</span>(<span class="string">&quot;&#123;d&#125; -[&#123;l&#125;]: &#123;m&#125;&#123;n&#125;&quot;</span>)))</span><br><span class="line">        .<span class="title function_ invoke__">build</span>(<span class="string">&quot;log/output.log&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">        .<span class="title function_ invoke__">appender</span>(Appender::<span class="title function_ invoke__">builder</span>().<span class="title function_ invoke__">build</span>(<span class="string">&quot;logfile&quot;</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(logfile)))</span><br><span class="line">        .<span class="title function_ invoke__">build</span>(Root::<span class="title function_ invoke__">builder</span>().<span class="title function_ invoke__">appender</span>(<span class="string">&quot;logfile&quot;</span>).<span class="title function_ invoke__">build</span>(LevelFilter::Info))</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    log4rs::<span class="title function_ invoke__">init_config</span>(config)?;</span><br><span class="line"></span><br><span class="line">    log::info!(<span class="string">&quot;输出日志&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>命令生成<code>log</code>日志，可通过<code>cat log/output.log</code>命令查看输出的日志:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2023-04-18T14:03:39.703966199+00:00 -[INFO]: 输出日志</span><br></pre></td></tr></table></figure><h2 id="2-版本控制">2. 版本控制</h2><p>  需要安装<code>semver</code>库，可通过<code>cargo add semver</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">semver</span> = <span class="string">&quot;1.0.17&quot;</span> <span class="comment"># api 变化大</span></span><br></pre></td></tr></table></figure><h3 id="2-1-解析并递增版本字符串">2.1 解析并递增版本字符串</h3><p>  使用 <code>Version::parse</code> 从字符串字面量构造语义化版本 <code>semver::Version</code>，然后逐个递增补丁（修订）版本号、副（次要）版本号和主版本号。**注意：**根据语义化版本控制规范，增加副（次要）版本号时会将补丁（修订）版本号重置为 <code>0</code>，增加主版本号时会将副（次要）版本号和补丁（修订）版本号都重置为 <code>0</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> semver::&#123;BuildMetadata, Error, Prerelease, Version&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">parsed_version</span> = Version::<span class="title function_ invoke__">parse</span>(<span class="string">&quot;0.2.6&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        parsed_version,</span><br><span class="line">        Version &#123;</span><br><span class="line">            major: <span class="number">0</span>,</span><br><span class="line">            minor: <span class="number">2</span>,</span><br><span class="line">            patch: <span class="number">6</span>,</span><br><span class="line">            pre: Prerelease::EMPTY,</span><br><span class="line">            build: BuildMetadata::EMPTY,</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parsed_version.increment_patch(); // 开发者删除该实现，需要用户自己实现</span></span><br><span class="line">    <span class="title function_ invoke__">increment_patch</span>(&amp;<span class="keyword">mut</span> parsed_version);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(parsed_version.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;0.2.7&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;新的补丁发布: v&#123;&#125;&quot;</span>, parsed_version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parsed_version.increment_minor(); // 开发者删除该实现，需要用户自己实现</span></span><br><span class="line">    <span class="title function_ invoke__">increment_minor</span>(&amp;<span class="keyword">mut</span> parsed_version);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(parsed_version.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;0.3.0&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;新的次要版本: v&#123;&#125;&quot;</span>, parsed_version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parsed_version.increment_major(); // 开发者删除该实现，需要用户自己实现</span></span><br><span class="line">    <span class="title function_ invoke__">increment_major</span>(&amp;<span class="keyword">mut</span> parsed_version);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(parsed_version.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;1.0.0&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;新的主要版本: v&#123;&#125;&quot;</span>, parsed_version);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">increment_patch</span>(v: &amp;<span class="keyword">mut</span> Version) &#123;</span><br><span class="line">    v.patch += <span class="number">1</span>;</span><br><span class="line">    v.pre = Prerelease::EMPTY;</span><br><span class="line">    v.build = BuildMetadata::EMPTY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">increment_minor</span>(v: &amp;<span class="keyword">mut</span> Version) &#123;</span><br><span class="line">    v.minor += <span class="number">1</span>;</span><br><span class="line">    v.patch = <span class="number">0</span>;</span><br><span class="line">    v.pre = Prerelease::EMPTY;</span><br><span class="line">    v.build = BuildMetadata::EMPTY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">increment_major</span>(v: &amp;<span class="keyword">mut</span> Version) &#123;</span><br><span class="line">    v.major += <span class="number">1</span>;</span><br><span class="line">    v.minor = <span class="number">0</span>;</span><br><span class="line">    v.patch = <span class="number">0</span>;</span><br><span class="line">    v.pre = Prerelease::EMPTY;</span><br><span class="line">    v.build = BuildMetadata::EMPTY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">新的补丁发布: v0.2.7</span><br><span class="line">新的次要版本: v0.3.0</span><br><span class="line">新的主要版本: v1.0.0</span><br></pre></td></tr></table></figure><h3 id="2-2-解析复杂的版本字符串">2.2 解析复杂的版本字符串</h3><p>  使用 <code>Version::parse</code> 从复杂的版本字符串构造语义化版本 <code>semver::Version</code>。该字符串包含语义化版本控制规范中定义的预发布和构建元数据。需要注意的是：根据语义化版本控制规范，构建元数据是虽然被解析，但在比较版本时不考虑。换句话说，即使两个版本的构建字符串不同，但它们的版本可能是相等的。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> semver::&#123;BuildMetadata, Comparator, Error, Prerelease, Version&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">version_str</span> = <span class="string">&quot;1.0.49-125+g72ee7853&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不考虑build版本的比较</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">comparator_version</span> = Comparator::<span class="title function_ invoke__">parse</span>(version_str)?;</span><br><span class="line"></span><br><span class="line">    Comparator::<span class="title function_ invoke__">matches</span>(</span><br><span class="line">        &amp;comparator_version,</span><br><span class="line">        &amp;Version &#123;</span><br><span class="line">            major: <span class="number">1</span>,</span><br><span class="line">            minor: <span class="number">0</span>,</span><br><span class="line">            patch: <span class="number">49</span>,</span><br><span class="line">            pre: Prerelease::<span class="title function_ invoke__">new</span>(<span class="string">&quot;125&quot;</span>)?,</span><br><span class="line">            build: BuildMetadata::EMPTY, <span class="comment">// 不考虑build版本的比较</span></span><br><span class="line">        &#125;,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 将版本号字符串解析为完整的版本号对象，考虑build版本的比较</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed_version</span> = Version::<span class="title function_ invoke__">parse</span>(version_str)?;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(parsed_version.build, BuildMetadata::<span class="title function_ invoke__">new</span>(<span class="string">&quot;g72ee7853&quot;</span>)?);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">serialized_version</span> = parsed_version.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;serialized_version, version_str);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="2-3-检查给定版本是否为预发布版本">2.3 检查给定版本是否为预发布版本</h3><p>  给定两个版本，使用 <code>is_prerelease</code> 断言一个是预发布，另一个不是。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> semver::&#123;Error, Version&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">version_1</span> = Version::<span class="title function_ invoke__">parse</span>(<span class="string">&quot;1.0.0-alpha&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">version_2</span> = Version::<span class="title function_ invoke__">parse</span>(<span class="string">&quot;1.0.0&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原函数is_prerelease已删除通过version_1.pre判断</span></span><br><span class="line">    <span class="built_in">assert!</span>(!version_1.pre.<span class="title function_ invoke__">is_empty</span>()); <span class="comment">// 断言version1为预发布版本</span></span><br><span class="line">    <span class="built_in">assert!</span>(version_2.pre.<span class="title function_ invoke__">is_empty</span>()); <span class="comment">// 断言version2不是预发布版本</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="2-4-查询适配给定范围的最新版本">2.4 查询适配给定范围的最新版本</h3><p>  给定两个版本，使用 <code>is_prerelease</code> 断言一个是预发布，另一个不是。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> semver::&#123;Error, Version&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">version_1</span> = Version::<span class="title function_ invoke__">parse</span>(<span class="string">&quot;1.0.0-alpha&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">version_2</span> = Version::<span class="title function_ invoke__">parse</span>(<span class="string">&quot;1.0.0&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原函数is_prerelease已删除通过version_1.pre判断</span></span><br><span class="line">    <span class="built_in">assert!</span>(!version_1.pre.<span class="title function_ invoke__">is_empty</span>()); <span class="comment">// 断言version1为预发布版本</span></span><br><span class="line">    <span class="built_in">assert!</span>(version_2.pre.<span class="title function_ invoke__">is_empty</span>()); <span class="comment">// 断言version2不是预发布版本</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="2-5-查询适配给定范围的最新版本">2.5 查询适配给定范围的最新版本</h3><p>  给定一个版本字符串 <code>&amp;str</code> 的列表，查找最新的语义化版本 <code>semver::Version</code>。<code>semver::VersionReq</code> 用 <code>VersionReq::matches</code> 过滤列表，也可以展示语义化版本 <code>semver</code> 的预发布参数设置。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> semver::&#123;Version, VersionReq&#125;;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">SemVer</span>(semver::Error);</span><br><span class="line">        <span class="comment">// SemVerReq(semver::Error);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_max_matching_version</span>&lt;<span class="symbol">&#x27;a</span>, I&gt;(version_req_str: &amp;<span class="type">str</span>, iterable: I) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Option</span>&lt;Version&gt;&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    I: <span class="built_in">IntoIterator</span>&lt;Item = &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vreq</span> = VersionReq::<span class="title function_ invoke__">parse</span>(version_req_str)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(iterable</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|s| Version::<span class="title function_ invoke__">parse</span>(s).<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|s| vreq.<span class="title function_ invoke__">matches</span>(s))</span><br><span class="line">        .<span class="title function_ invoke__">max</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="title function_ invoke__">find_max_matching_version</span>(<span class="string">&quot;&lt;= 1.0.0&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;0.9.0&quot;</span>, <span class="string">&quot;1.0.0&quot;</span>, <span class="string">&quot;1.0.1&quot;</span>])?,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(Version::<span class="title function_ invoke__">parse</span>(<span class="string">&quot;1.0.0&quot;</span>)?)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="title function_ invoke__">find_max_matching_version</span>(</span><br><span class="line">            <span class="string">&quot;&gt;1.2.3-alpha.3&quot;</span>,</span><br><span class="line">            <span class="built_in">vec!</span>[</span><br><span class="line">                <span class="string">&quot;1.2.3-alpha.3&quot;</span>,</span><br><span class="line">                <span class="string">&quot;1.2.3-alpha.4&quot;</span>,</span><br><span class="line">                <span class="string">&quot;1.2.3-alpha.10&quot;</span>,</span><br><span class="line">                <span class="string">&quot;1.2.3-beta.4&quot;</span>,</span><br><span class="line">                <span class="string">&quot;3.4.5-alpha.9&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">        )?,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(Version::<span class="title function_ invoke__">parse</span>(<span class="string">&quot;1.2.3-beta.4&quot;</span>)?)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="2-6-检查外部命令的版本兼容性">2.6 检查外部命令的版本兼容性</h3><p>  实例使用 <code>Command</code> 模块运行命令 <code>git --version</code>，然后使用 <code>Version::parse</code> 将版本号解析为语义化版本 <code>semver::Version</code>。<code>VersionReq::matches</code> 将 <code>semver::VersionReq</code> 与解析的语义化版本进行比较。最终，命令输出类似于“<code>git version x.y.z</code>”</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> semver::&#123;Version, VersionReq&#125;;</span><br><span class="line"><span class="keyword">use</span> std::process::Command;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">Utf8</span>(std::string::FromUtf8Error);</span><br><span class="line">        <span class="title function_ invoke__">SemVer</span>(semver::Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">version_constraint</span> = <span class="string">&quot;&gt; 1.12.0&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">version_test</span> = VersionReq::<span class="title function_ invoke__">parse</span>(version_constraint)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span> = Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;git&quot;</span>).<span class="title function_ invoke__">arg</span>(<span class="string">&quot;--version&quot;</span>).<span class="title function_ invoke__">output</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !output.status.<span class="title function_ invoke__">success</span>() &#123;</span><br><span class="line">        error_chain::bail!(<span class="string">&quot;执行命令失败错误代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stdout</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(output.stdout)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">version</span> = stdout</span><br><span class="line">        .<span class="title function_ invoke__">trim</span>() <span class="comment">//处理多余的回车符号</span></span><br><span class="line">        .<span class="title function_ invoke__">split</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">last</span>()</span><br><span class="line">        .<span class="title function_ invoke__">ok_or_else</span>(|| <span class="string">&quot;命令输出无效&quot;</span>)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, version);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed_version</span> = Version::<span class="title function_ invoke__">parse</span>(version)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !version_test.<span class="title function_ invoke__">matches</span>(&amp;parsed_version) &#123;</span><br><span class="line">        error_chain::bail!(</span><br><span class="line">            <span class="string">&quot;命令版本低于最低支持版本 (找到 &#123;&#125;, 需要 &#123;&#125;)&quot;</span>,</span><br><span class="line">            parsed_version,</span><br><span class="line">            version_constraint</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2.34.1</span><br></pre></td></tr></table></figure><h2 id="3-构建工具">3. 构建工具</h2><p>  本节介绍在编译 <code>crate</code> 源代码之前运行的“构建时”工具或代码。按照惯例，构建时代码存放在 <strong><a href="http://build.rs">build.rs</a></strong> 文件，通常称为“构建脚本”。常见的用例包括：Rust 代码生成、绑定的 <strong>C/C++/asm</strong>代码的编译。要获取更多信息，请阅读（Cargo 手册 中文版） 的构建脚本文档。</p><h3 id="3-1-编译并静态链接到绑定的-C-语言库">3.1 编译并静态链接到绑定的 <strong>C</strong> 语言库</h3><p>  为了适应项目中需要混合 <strong>C、C++，或 asm</strong>等语言的场景，<strong>cc crate</strong> 提供了一个简单的 API，用于将绑定的 <strong>C/C++/asm</strong> 代码编译成静态库（<strong>.a</strong>），静态库可以通过 <strong>rustc</strong> 静态链接。下面的实例有一些绑定的 <strong>C</strong> 语言代码（<strong>src/hello.c</strong>），将从 rust 中调用它们。在编译 rust 源代码之前，<strong>Cargo.toml</strong>中指定的“构建”文件（<strong><a href="http://build.rs">build.rs</a></strong>）预先运行。使用 <strong>cc</strong> crate，将生成一个静态库文件（本实例中为 <strong>libhello.a</strong>，请参阅 compile 文档），通过在 <code>extern</code> 代码块中声明外部函数签名，然后就可以从 <strong>rust</strong> 中调用该静态库。<br>  本实例中绑定的 <strong>C</strong> 语言文件非常简单，只需要将一个源文件传递给 <code>cc::Build</code>。对于更复杂的构建需求，<code>cc::Build</code> 提供了一整套构建器方法，用于指定（包含）<strong>include</strong>路径和扩展编译器标志（flag）。</p><ul><li>需要安装<code>cc</code>库,<code>Cargo.toml</code>文件内容配置如下：</li></ul><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line">...</span><br><span class="line"><span class="attr">build</span> = <span class="string">&quot;build.rs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-dependencies]</span></span><br><span class="line"><span class="attr">cc</span> = <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>build.rs</code>文件内容如下：</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    cc::Build::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">file</span>(<span class="string">&quot;src/hello.c&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">compile</span>(<span class="string">&quot;hello&quot;</span>);   <span class="comment">// 输出 `libhello.a`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>src/hello.c</code>文件内容如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from C!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">greet</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你好, %s!\n&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>src/main.rs</code>文件内容如下：</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> std::ffi::CString;</span><br><span class="line"><span class="keyword">use</span> std::os::raw::c_char;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">NulError</span>(::std::ffi::NulError);</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(::std::io::Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">prompt</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">use</span> std::io::Write;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    std::io::<span class="title function_ invoke__">stdout</span>().<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    std::io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(input.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hello</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greet</span>(name: *<span class="keyword">const</span> c_char);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">hello</span>() &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;你娃叫啥? &quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c_name</span> = CString::<span class="title function_ invoke__">new</span>(name)?;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">greet</span>(c_name.<span class="title function_ invoke__">as_ptr</span>()) &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>,输入<strong>Rust</strong>。输出如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello from C!</span><br><span class="line">你娃叫啥? Rust</span><br><span class="line">你好, Rust!</span><br></pre></td></tr></table></figure><ul><li>注：这里修改<code>src/hello.c</code>文件内容后,需要同时修改<code>build.rs</code>中的内容（可随意修改后撤回并<strong>Ctrl+S</strong>保存），否则运行时无法获取最新修改后的信息。</li></ul><h3 id="3-2-编译并静态链接到绑定的-C-语言库">3.2 编译并静态链接到绑定的 <strong>C++</strong> 语言库</h3><p>  链接绑定的 <strong>C++</strong> 语言库非常类似于链接绑定的 <strong>C</strong> 语言库。编译并静态链接绑定的 <strong>C++</strong> 库时，与链接绑定的 <strong>C</strong> 语言库相比有两个核心区别：一是通过构造器方法 <strong>cpp(true)</strong> 指定 <strong>C++</strong> 编译器；二是通过在 <strong>C++</strong> 源文件顶部添加 <code>extern &quot;C&quot;</code> 代码段，以防止 <strong>C++</strong> 编译器的名称篡改。</p><ul><li><code>Cargo.toml</code>文件内容配置如下：</li></ul><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line">...</span><br><span class="line"><span class="attr">build</span> = <span class="string">&quot;build.rs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-dependencies]</span></span><br><span class="line"><span class="attr">cc</span> = <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>build.rs</code>文件内容如下：</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    cc::Build::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">cpp</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="title function_ invoke__">file</span>(<span class="string">&quot;src/foo.cpp&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">compile</span>(<span class="string">&quot;foo&quot;</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>src/foo.cpp</code>文件内容如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>src/main.rs</code>文件内容如下：</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">multiply</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;乘积为：&#123;&#125;&quot;</span>, <span class="title function_ invoke__">multiply</span>(<span class="number">5</span>, <span class="number">7</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">乘积为：35</span><br></pre></td></tr></table></figure><h3 id="3-3-编译-C-语言库时自定义设置">3.3 编译 <strong>C</strong> 语言库时自定义设置</h3><p>  使用 <code>cc::Build::define</code>自定义构建绑定的 <strong>C</strong> 语言代码非常简单。该方法接受 <code>Option</code> 值，因此可以创建这样的定义：<code>#define APP_NAME &quot;foo&quot;</code>、<code>#define WELCOME</code>（将 <code>None</code> 作为不确定值传递）。如下实例构建了一个绑定的 <strong>C</strong> 语言文件，其在 <strong><a href="http://build.rs">build.rs</a></strong> 中设置了动态定义，并在运行时打印 “Welcome to foo - version 1.0.2”。<strong>Cargo</strong> 设定了一些环境变量，这些变量可能对某些自定义设置有用。</p><ul><li><code>Cargo.toml</code>文件内容配置如下：</li></ul><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line">...</span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">build</span> = <span class="string">&quot;build.rs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-dependencies]</span></span><br><span class="line"><span class="attr">cc</span> = <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>build.rs</code>文件内容如下：</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    cc::Build::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">define</span>(<span class="string">&quot;APP_NAME&quot;</span>, <span class="string">&quot;\&quot;无名\&quot;&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">define</span>(</span><br><span class="line">            <span class="string">&quot;VERSION&quot;</span>,</span><br><span class="line">            <span class="built_in">format!</span>(<span class="string">&quot;\&quot;&#123;&#125;\&quot;&quot;</span>, <span class="built_in">env!</span>(<span class="string">&quot;CARGO_PKG_VERSION&quot;</span>)).<span class="title function_ invoke__">as_str</span>(),</span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">define</span>(<span class="string">&quot;WELCOME&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        .<span class="title function_ invoke__">file</span>(<span class="string">&quot;src/foo.c&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">compile</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>src/foo.c</code>文件内容如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_app_info</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WELCOME</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;欢迎：&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s - 版本 %s\n&quot;</span>, APP_NAME, VERSION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>src/main.rs</code>文件内容如下：</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_app_info</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">print_app_info</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">欢迎：无名 - 版本 0.1.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】八 日期与时间</title>
      <link href="/news/1681654162938.html"/>
      <url>/news/1681654162938.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-期间和计算">1. 期间和计算</h2><h3 id="1-1-测量运行时间">1.1 测量运行时间</h3><p>  测量从 <code>time::Instant::now</code> 开始运行的时间 <code>time::Instant::elapsed</code>。调用 <code>time::Instant::elapsed</code> 将返回 <code>time::Duration</code>，在实例末尾打印该时间。此方法不会更改或者重置 <code>time::Instant</code> 对象。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expensive_function</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="title function_ invoke__">expensive_function</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">duration</span> = start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;expensive_function() 函数运行的时间是: &#123;:?&#125;&quot;</span>, duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">expensive_function() 函数运行的时间是: 2.000175481s</span><br></pre></td></tr></table></figure><h3 id="1-2-执行日期检查和时间计算">1.2 执行日期检查和时间计算</h3><p>  需要安装<code>chrono</code>库，可通过<code>cargo add chrono</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">chrono</span> = <span class="string">&quot;0.4.24&quot;</span></span><br></pre></td></tr></table></figure><p>  使用 <code>DateTime::checked_add_signed</code> 计算并显示两周之后的日期和时间，使用 <code>DateTime::checked_sub_signed</code> 计算并显示前一天的日期。如果无法计算出日期和时间，这些方法将返回 <code>None</code>。可以在 <code>chrono::format::strftime</code> 中找到适用于 <code>DateTime::format</code> 的转义序列。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> chrono::&#123;DateTime, Duration, Utc&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">day_earlier</span>(date_time: DateTime&lt;Utc&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;DateTime&lt;Utc&gt;&gt; &#123;</span><br><span class="line">    date_time.<span class="title function_ invoke__">checked_sub_signed</span>(Duration::<span class="title function_ invoke__">days</span>(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">now</span> = Utc::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, now);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">almost_three_weeks_from_now</span> = now</span><br><span class="line">        .<span class="title function_ invoke__">checked_add_signed</span>(Duration::<span class="title function_ invoke__">weeks</span>(<span class="number">2</span>))</span><br><span class="line">        .<span class="title function_ invoke__">and_then</span>(|in_2weeks| in_2weeks.<span class="title function_ invoke__">checked_add_signed</span>(Duration::<span class="title function_ invoke__">weeks</span>(<span class="number">1</span>)))</span><br><span class="line">        .<span class="title function_ invoke__">and_then</span>(day_earlier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> almost_three_weeks_from_now &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x),</span><br><span class="line">        <span class="literal">None</span> =&gt; eprintln!(<span class="string">&quot;将近三周后!&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> now.<span class="title function_ invoke__">checked_add_signed</span>(Duration::<span class="title function_ invoke__">max_value</span>()) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x),</span><br><span class="line">        <span class="literal">None</span> =&gt; eprintln!(<span class="string">&quot;我们不能用 chrono 来判断太阳系绕银河中心完成超过一圈完整轨道的时间.&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2023-04-16 13:23:26.368785736 UTC</span><br><span class="line">2023-05-07 13:23:26.368785736 UTC</span><br><span class="line">我们不能用 chrono 来判断太阳系绕银河中心完成超过一圈完整轨道的时间.</span><br></pre></td></tr></table></figure><h3 id="1-3-时间的时区转换">1.3 时间的时区转换</h3><p>  使用 <code>offset::Local::now</code> 获取本地时间并显示，然后使用 <code>DateTime::from_utc</code> 结构体方法将其转换为 <code>UTC</code> 标准格式。最后，使用 <code>offset::FixedOffset</code> 结构体，可以将 <code>UTC</code> 时间转换为 <code>UTC+8</code> 和 <code>UTC-2</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> chrono::&#123;DateTime, FixedOffset, Local, Utc&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">local_time</span> = Local::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">utc_time</span> = DateTime::&lt;Utc&gt;::<span class="title function_ invoke__">from_utc</span>(local_time.<span class="title function_ invoke__">naive_utc</span>(), Utc);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">china_timezone</span> = FixedOffset::<span class="title function_ invoke__">east_opt</span>(<span class="number">8</span> * <span class="number">3600</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rio_timezone</span> = FixedOffset::<span class="title function_ invoke__">west_opt</span>(<span class="number">2</span> * <span class="number">3600</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;现在当地时间是 &#123;&#125;&quot;</span>, local_time);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;UTC 时间现在是&#123;&#125;&quot;</span>, utc_time);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;现在香港时间是 &#123;&#125;&quot;</span>, utc_time.<span class="title function_ invoke__">with_timezone</span>(&amp;china_timezone));</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;现在里约热内卢时间是 &#123;&#125;&quot;</span>,</span><br><span class="line">        utc_time.<span class="title function_ invoke__">with_timezone</span>(&amp;rio_timezone)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">现在当地时间是 2023-04-16 13:31:33.619954917 +00:00</span><br><span class="line">UTC 时间现在是2023-04-16 13:31:33.619954917 UTC</span><br><span class="line">现在香港时间是 2023-04-16 21:31:33.619954917 +08:00</span><br><span class="line">现在里约热内卢时间是 2023-04-16 11:31:33.619954917 -02:00</span><br></pre></td></tr></table></figure><h2 id="2-解析与显示">2. 解析与显示</h2><h3 id="2-1-检查日期和时间">2.1 检查日期和时间</h3><p>  通过 <code>Timelike</code> 获取当前 <code>UTC DateTime</code> 及其时/分/秒，通过 <code>Datelike</code> 获取其年/月/日/工作日。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> chrono::&#123;Datelike, Timelike, Utc&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">now</span> = Utc::<span class="title function_ invoke__">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (is_pm, hour) = now.<span class="title function_ invoke__">hour12</span>();</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;当前的 UTC 时间是 &#123;:02&#125;:&#123;:02&#125;:&#123;:02&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">        hour,</span><br><span class="line">        now.<span class="title function_ invoke__">minute</span>(),</span><br><span class="line">        now.<span class="title function_ invoke__">second</span>(),</span><br><span class="line">        <span class="keyword">if</span> is_pm &#123; <span class="string">&quot;下午&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;上午&quot;</span> &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;自午夜以来已有 &#123;&#125; 秒&quot;</span>, now.<span class="title function_ invoke__">num_seconds_from_midnight</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (is_common_era, year) = now.<span class="title function_ invoke__">year_ce</span>();</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;当前的 UTC 时间是 &#123;&#125;-&#123;:02&#125;-&#123;:02&#125; &#123;:?&#125; (&#123;&#125;)&quot;</span>,</span><br><span class="line">        year,</span><br><span class="line">        now.<span class="title function_ invoke__">month</span>(),</span><br><span class="line">        now.<span class="title function_ invoke__">day</span>(),</span><br><span class="line">        now.<span class="title function_ invoke__">weekday</span>(),</span><br><span class="line">        <span class="keyword">if</span> is_common_era &#123; <span class="string">&quot;AD&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;BC&quot;</span> &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;公元于 &#123;&#125; 天前开始&quot;</span>, now.<span class="title function_ invoke__">num_days_from_ce</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">当前的 UTC 时间是 01:39:35 下午</span><br><span class="line">自午夜以来已有 49175 秒</span><br><span class="line">当前的 UTC 时间是 2023-04-16 Sun (AD)</span><br><span class="line">公元于 738626 天前开始</span><br></pre></td></tr></table></figure><h3 id="2-2-日期和-UNIX-时间戳的互相转换">2.2 日期和 <code>UNIX</code> 时间戳的互相转换</h3><p>  使用 <code>NaiveDateTime::timestamp</code> 将由<code>NaiveDate::from_ymd</code> 生成的日期和由 <code>NaiveTime::from_hms</code> 生成的时间转换为 <code>UNIX</code> 时间戳。然后，它使用 <code>NaiveDateTime::from_timestamp</code> 计算自 <code>UTC</code> 时间 <strong>1970 年 01 月 01 日 00:00:00</strong> 开始的 <strong>20</strong> 亿秒后的日期。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> chrono::&#123;NaiveDate, NaiveDateTime&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">date_time</span>: NaiveDateTime = NaiveDate::<span class="title function_ invoke__">from_ymd_opt</span>(<span class="number">2023</span>, <span class="number">04</span>, <span class="number">16</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">and_hms_opt</span>(<span class="number">17</span>, <span class="number">33</span>, <span class="number">44</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;1970-01-01 00:00:00 和 &#123;&#125; 之间的秒数是 &#123;&#125;.&quot;</span>,</span><br><span class="line">        date_time,</span><br><span class="line">        date_time.<span class="title function_ invoke__">timestamp</span>()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">date_time_after_a_billion_seconds</span> =</span><br><span class="line">        NaiveDateTime::<span class="title function_ invoke__">from_timestamp_opt</span>(<span class="number">20_0000_0000</span>, <span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;二十亿秒后的日期从 1970-01-01 00:00:00 是 &#123;&#125;.&quot;</span>,</span><br><span class="line">        date_time_after_a_billion_seconds</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1970-01-01 00:00:00 和 2023-04-16 17:33:44 之间的秒数是 1681666424.</span><br><span class="line">十亿秒后的日期从 1970-01-01 00:00:00 是 2033-05-18 03:33:20.</span><br></pre></td></tr></table></figure><h3 id="2-3-日期和时间的格式化显示">2.3 日期和时间的格式化显示</h3><p>  使用 <code>Utc::now</code> 获取并显示当前 <code>UTC</code> 时间。使用 <code>DateTime::to_rfc2822</code> 将当前时间格式化为熟悉的 <code>RFC 2822</code> 格式，使用 <code>DateTime::to_rfc3339</code> 将当前时间格式化为熟悉的 <code>RFC 3339</code> 格式，也可以使用 <code>DateTime::format</code>自定义时间格式。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> chrono::&#123;DateTime, Utc&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">now</span>: DateTime&lt;Utc&gt; = Utc::<span class="title function_ invoke__">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;UTC 现在是: &#123;&#125;&quot;</span>, now);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;现在在 RFC 2822 中的 UTC 是: &#123;&#125;&quot;</span>, now.<span class="title function_ invoke__">to_rfc2822</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;现在在 RFC 3339 中的 UTC 是: &#123;&#125;&quot;</span>, now.<span class="title function_ invoke__">to_rfc3339</span>());</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;现在采用自定义格式的 UTC 是: &#123;&#125;&quot;</span>,</span><br><span class="line">        now.<span class="title function_ invoke__">format</span>(<span class="string">&quot;%Y:%m:%d %H:%M:%S&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UTC 现在是: 2023-04-16 13:52:53.430260493 UTC</span><br><span class="line">现在在 RFC 2822 中的 UTC 是: Sun, 16 Apr 2023 13:52:53 +0000</span><br><span class="line">现在在 RFC 3339 中的 UTC 是: 2023-04-16T13:52:53.430260493+00:00</span><br><span class="line">现在采用自定义格式的 UTC 是: 2023:04:16 13:52:53</span><br></pre></td></tr></table></figure><h3 id="2-4-将字符串解析为-DateTime-结构体">2.4 将字符串解析为 DateTime 结构体</h3><p>  时间格式 <code>RFC 2822</code>、<code>RFC 3339</code>，以及自定义时间格式，通常用字符串表达。要将这些字符串解析为 <code>DateTime</code> 结构体，可以分别用 <code>DateTime::parse_from_rfc2822</code>、<code>DateTime::parse_from_rfc3339</code>，以及 <code>DateTime::parse_from_str</code>。可以在 <code>chrono::format::strftime</code> 中找到适用于 <code>DateTime::parse_from_str</code> 的转义序列。注意：<code>DateTime::parse_from_str</code> 要求这些 <code>DateTime</code> 结构体必须是可创建的，以便它唯一地标识日期和时间。要解析不带时区的日期和时间，请使用 <code>NaiveDate</code>、<code>NaiveTime</code>，以及 <code>NaiveDateTime</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> chrono::format::ParseError;</span><br><span class="line"><span class="keyword">use</span> chrono::&#123;DateTime, NaiveDate, NaiveDateTime, NaiveTime&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), ParseError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rfc2822</span> = DateTime::<span class="title function_ invoke__">parse_from_rfc2822</span>(<span class="string">&quot;Wed, 18 Feb 2015 23:16:09 GMT&quot;</span>).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">//部分无法解析</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rfc2822);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rfc3339</span> = DateTime::<span class="title function_ invoke__">parse_from_rfc3339</span>(<span class="string">&quot;1896-12-19T16:39:57-08:00&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rfc3339);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">custom</span> =</span><br><span class="line">        DateTime::<span class="title function_ invoke__">parse_from_str</span>(<span class="string">&quot;5.8.2022 8:00 am +0000&quot;</span>, <span class="string">&quot;%d.%m.%Y %H:%M %P %z&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, custom);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">time_only</span> = NaiveTime::<span class="title function_ invoke__">parse_from_str</span>(<span class="string">&quot;23:56:04&quot;</span>, <span class="string">&quot;%H:%M:%S&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, time_only);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">date_only</span> = NaiveDate::<span class="title function_ invoke__">parse_from_str</span>(<span class="string">&quot;2023-09-05&quot;</span>, <span class="string">&quot;%Y-%m-%d&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, date_only);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">no_timezone</span> =</span><br><span class="line">        NaiveDateTime::<span class="title function_ invoke__">parse_from_str</span>(<span class="string">&quot;2022-12-05 23:56:04&quot;</span>, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, no_timezone);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2015-02-18 23:16:09 +00:00</span><br><span class="line">1896-12-19 16:39:57 -08:00</span><br><span class="line">2022-08-05 08:00:00 +00:00</span><br><span class="line">23:56:04</span><br><span class="line">2023-09-05</span><br><span class="line">2022-12-05 23:56:04</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】七 数据库</title>
      <link href="/news/1681570373600.html"/>
      <url>/news/1681570373600.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-SQLite">1. SQLite</h2><p>  需要安装<code>rusqlite</code>库，可通过<code>cargo add rusqlite --features bundled</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rusqlite</span> = &#123; version = <span class="string">&quot;0.29.0&quot;</span>, features = [<span class="string">&quot;bundled&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-创建-SQLite-数据库">1.1 创建 SQLite 数据库</h3><p>  使用<code>rusqlite</code> <code>crate</code> 打开 <code>SQLite</code> 数据库连接。如果数据库不存在，<code>Connection::open</code>方法将创建它。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use rusqlite::NO_PARAMS; 已弃用：改用空数组;stmt.execute（NO_PARAMS） =&gt; stmt.execute（[]）</span></span><br><span class="line"><span class="keyword">use</span> rusqlite::&#123;Connection, <span class="type">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">conn</span> = Connection::<span class="title function_ invoke__">open</span>(<span class="string">&quot;cats.db&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    conn.<span class="title function_ invoke__">execute</span>(</span><br><span class="line">        <span class="string">&quot;create table if not exists cat_colors (</span></span><br><span class="line"><span class="string">             id integer primary key,</span></span><br><span class="line"><span class="string">             name text not null unique</span></span><br><span class="line"><span class="string">         )&quot;</span>,</span><br><span class="line">        [],</span><br><span class="line">    )?;</span><br><span class="line">    conn.<span class="title function_ invoke__">execute</span>(</span><br><span class="line">        <span class="string">&quot;create table if not exists cats (</span></span><br><span class="line"><span class="string">             id integer primary key,</span></span><br><span class="line"><span class="string">             name text not null,</span></span><br><span class="line"><span class="string">             color_id integer not null references cat_colors(id)</span></span><br><span class="line"><span class="string">         )&quot;</span>,</span><br><span class="line">        [],</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>生成cats.db文件</li></ul><h3 id="1-2-数据插入和查询">1.2 数据插入和查询</h3><p>  <code>Connection::open</code> 将打开在前一章节实例中创建的数据库 <code>cats</code> 的连接。下面的实例使用 <code>Connection</code> 的 <code>execute</code> 方法将数据插入 <code>cat_colors</code> 和 <code>cats</code> 两张表中。首先，将数据插入到 <code>cat_colors</code> 表中。随后，使用 <code>Connection</code> 的 <code>last_insert_rowid</code> 方法来获取 <code>cat_colors</code> 表最后插入记录的 <code>id</code>。当向 <code>cats</code> 表中插入数据时，使用此 <code>id</code>。然后，使用 <code>prepare</code> 方法准备执行 <code>select</code> 查询操作，该方法提供 <code>statement</code> 结构体。最后，使用 <code>statement</code> 的 <code>query_map</code> 方法执行查询。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rusqlite::&#123;Connection, <span class="type">Result</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    color: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">conn</span> = Connection::<span class="title function_ invoke__">open</span>(<span class="string">&quot;cats.db&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cat_colors</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    cat_colors.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="built_in">vec!</span>[<span class="string">&quot;Tigger&quot;</span>, <span class="string">&quot;Sammy&quot;</span>]);</span><br><span class="line">    cat_colors.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Black&quot;</span>), <span class="built_in">vec!</span>[<span class="string">&quot;Oreo&quot;</span>, <span class="string">&quot;Biscuit&quot;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">for</span> (color, catnames) <span class="keyword">in</span> &amp;cat_colors &#123;</span><br><span class="line">        conn.<span class="title function_ invoke__">execute</span>(</span><br><span class="line">            <span class="string">&quot;INSERT INTO cat_colors (name) values (?1)&quot;</span>,</span><br><span class="line">            &amp;[&amp;color.<span class="title function_ invoke__">to_string</span>()],</span><br><span class="line">        )?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">last_id</span>: <span class="type">String</span> = conn.<span class="title function_ invoke__">last_insert_rowid</span>().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">cat</span> <span class="keyword">in</span> catnames &#123;</span><br><span class="line">            conn.<span class="title function_ invoke__">execute</span>(</span><br><span class="line">                <span class="string">&quot;INSERT INTO cats (name, color_id) values (?1, ?2)&quot;</span>,</span><br><span class="line">                &amp;[&amp;cat.<span class="title function_ invoke__">to_string</span>(), &amp;last_id],</span><br><span class="line">            )?;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stmt</span> = conn.<span class="title function_ invoke__">prepare</span>(</span><br><span class="line">        <span class="string">&quot;SELECT c.name, cc.name from cats c</span></span><br><span class="line"><span class="string">         INNER JOIN cat_colors cc</span></span><br><span class="line"><span class="string">         ON cc.id = c.color_id;&quot;</span>,</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cats</span> = stmt.<span class="title function_ invoke__">query_map</span>([], |row| &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Cat &#123;</span><br><span class="line">            name: row.<span class="title function_ invoke__">get</span>(<span class="number">0</span>)?,</span><br><span class="line">            color: row.<span class="title function_ invoke__">get</span>(<span class="number">1</span>)?,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">cat</span> <span class="keyword">in</span> cats &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;找到猫 &#123;:?&#125;&quot;</span>, cat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">找到猫 Ok(Cat &#123; name: <span class="string">&quot;Oreo&quot;</span>, color: <span class="string">&quot;Black&quot;</span> &#125;)</span><br><span class="line">找到猫 Ok(Cat &#123; name: <span class="string">&quot;Biscuit&quot;</span>, color: <span class="string">&quot;Black&quot;</span> &#125;)</span><br><span class="line">找到猫 Ok(Cat &#123; name: <span class="string">&quot;Tigger&quot;</span>, color: <span class="string">&quot;Blue&quot;</span> &#125;)</span><br><span class="line">找到猫 Ok(Cat &#123; name: <span class="string">&quot;Sammy&quot;</span>, color: <span class="string">&quot;Blue&quot;</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="1-3-事务处理">1.3 事务处理</h3><p>  <code>Connection::open</code> 将打开来自前述实例的数据库 <code>cats.db</code>。使用 <code>Connection::transaction</code> 开始事务，除非使用 <code>Transaction::commit</code> 显式提交，否则事务将回滚。在下面的实例中，颜色表对颜色名称具有唯一性约束。当尝试插入重复的颜色时，事务会回滚。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rusqlite::&#123;Connection, <span class="type">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">conn</span> = Connection::<span class="title function_ invoke__">open</span>(<span class="string">&quot;cats.db&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">successful_tx</span>(&amp;<span class="keyword">mut</span> conn)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">rolled_back_tx</span>(&amp;<span class="keyword">mut</span> conn);</span><br><span class="line">    <span class="built_in">assert!</span>(res.<span class="title function_ invoke__">is_err</span>());</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">successful_tx</span>(conn: &amp;<span class="keyword">mut</span> Connection) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx</span> = conn.<span class="title function_ invoke__">transaction</span>()?;</span><br><span class="line"></span><br><span class="line">    tx.<span class="title function_ invoke__">execute</span>(<span class="string">&quot;delete from cat_colors&quot;</span>, [])?;</span><br><span class="line">    tx.<span class="title function_ invoke__">execute</span>(<span class="string">&quot;insert into cat_colors (name) values (?1)&quot;</span>, &amp;[&amp;<span class="string">&quot;lavender&quot;</span>])?;</span><br><span class="line">    tx.<span class="title function_ invoke__">execute</span>(<span class="string">&quot;insert into cat_colors (name) values (?1)&quot;</span>, &amp;[&amp;<span class="string">&quot;blue&quot;</span>])?;</span><br><span class="line"></span><br><span class="line">    tx.<span class="title function_ invoke__">commit</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">rolled_back_tx</span>(conn: &amp;<span class="keyword">mut</span> Connection) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx</span> = conn.<span class="title function_ invoke__">transaction</span>()?;</span><br><span class="line"></span><br><span class="line">    tx.<span class="title function_ invoke__">execute</span>(<span class="string">&quot;delete from cat_colors&quot;</span>, [])?;</span><br><span class="line">    tx.<span class="title function_ invoke__">execute</span>(<span class="string">&quot;insert into cat_colors (name) values (?1)&quot;</span>, &amp;[&amp;<span class="string">&quot;lavender&quot;</span>])?;</span><br><span class="line">    tx.<span class="title function_ invoke__">execute</span>(<span class="string">&quot;insert into cat_colors (name) values (?1)&quot;</span>, &amp;[&amp;<span class="string">&quot;blue&quot;</span>])?;</span><br><span class="line">    tx.<span class="title function_ invoke__">execute</span>(<span class="string">&quot;insert into cat_colors (name) values (?1)&quot;</span>, &amp;[&amp;<span class="string">&quot;lavender&quot;</span>])?;</span><br><span class="line"></span><br><span class="line">    tx.<span class="title function_ invoke__">commit</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: SqliteFailure(Error &#123; code: ConstraintViolation, extended_code: 787 &#125;, Some(<span class="string">&quot;FOREIGN KEY constraint failed&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="2-Postgres-暂未测试">2. Postgres (暂未测试)</h2><p>  需要安装<code>postgres</code>库，可通过<code>cargo add postgres</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">postgres</span> = <span class="string">&quot;0.19.5&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-1-Postgres-数据库中创建表">2.1 Postgres 数据库中创建表</h3><p>  <code>Postgres</code> 数据库中，使用 <code>postgres</code> <code>crate</code> 创建表。<br><code>Client::connect</code>用于连接到现有数据库。本实例中使用 <code>Client::connect</code> 格式化连接数据库的 URL 字符串。假设存在一个数据库：名为 <code>library</code>，用户名为 <code>postgres</code>，密码为 <code>postgres</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> postgres::&#123;Client, NoTls, Error&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = Client::<span class="title function_ invoke__">connect</span>(<span class="string">&quot;postgresql://postgres:postgres@localhost/library&quot;</span>, NoTls)?;</span><br><span class="line">    <span class="comment">// let mut client = Client::connect(&quot;host=localhost user=postgres&quot;, NoTls)?; //待测，官方连接数据库示例</span></span><br><span class="line">    </span><br><span class="line">    client.<span class="title function_ invoke__">batch_execute</span>(<span class="string">&quot;</span></span><br><span class="line"><span class="string">        CREATE TABLE IF NOT EXISTS author (</span></span><br><span class="line"><span class="string">            id              SERIAL PRIMARY KEY,</span></span><br><span class="line"><span class="string">            name            VARCHAR NOT NULL,</span></span><br><span class="line"><span class="string">            country         VARCHAR NOT NULL</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string">    &quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    client.<span class="title function_ invoke__">batch_execute</span>(<span class="string">&quot;</span></span><br><span class="line"><span class="string">        CREATE TABLE IF NOT EXISTS book  (</span></span><br><span class="line"><span class="string">            id              SERIAL PRIMARY KEY,</span></span><br><span class="line"><span class="string">            title           VARCHAR NOT NULL,</span></span><br><span class="line"><span class="string">            author_id       INTEGER NOT NULL REFERENCES author</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string">    &quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-数据插入和查询">2.2 数据插入和查询</h3><p>  下述实例中使用 <code>Client</code> 的 <code>execute</code> 方法将数据插入到 <code>author</code> 表中。然后，使用 <code>Client</code> 的 <code>query</code> 方法查询 <code>author</code> 表中的数据。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> postgres::&#123;Client, NoTls, Error&#125;;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">    _id: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    country: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = Client::<span class="title function_ invoke__">connect</span>(<span class="string">&quot;postgresql://postgres:postgres@localhost/library&quot;</span>, </span><br><span class="line">                                    NoTls)?;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">authors</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    authors.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Chinua Achebe&quot;</span>), <span class="string">&quot;Nigeria&quot;</span>);</span><br><span class="line">    authors.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rabindranath Tagore&quot;</span>), <span class="string">&quot;India&quot;</span>);</span><br><span class="line">    authors.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Anita Nair&quot;</span>), <span class="string">&quot;India&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">for</span> (key, value) <span class="keyword">in</span> &amp;authors &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">author</span> = Author &#123;</span><br><span class="line">            _id: <span class="number">0</span>,</span><br><span class="line">            name: key.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            country: value.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        client.<span class="title function_ invoke__">execute</span>(</span><br><span class="line">                <span class="string">&quot;INSERT INTO author (name, country) VALUES ($1, $2)&quot;</span>,</span><br><span class="line">                &amp;[&amp;author.name, &amp;author.country],</span><br><span class="line">        )?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> client.<span class="title function_ invoke__">query</span>(<span class="string">&quot;SELECT id, name, country FROM author&quot;</span>, &amp;[])? &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">author</span> = Author &#123;</span><br><span class="line">            _id: row.<span class="title function_ invoke__">get</span>(<span class="number">0</span>),</span><br><span class="line">            name: row.<span class="title function_ invoke__">get</span>(<span class="number">1</span>),</span><br><span class="line">            country: row.<span class="title function_ invoke__">get</span>(<span class="number">2</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Author &#123;&#125; is from &#123;&#125;&quot;</span>, author.name, author.country);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-数据聚合">2.3 数据聚合</h3><p>  下述实例按照降序列出了<a href="https://github.com/MuseumofModernArt/collection/blob/master/Artists.csv">美国纽约州现代艺术博物馆</a>数据库中首批 7999 位艺术家的国籍。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> postgres::&#123;Client, Error, NoTls&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Nation</span> &#123;</span><br><span class="line">    nationality: <span class="type">String</span>,</span><br><span class="line">    count: <span class="type">i64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = Client::<span class="title function_ invoke__">connect</span>(</span><br><span class="line">        <span class="string">&quot;postgresql://postgres:postgres@127.0.0.1/moma&quot;</span>,</span><br><span class="line">        NoTls,</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> client.<span class="title function_ invoke__">query</span> </span><br><span class="line">    (<span class="string">&quot;SELECT nationality, COUNT(nationality) AS count </span></span><br><span class="line"><span class="string">    FROM artists GROUP BY nationality ORDER BY count DESC&quot;</span>, &amp;[])? &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> (nationality, count) : (<span class="type">Option</span>&lt;<span class="type">String</span>&gt;, <span class="type">Option</span>&lt;<span class="type">i64</span>&gt;) </span><br><span class="line">        = (row.<span class="title function_ invoke__">get</span> (<span class="number">0</span>), row.<span class="title function_ invoke__">get</span> (<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nationality.<span class="title function_ invoke__">is_some</span> () &amp;&amp; count.<span class="title function_ invoke__">is_some</span> () &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">nation</span> = Nation&#123;</span><br><span class="line">                nationality: nationality.<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">                count: count.<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, nation.nationality, nation.count);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】六 数据结构</title>
      <link href="/news/1681480076711.html"/>
      <url>/news/1681480076711.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-位域">1. 位域</h2><h3 id="1-1-定义并操作位域风格的类型">1.1 定义并操作位域风格的类型</h3><p>  需要安装<code>bitflags</code>库，可通过<code>cargo add bitflags</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">bitflags</span> = <span class="string">&quot;2.1.0&quot;</span></span><br></pre></td></tr></table></figure><p>  如下实例在 <code>bitflags!</code> 宏的帮助下创建类型安全的位域类型 <code>MyFlags</code>，并为其实现基本的清理操作（<code>clear</code> 方法）以及 <code>Display trait</code>。随后，展示了基本的按位操作和格式化。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> bitflags::bitflags;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 MyFlags 枚举类型，表示一个 32 位二进制标志位</span></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="meta">#[derive(Clone, Copy, PartialEq, Eq, Debug )]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyFlags</span>: <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> FLAG_A       = <span class="number">0b00000001</span>; <span class="comment">// 第一位标志位表示 FLAG_A</span></span><br><span class="line">        <span class="keyword">const</span> FLAG_B       = <span class="number">0b00000010</span>; <span class="comment">// 第二位标志位表示 FLAG_B</span></span><br><span class="line">        <span class="keyword">const</span> FLAG_C       = <span class="number">0b00000100</span>; <span class="comment">// 第三位标志位表示 FLAG_C</span></span><br><span class="line">        <span class="keyword">const</span> FLAG_ABC     = <span class="keyword">Self</span>::FLAG_A.<span class="title function_ invoke__">bits</span>() <span class="comment">// FLAG_ABC 表示 FLAG_A、FLAG_B 和 FLAG_C 的集合</span></span><br><span class="line">                           | <span class="keyword">Self</span>::FLAG_B.<span class="title function_ invoke__">bits</span>()</span><br><span class="line">                           | <span class="keyword">Self</span>::FLAG_C.<span class="title function_ invoke__">bits</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyFlags</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 clear 方法，清空标志位</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">clear</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> MyFlags &#123;</span><br><span class="line">        *<span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">bits_mut</span>() = <span class="number">0</span>; <span class="comment">// 将 MyFlags 对应的 u32 类型全部置为 0</span></span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> <span class="title class_">MyFlags</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 fmt::Display trait，使得 MyFlags 类型可以被格式化输出</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;:032b&#125;&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">bits</span>()) <span class="comment">// 将 MyFlags 转换为 32 位二进制数输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 枚举类型可以像整数一样进行按位运算</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e1</span> = MyFlags::FLAG_A | MyFlags::FLAG_C; <span class="comment">// e1 包含 FLAG_A 和 FLAG_C</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e2</span> = MyFlags::FLAG_B | MyFlags::FLAG_C; <span class="comment">// e2 包含 FLAG_B 和 FLAG_C</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>((e1 | e2), MyFlags::FLAG_ABC); <span class="comment">// e1 和 e2 的并集包含 FLAG_ABC</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>((e1 &amp; e2), MyFlags::FLAG_C); <span class="comment">// e1 和 e2 的交集包含 FLAG_C</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>((e1 - e2), MyFlags::FLAG_A); <span class="comment">// e1 减去 e2 的差集包含 FLAG_A</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(!e2, MyFlags::FLAG_A); <span class="comment">// e2 的补集不包含 FLAG_A</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">flags</span> = MyFlags::FLAG_ABC;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, flags), <span class="string">&quot;00000000000000000000000000000111&quot;</span>); <span class="comment">// 输出 MyFlags 为 32 位二进制数</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, flags.<span class="title function_ invoke__">clear</span>()),</span><br><span class="line">        <span class="string">&quot;00000000000000000000000000000000&quot;</span> <span class="comment">// 清空 MyFlags，输出 0</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, MyFlags::FLAG_B), <span class="string">&quot;MyFlags(FLAG_B)&quot;</span>); <span class="comment">// 输出 MyFlags 枚举类型</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, MyFlags::FLAG_A | MyFlags::FLAG_B),</span><br><span class="line">        <span class="string">&quot;MyFlags(FLAG_A | FLAG_B)&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验成功</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【如何百科】Ubuntu离线安装MiniKube</title>
      <link href="/news/1681466985497.html"/>
      <url>/news/1681466985497.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-工具包准备">1. 工具包准备</h2><p>  安装机器架构 Ubuntu16.04 AMD64<br>  docker的安装过程详见文章：<a href="https://www.taissan.com/news/1678175207403.html">【如何百科】Ubuntu 安装最新 docker</a></p><h3 id="1-1-Minekube-下载">1.1 Minekube 下载</h3><ul><li>官方二进制下载地址<a href="https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64/">下载链接</a></li><li>官方 Deb 包下载地址<a href="https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb/">下载链接</a></li><li>官方 RPM 包下载地址<a href="https://storage.googleapis.com/minikube/releases/latest/minikube-latest.x86_64.rpm/">下载链接</a></li></ul><h3 id="1-2-helm-下载">1.2 helm 下载</h3><ul><li>官方二进制包下载地址<a href="https://get.helm.sh/helm-v3.11.3-linux-amd64.tar.gz">下载链接</a></li><li>官方 Deb 包下载地址<a href="https://helm.baltorepo.com/stable/debian/packages/helm/releases/3.11.2-1/files/helm_3.11.2-1_amd64.deb/">下载链接</a></li></ul><h3 id="1-3-kubernetes-相关命令工具下载-至少需要下载以下三个工具">1.3 kubernetes 相关命令工具下载,至少需要下载以下三个工具</h3><p>  本文以 v1.26.3 版本为主。<a href="https://www.downloadkubernetes.com/">下载地址</a></p><ul><li>kubectl</li><li>kubelet</li><li>kubeadm</li></ul><h2 id="2-minikube-镜像准备">2. minikube 镜像准备</h2><h3 id="2-1-下载-minikube-必需的-9-个镜像">2.1 下载 minikube 必需的 9 个镜像</h3><ul><li><code>gcr.io/k8s-minikube/kicbase:v0.0.39</code></li><li><code>gcr.io/k8s-minikube/storage-provisioner:v5</code></li><li><code>registry.k8s.io/kube-apiserver:v1.26.3</code></li><li><code>registry.k8s.io/kube-controller-manager:v1.26.3</code></li><li><code>registry.k8s.io/kube-scheduler:v1.26.3</code></li><li><code>registry.k8s.io/kube-proxy:v1.26.3</code></li><li><code>registry.k8s.io/etcd:3.5.6-0</code></li><li><code>registry.k8s.io/pause:3.9</code></li><li><code>registry.k8s.io/coredns/coredns:v1.9.3</code></li></ul><h3 id="2-2-部署-minikube-dashboard-的-2-个镜像-可选">2.2 部署 minikube dashboard 的 2 个镜像(可选)</h3><ul><li><code>kubernetesui/dashboard:v2.7.0</code></li><li><code>kubernetesui/metrics-scraper:v1.0.8</code></li></ul><h3 id="2-3-镜像下载方法">2.3 镜像下载方法</h3><ul><li>(1). 通过 WSL 的 <code>docker pull</code> 命令下载并导出为 tar 包</li><li>(2). 通过 python 脚本下载 tar 包(仅支持 docker v2 清单的镜像)，脚本参考：<a href="https://github.com/NotGlop/docker-drag">https://github.com/NotGlop/docker-drag</a></li></ul><h2 id="3-minikube-部署">3. minikube 部署</h2><ul><li>将之前下载的所有镜像 tar 包及工具包上传到主机上</li></ul><h3 id="3-1-安装所有镜像">3.1 安装所有镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i *.tar</span><br></pre></td></tr></table></figure><h3 id="3-2-安装所需工具-root-权限">3.2 安装所需工具(root 权限)</h3><ul><li>安装 minikube(deb 包)</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i minikube_latest_amd64.deb</span><br></pre></td></tr></table></figure><ul><li>安装 helm(deb 包)</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i helm_3.11.2-1_amd64.deb</span><br></pre></td></tr></table></figure><ul><li>安装 kubectl(二进制)</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl</span><br></pre></td></tr></table></figure><h3 id="3-3-为-minikube-新建用户">3.3 为 minikube 新建用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个minikube用户</span></span><br><span class="line">adduser minikube</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个docker用户组</span></span><br><span class="line">groupadd docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将minikube添加到docker组</span></span><br><span class="line">usermod -aG docker minikube</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前用户添加到该docker组(root)</span></span><br><span class="line">usermod -aG docker <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h3 id="3-4-使用-minikube-用户启动-minikube。需要重启-2-次">3.4 使用 minikube 用户启动 minikube。需要重启 2 次</h3><ul><li>第一次启动时，会在用户目录下创建一个<code>.minikube/cache/linux/amd64/v1.26.3</code>的目录,但由于检测不到<code>kubectl</code>等工具，故会以失败告终。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">minikube start</span><br></pre></td></tr></table></figure><ul><li>将之前下载的 3 个命令工具(<code>kubectl,kubelet,kubeadm</code>) 拷贝到用户目录的 <code>.minikube/cache/linux/amd64/v1.26.3</code> 目录下</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> tools/* .minikube/cache/linux/amd64/v1.26.3/</span><br></pre></td></tr></table></figure><ul><li>执行第二次启动</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">minikube start</span><br></pre></td></tr></table></figure><ul><li>待系统输出以下内容则说明 minikube 安装完成</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Done! kubectl is now configured to use <span class="string">&quot;minikube&quot;</span> cluster and <span class="string">&quot;default&quot;</span> namespace by default</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 万法天书 </category>
          
          <category> 如何百科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> minikube </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】五 密码学</title>
      <link href="/news/1681401209555.html"/>
      <url>/news/1681401209555.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-散列（哈希）">1. 散列（哈希）</h2><h3 id="1-1-计算文件的-SHA-256-摘要">1.1 计算文件的 SHA-256 摘要</h3><p>  需要安装<code>ring</code>,<code>data-encoding</code>,<code>error-chain</code> 库，可通过<code>cargo add ring</code>,<code>cargo add data-encoding</code> ,<code>cargo add error-chain</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">data-encoding</span> = <span class="string">&quot;2.3.3&quot;</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br><span class="line"><span class="attr">ring</span> = <span class="string">&quot;0.16.20&quot;</span></span><br></pre></td></tr></table></figure><p>  以下实例中，先创建文件，写入一些数据。然后使用 <code>digest::Context</code> 计算文件内容的 <code>SHA-256</code> 摘要 <code>digest::Digest</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> data_encoding::HEXUPPER;</span><br><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> ring::digest::&#123;Context, Digest, SHA256&#125;;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;BufReader, Read, Write&#125;;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">Decode</span>(data_encoding::DecodeError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sha256_digest</span>&lt;R: Read&gt;(<span class="keyword">mut</span> reader: R) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Digest&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">context</span> = Context::<span class="title function_ invoke__">new</span>(&amp;SHA256);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">count</span> = reader.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer)?;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        context.<span class="title function_ invoke__">update</span>(&amp;buffer[..count]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(context.<span class="title function_ invoke__">finish</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = <span class="string">&quot;file.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">output</span> = File::<span class="title function_ invoke__">create</span>(path)?;</span><br><span class="line">    <span class="built_in">write!</span>(output, <span class="string">&quot;我们将生成此文本的摘要&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span> = File::<span class="title function_ invoke__">open</span>(path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reader</span> = BufReader::<span class="title function_ invoke__">new</span>(input);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">digest</span> = <span class="title function_ invoke__">sha256_digest</span>(reader)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;SHA-256 摘要是 &#123;&#125;&quot;</span>, HEXUPPER.<span class="title function_ invoke__">encode</span>(digest.<span class="title function_ invoke__">as_ref</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出结果如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SHA-256 摘要是 765E79C9E2677BCA5A050906AF635703BAC1A725EC63701285A907A263182EC2</span><br></pre></td></tr></table></figure><h3 id="1-2-使用-HMAC-摘要对消息进行签名和验证">1.2. 使用 HMAC 摘要对消息进行签名和验证</h3><p>  使用 <code>ring::hmac</code> 创建字符串的签名 <code>hmac::Signature</code>，然后验证签名是否正确。HMAC运算利用hash算法，以一个消息M和一个密钥K作为输入，生成一个定长的消息摘要作为输出。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ring::error::Unspecified;</span><br><span class="line"><span class="keyword">use</span> ring::rand::SecureRandom;</span><br><span class="line"><span class="keyword">use</span> ring::&#123;hmac, rand&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Unspecified&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">key_value</span> = [<span class="number">0u8</span>; <span class="number">48</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rng</span> = rand::SystemRandom::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    rng.<span class="title function_ invoke__">fill</span>(&amp;<span class="keyword">mut</span> key_value)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">key</span> = hmac::Key::<span class="title function_ invoke__">new</span>(hmac::HMAC_SHA256, &amp;key_value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="string">&quot;合法而非常重要的信息。&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">signature</span> = hmac::<span class="title function_ invoke__">sign</span>(&amp;key, message.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">    hmac::<span class="title function_ invoke__">verify</span>(&amp;key, message.<span class="title function_ invoke__">as_bytes</span>(), signature.<span class="title function_ invoke__">as_ref</span>())?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>验证.</li></ul><h2 id="2-加密">2. 加密</h2><h3 id="2-1-使用-PBKDF2-对密码进行加密（salt）和散列（hash）运算">2.1 使用 <code>PBKDF2</code> 对密码进行加密（<code>salt</code>）和散列（<code>hash</code>）运算</h3><p>  对于通过 <code>PBKDF2</code> 密钥派生函数 <code>pbkdf2::derive</code> 生成的加密（加盐算法）密码，使用 <code>ring::pbkdf2</code> 进行散列（哈希）运算，使用 <code>pbkdf2::verify</code> 验证散列（哈希）运算是否正确。<code>salt</code> 值是使用 <code>SecureRandom::fill</code> 生成的，<code>salt</code> 字节数组被其安全生成的随机数填充。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入需要用到的库</span></span><br><span class="line"><span class="keyword">use</span> data_encoding::HEXUPPER; <span class="comment">// HEXUPPER 数据编码库</span></span><br><span class="line"><span class="keyword">use</span> ring::error::Unspecified; <span class="comment">// Ring 库中的错误类型 Unspecified</span></span><br><span class="line"><span class="keyword">use</span> ring::rand::SecureRandom; <span class="comment">// 一个安全的随机数生成器</span></span><br><span class="line"><span class="keyword">use</span> ring::&#123;digest, pbkdf2, rand&#125;; <span class="comment">// Ring 库中的摘要、PBKDF2 和随机数模块</span></span><br><span class="line"><span class="keyword">use</span> std::num::NonZeroU32; <span class="comment">// 非零的 u32 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Unspecified&gt; &#123;</span><br><span class="line">    <span class="comment">// 定义常量 CREDENTIAL_LEN，并赋值为 SHA512 输出的长度</span></span><br><span class="line">    <span class="keyword">const</span> CREDENTIAL_LEN: <span class="type">usize</span> = digest::SHA512_OUTPUT_LEN;</span><br><span class="line">    <span class="comment">// 定义 NonZeroU32 类型变量 n_iter，赋值为 100000</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n_iter</span> = NonZeroU32::<span class="title function_ invoke__">new</span>(<span class="number">100_000</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// 创建系统随机数生成器 rng</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rng</span> = rand::SystemRandom::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="comment">// 定义长度为 CREDENTIAL_LEN 的数组 salt，并用随机数生成器 rng 填充</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">salt</span> = [<span class="number">0u8</span>; CREDENTIAL_LEN];</span><br><span class="line">    rng.<span class="title function_ invoke__">fill</span>(&amp;<span class="keyword">mut</span> salt)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义字符串变量 password，并赋值为 &quot;Guess Me If You Can!&quot;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">password</span> = <span class="string">&quot;Guess Me If You Can!&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义长度为 CREDENTIAL_LEN 的数组 pbkdf2_hash，并使用 PBKDF2 算法和 salt 以及 password 的字节数组填充该数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">pbkdf2_hash</span> = [<span class="number">0u8</span>; CREDENTIAL_LEN];</span><br><span class="line">    pbkdf2::<span class="title function_ invoke__">derive</span>(</span><br><span class="line">        pbkdf2::PBKDF2_HMAC_SHA512, <span class="comment">// 使用 HMAC-SHA512 算法</span></span><br><span class="line">        n_iter,</span><br><span class="line">        &amp;salt,</span><br><span class="line">        password.<span class="title function_ invoke__">as_bytes</span>(),</span><br><span class="line">        &amp;<span class="keyword">mut</span> pbkdf2_hash,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 打印 salt 和 pbkdf2_hash 的十六进制编码</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Salt: &#123;&#125;&quot;</span>, HEXUPPER.<span class="title function_ invoke__">encode</span>(&amp;salt));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;PBKDF2 hash: &#123;&#125;&quot;</span>, HEXUPPER.<span class="title function_ invoke__">encode</span>(&amp;pbkdf2_hash));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 PBKDF2 算法、salt 和 password 的字节数组验证 pbkdf2_hash 是否正确</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">should_succeed</span> = pbkdf2::<span class="title function_ invoke__">verify</span>(</span><br><span class="line">        pbkdf2::PBKDF2_HMAC_SHA512, <span class="comment">// 使用 HMAC-SHA512 算法</span></span><br><span class="line">        n_iter,</span><br><span class="line">        &amp;salt,</span><br><span class="line">        password.<span class="title function_ invoke__">as_bytes</span>(),</span><br><span class="line">        &amp;pbkdf2_hash,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 定义字符串变量 wrong_password，并赋值为 &quot;Definitely not the correct password&quot;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">wrong_password</span> = <span class="string">&quot;Definitely not the correct password&quot;</span>;</span><br><span class="line">    <span class="comment">// 使用 PBKDF2 算法、salt 和 wrong_password 的字节数组验证 pbkdf2_hash 是否正确</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">should_fail</span> = pbkdf2::<span class="title function_ invoke__">verify</span>(</span><br><span class="line">        pbkdf2::PBKDF2_HMAC_SHA512, <span class="comment">// 使用 HMAC-SHA512 算法</span></span><br><span class="line">        n_iter,</span><br><span class="line">        &amp;salt,</span><br><span class="line">        wrong_password.<span class="title function_ invoke__">as_bytes</span>(),</span><br><span class="line">        &amp;pbkdf2_hash,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 assert! 宏判断 should_succeed 是否成功</span></span><br><span class="line">    <span class="built_in">assert!</span>(should_succeed.<span class="title function_ invoke__">is_ok</span>());</span><br><span class="line">    <span class="comment">// 使用 assert! 宏判断 should_fail 是否失败</span></span><br><span class="line">    <span class="built_in">assert!</span>(!should_fail.<span class="title function_ invoke__">is_ok</span>());</span><br><span class="line">    <span class="comment">// 如果程序没有发生错误</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出结果如下，没有报错，说明验证成功：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Salt: CDC7242F11C2AEF4F5091F88CDD63C2D07871ACA0B13A8E9AB458DFF9F2BC7B441F5F250A9C81FB4E006286E08504F0AD7698AF8EC8F03D58AB99706051D1BAE</span><br><span class="line">PBKDF2 <span class="built_in">hash</span>: 6F547321949A89DA4A91BAD3FB1E5ACE48D0CAA57453221A82BD6CA4EA0E840FEFF2756070CB81978EBC9AFAB6017B050BF8A1D4909888470BCFA31494FBEE30</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】四 并行/并发</title>
      <link href="/news/1680865445147.html"/>
      <url>/news/1680865445147.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-显式线程">1. 显式线程</h2><h3 id="1-1-生成短期线程">1.1 生成短期线程</h3><p>  需要安装<code>crossbeam</code>库，可通过<code>cargo add crossbeam</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">crossbeam</span> = <span class="string">&quot;0.8.2&quot;</span></span><br></pre></td></tr></table></figure><p>  使用 <code>crossbeam</code> crate 为并发和并行编程提供了数据结构和函数。<code>Scope::spawn</code> 生成一个新的作用域线程，该线程确保传入 <code>crossbeam::scope</code> 函数的闭包在返回之前终止，这意味着您可以从调用的函数中引用数据。</p><ul><li>本实例将数组一分为二，并在不同的线程中并行计算。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> crossbeam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = &amp;[<span class="number">1</span>, <span class="number">25</span>, -<span class="number">4</span>, <span class="number">10</span>, <span class="number">36</span>, <span class="number">88</span>, -<span class="number">99</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">max</span> = <span class="title function_ invoke__">find_max</span>(arr);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(max, <span class="title function_ invoke__">Some</span>(<span class="number">88</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_max</span>(arr: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> THRESHOLD: <span class="type">usize</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> arr.<span class="title function_ invoke__">len</span>() &lt;= THRESHOLD &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">max</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mid</span> = arr.<span class="title function_ invoke__">len</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> (left, right) = arr.<span class="title function_ invoke__">split_at</span>(mid);</span><br><span class="line"></span><br><span class="line">    crossbeam::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread_l</span> = s.<span class="title function_ invoke__">spawn</span>(|_| <span class="title function_ invoke__">find_max</span>(left));</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread_r</span> = s.<span class="title function_ invoke__">spawn</span>(|_| <span class="title function_ invoke__">find_max</span>(right));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">max_l</span> = thread_l.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>()?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">max_r</span> = thread_r.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>()?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(max_l.<span class="title function_ invoke__">max</span>(max_r))</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>校验</li></ul><h3 id="1-2-创建并发的数据管道">1.2. 创建并发的数据管道</h3><p>  在章节1.1基础上再次安装<code>crossbeam-channel</code>库，可通过<code>cargo add crossbeam-channel</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">crossbeam</span> = <span class="string">&quot;0.8.2&quot;</span></span><br><span class="line"><span class="attr">crossbeam-channel</span> = <span class="string">&quot;0.5.7&quot;</span></span><br></pre></td></tr></table></figure><p>  使用 <code>crossbeam</code> 和 <code>crossbeam-channel</code> 两个 crate 创建了一个并行的管道。管道有一个数据源和一个数据接收器，数据在从源到接收器的过程中由两个工作线程并行处理。<br>  使用容量由 <code>crossbeam_channel::bounded</code> 分配的有界信道。生产者必须在它自己的线程上，因为它产生的消息比工作线程处理它们的速度快（因为工作线程休眠了半秒）——这意味着生产者将在对 <code>[crossbeam_channel::Sender::send]</code> 调用时阻塞半秒，直到其中一个工作线程对信道中的数据处理完毕。也请注意，信道中的数据由最先接收它的任何工作线程调用，因此每个消息都传递给单个工作线程，而不是传递给两个工作线程。</p><p>  通过迭代器 <code>crossbeam_channel::Receiver::iter</code>方法从信道读取数据，这将会造成阻塞，要么等待新消息，要么直到信道关闭。因为信道是在 <code>crossbeam::scope</code>范围内创建的，我们必须通过 <code>drop</code> 手动关闭它们，以防止整个程序阻塞工作线程的 <code>for</code> 循环。可以将对 <code>drop</code> 的调用视作不再发送消息的信号。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> crossbeam;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> crossbeam_channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crossbeam_channel::bounded;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (send1, recv1) = <span class="title function_ invoke__">bounded</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> (send2, recv2) = <span class="title function_ invoke__">bounded</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n_msgs</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n_workers</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    crossbeam::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|_| &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..n_msgs &#123;</span><br><span class="line">                send1.<span class="title function_ invoke__">send</span>(i).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;发送来源 &#123;&#125;&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关闭信道 —— 这是退出的必要条件</span></span><br><span class="line">            <span class="comment">// for 巡海在工作线程中</span></span><br><span class="line">            <span class="title function_ invoke__">drop</span>(send1);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 由 2 个线程并行处理</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..n_workers &#123;</span><br><span class="line">            <span class="comment">// 从数据源发送数据到接收器，接收器接收数据</span></span><br><span class="line">            <span class="keyword">let</span> (sendr, recvr) = (send2.<span class="title function_ invoke__">clone</span>(), recv1.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">            <span class="comment">// 在不同的线程中衍生工人</span></span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> |_| &#123;</span><br><span class="line">                thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">500</span>));</span><br><span class="line">                <span class="comment">// 接收数据，直到信道关闭前</span></span><br><span class="line">                <span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> recvr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;工作线程 &#123;:?&#125; 接受到 &#123;&#125;. 并予以百倍奉还&quot;</span>, thread::<span class="title function_ invoke__">current</span>().<span class="title function_ invoke__">id</span>(), msg);</span><br><span class="line">                    sendr.<span class="title function_ invoke__">send</span>(msg * <span class="number">100</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭信道，否则接收器不会关闭</span></span><br><span class="line">        <span class="comment">// 退出 for 循坏</span></span><br><span class="line">        <span class="title function_ invoke__">drop</span>(send2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收器</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> recv2.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;返回到接收器 &#123;&#125;&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出结果如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">发送来源 0</span><br><span class="line">工作线程 ThreadId(3) 接受到 0. 并予以百倍奉还</span><br><span class="line">工作线程 ThreadId(3) 接受到 1. 并予以百倍奉还</span><br><span class="line">返回到接收器 0</span><br><span class="line">返回到接收器 100</span><br><span class="line">发送来源 1</span><br><span class="line">发送来源 2</span><br><span class="line">工作线程 ThreadId(4) 接受到 2. 并予以百倍奉还</span><br><span class="line">发送来源 3</span><br><span class="line">返回到接收器 200</span><br><span class="line">工作线程 ThreadId(4) 接受到 3. 并予以百倍奉还</span><br><span class="line">返回到接收器 300</span><br></pre></td></tr></table></figure><h3 id="1-3-在两个线程间传递数据">1.3 在两个线程间传递数据</h3><p>  在单生产者、单消费者（SPSC）环境中使用 <code>crossbeam-channel</code>。我们构建的生成短期线程实例中，使用 <code>crossbeam::scope</code> 和 <code>Scope::spawn</code> 来管理生产者线程。在两个线程之间，使用 <code>crossbeam_channel::unbounded</code> 信道交换数据，这意味着可存储消息的数量没有限制。生产者线程在消息之间休眠半秒。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;thread, time&#125;;</span><br><span class="line"><span class="keyword">use</span> crossbeam_channel::unbounded;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (snd, rcv) = <span class="title function_ invoke__">unbounded</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n_msgs</span> = <span class="number">5</span>;</span><br><span class="line">    crossbeam::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|_| &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..n_msgs &#123;</span><br><span class="line">                snd.<span class="title function_ invoke__">send</span>(i).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                thread::<span class="title function_ invoke__">sleep</span>(time::Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">500</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..n_msgs &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msg</span> = rcv.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;收到 &#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出结果如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">收到 0</span><br><span class="line">收到 1</span><br><span class="line">收到 2</span><br><span class="line">收到 3</span><br><span class="line">收到 4</span><br></pre></td></tr></table></figure><h3 id="1-4-保持全局可变状态">1.4 保持全局可变状态</h3><p>  使用 <code>lazy_static</code> 声明全局状态。<code>lazy_static</code> 创建了一个全局可用的 <code>static ref</code>，它需要 <code>Mutex</code> 来允许变化（请参阅 <code>RwLock</code>）。在 <code>Mutex</code> 的包裹下，保证了状态不能被多个线程同时访问，从而防止出现争用情况。必须获取 <code>MutexGuard</code>，方可读取或更改存储在 <code>Mutex</code> 中的值。</p><p>此小节需要安装<code>lazy_static</code>库，可通过<code>cargo add lazy_static</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">lazy_static</span> = <span class="string">&quot;1.4.0&quot;</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line">error_chain!&#123; &#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> FRUIT: Mutex&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="type">Vec</span>::<span class="title function_ invoke__">new</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">insert</span>(fruit: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">db</span> = FRUIT.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">map_err</span>(|_| <span class="string">&quot;Failed to acquire MutexGuard&quot;</span>)?;</span><br><span class="line">    db.<span class="title function_ invoke__">push</span>(fruit.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">insert</span>(<span class="string">&quot;苹果&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">insert</span>(<span class="string">&quot;橘子&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">insert</span>(<span class="string">&quot;梨&quot;</span>)?;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">db</span> = FRUIT.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">map_err</span>(|_| <span class="string">&quot;Failed to acquire MutexGuard&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">        db.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>().<span class="title function_ invoke__">for_each</span>(|(i, item)| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, i, item));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">insert</span>(<span class="string">&quot;葡萄&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出结果如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0: 苹果</span><br><span class="line">1: 橘子</span><br><span class="line">2: 梨</span><br></pre></td></tr></table></figure><h3 id="1-5-对所有-iso-文件的-SHA256-值并发求和">1.5 对所有 <code>iso</code> 文件的 <code>SHA256</code> 值并发求和</h3><p>  计算了当前目录中每个扩展名为 <code>iso</code> 的文件的 <code>SHA256</code> 哈希值。线程池生成的线程数与使用 <code>num_cpus::get</code> 获取的系统内核数相等。<code>Walkdir::new</code> 遍历当前目录，并调用 <code>execute</code> 来执行读取和计算 <code>SHA256</code> 哈希值的操作。</p><p>此小节需要安装多个库</p><ul><li><code>threadpool</code>库，可通过<code>cargo add threadpool</code> 命令安装</li><li><code>num_cpus</code>库，可通过<code>cargo add num_cpus</code> 命令安装</li><li><code>walkdir</code>库，可通过<code>cargo add walkdir</code> 命令安装</li><li><code>ring</code>库，可通过<code>cargo add ring</code> 命令安装</li></ul><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br><span class="line"><span class="attr">ring</span> = <span class="string">&quot;0.16.20&quot;</span></span><br><span class="line"><span class="attr">walkdir</span> = <span class="string">&quot;2.3.3&quot;</span></span><br><span class="line"><span class="attr">num_cpus</span> = <span class="string">&quot;1.15.0&quot;</span></span><br><span class="line"><span class="attr">threadpool</span> = <span class="string">&quot;1.8.1&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> walkdir::WalkDir;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;BufReader, Read, Error&#125;;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"><span class="keyword">use</span> threadpool::ThreadPool;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc::channel;</span><br><span class="line"><span class="keyword">use</span> ring::digest::&#123;Context, Digest, SHA256&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify the iso extension</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_iso</span>(entry: &amp;Path) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> entry.<span class="title function_ invoke__">extension</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(e) <span class="keyword">if</span> e.<span class="title function_ invoke__">to_string_lossy</span>().<span class="title function_ invoke__">to_lowercase</span>() == <span class="string">&quot;iso&quot;</span> =&gt; <span class="literal">true</span>,</span><br><span class="line">        _ =&gt; <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">compute_digest</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(filepath: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(Digest, P), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf_reader</span> = BufReader::<span class="title function_ invoke__">new</span>(File::<span class="title function_ invoke__">open</span>(&amp;filepath)?);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">context</span> = Context::<span class="title function_ invoke__">new</span>(&amp;SHA256);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">count</span> = buf_reader.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer)?;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        context.<span class="title function_ invoke__">update</span>(&amp;buffer[..count]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>((context.<span class="title function_ invoke__">finish</span>(), filepath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = ThreadPool::<span class="title function_ invoke__">new</span>(num_cpus::<span class="title function_ invoke__">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = <span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">entry</span> <span class="keyword">in</span> WalkDir::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/home/user/Downloads&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">follow_links</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|e| e.<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|e| !e.<span class="title function_ invoke__">path</span>().<span class="title function_ invoke__">is_dir</span>() &amp;&amp; <span class="title function_ invoke__">is_iso</span>(e.<span class="title function_ invoke__">path</span>())) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">path</span> = entry.<span class="title function_ invoke__">path</span>().<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">tx</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">            pool.<span class="title function_ invoke__">execute</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">digest</span> = <span class="title function_ invoke__">compute_digest</span>(path);</span><br><span class="line">                tx.<span class="title function_ invoke__">send</span>(digest).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法发送数据!&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">t</span> <span class="keyword">in</span> rx.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> (sha, path) = t?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &#123;:?&#125;&quot;</span>, sha, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出结果类似于如下结果：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SHA256:72e880f84a8cbc734160ca3b043c91b455ae5d8877d0d5afe15fa2894e177f07 <span class="string">&quot;/home/user/Downloads/ubuntu.iso&quot;</span></span><br><span class="line">SHA256:2da6c248348f5ff0ee06e57222d6cd7ff2a4c652195db7325ee8327e44175f53 <span class="string">&quot;/home/user/Downloads/debian.iso&quot;</span></span><br><span class="line">SHA256:6ea82342f0db613ce21a0f6df2e59ec2f0c9b05ed4e50f9288305c0d492b42b0 <span class="string">&quot;/home/user/Downloads/win11.iso&quot;</span></span><br><span class="line">SHA256:cb4ca11618c4e5a24f7a6bcff2eb2a14453f4d802772374386f69d710568aef8 <span class="string">&quot;/home/user/Downloads/win12.iso&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-6-将绘制分形的线程分派到线程池">1.6 将绘制分形的线程分派到线程池</h3><p>  通过从朱莉娅集绘制分形来生成图像，该集合具有用于分布式计算的线程池。使用 <code>ImageBuffer::new</code> 为指定宽度和高度的输出图像分配内存，<code>Rgb::from_channels</code> 信道则计算输出图像的 <code>RGB</code> 像素值。使用 <code>ThreadPool</code> 创建线程池，线程池中的线程数量和使用 <code>num_cpus::get</code> 获取的系统内核数相等。<code>ThreadPool::execute</code> 将每个像素作为单独的作业接收。<code>mpsc::channel</code> 信道接收作业，<code>Receiver::recv</code>接收器则检索作业。<code>ImageBuffer::put_pixel</code>处理数据，设置像素颜色。最后，<code>ImageBuffer::save</code> 将图像存储为 <code>output.png</code>。</p><p>此小节需要在1.5小节基础上安装如下两个库</p><ul><li><code>num</code>库，可通过<code>cargo add num</code> 命令安装</li><li><code>image</code>库，可通过<code>cargo add image</code> 命令安装</li></ul><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br><span class="line"><span class="attr">num_cpus</span> = <span class="string">&quot;1.15.0&quot;</span></span><br><span class="line"><span class="attr">threadpool</span> = <span class="string">&quot;1.8.1&quot;</span></span><br><span class="line"><span class="attr">num</span> = <span class="string">&quot;0.4.0&quot;</span></span><br><span class="line"><span class="attr">image</span> = <span class="string">&quot;0.24.6&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> image::&#123;ImageBuffer, Rgb&#125;;</span><br><span class="line"><span class="keyword">use</span> num::complex::Complex;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc::&#123;channel, RecvError&#125;;</span><br><span class="line"><span class="keyword">use</span> threadpool::ThreadPool;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">MpscRecv</span>(RecvError);</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将强度值转换为 RGB 值的函数</span></span><br><span class="line"><span class="comment">// 基于 http://www.efg2.com/Lab/ScienceAndEngineering/Spectra.htm</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">wavelength_to_rgb</span>(wavelength: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rgb&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">wave</span> = wavelength <span class="keyword">as</span> <span class="type">f32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (r, g, b) = <span class="keyword">match</span> wavelength &#123;</span><br><span class="line">        <span class="number">380</span>..=<span class="number">439</span> =&gt; ((<span class="number">440</span>. - wave) / (<span class="number">440</span>. - <span class="number">380</span>.), <span class="number">0.0</span>, <span class="number">1.0</span>),</span><br><span class="line">        <span class="number">440</span>..=<span class="number">489</span> =&gt; (<span class="number">0.0</span>, (wave - <span class="number">440</span>.) / (<span class="number">490</span>. - <span class="number">440</span>.), <span class="number">1.0</span>),</span><br><span class="line">        <span class="number">490</span>..=<span class="number">509</span> =&gt; (<span class="number">0.0</span>, <span class="number">1.0</span>, (<span class="number">510</span>. - wave) / (<span class="number">510</span>. - <span class="number">490</span>.)),</span><br><span class="line">        <span class="number">510</span>..=<span class="number">579</span> =&gt; ((wave - <span class="number">510</span>.) / (<span class="number">580</span>. - <span class="number">510</span>.), <span class="number">1.0</span>, <span class="number">0.0</span>),</span><br><span class="line">        <span class="number">580</span>..=<span class="number">644</span> =&gt; (<span class="number">1.0</span>, (<span class="number">645</span>. - wave) / (<span class="number">645</span>. - <span class="number">580</span>.), <span class="number">0.0</span>),</span><br><span class="line">        <span class="number">645</span>..=<span class="number">780</span> =&gt; (<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>),</span><br><span class="line">        _ =&gt; (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">factor</span> = <span class="keyword">match</span> wavelength &#123;</span><br><span class="line">        <span class="number">380</span>..=<span class="number">419</span> =&gt; <span class="number">0.3</span> + <span class="number">0.7</span> * (wave - <span class="number">380</span>.) / (<span class="number">420</span>. - <span class="number">380</span>.),</span><br><span class="line">        <span class="number">701</span>..=<span class="number">780</span> =&gt; <span class="number">0.3</span> + <span class="number">0.7</span> * (<span class="number">780</span>. - wave) / (<span class="number">780</span>. - <span class="number">700</span>.),</span><br><span class="line">        _ =&gt; <span class="number">1.0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (r, g, b) = (</span><br><span class="line">        <span class="title function_ invoke__">normalize</span>(r, factor),</span><br><span class="line">        <span class="title function_ invoke__">normalize</span>(g, factor),</span><br><span class="line">        <span class="title function_ invoke__">normalize</span>(b, factor),</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// Rgb::from_channels(r, g, b, 0) // 自 0.24.0 后已弃用：使用像素的构造函数</span></span><br><span class="line">    <span class="title function_ invoke__">Rgb</span>([r, g, b]) <span class="comment">//与原书不同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将茱莉亚集距离映射为强度值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">julia</span>(c: Complex&lt;<span class="type">f32</span>&gt;, x: <span class="type">u32</span>, y: <span class="type">u32</span>, width: <span class="type">u32</span>, height: <span class="type">u32</span>, max_iter: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">width</span> = width <span class="keyword">as</span> <span class="type">f32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">height</span> = height <span class="keyword">as</span> <span class="type">f32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">z</span> = Complex &#123;</span><br><span class="line">        <span class="comment">// scale and translate the point to image coordinates</span></span><br><span class="line">        re: <span class="number">3.0</span> * (x <span class="keyword">as</span> <span class="type">f32</span> - <span class="number">0.5</span> * width) / width,</span><br><span class="line">        im: <span class="number">2.0</span> * (y <span class="keyword">as</span> <span class="type">f32</span> - <span class="number">0.5</span> * height) / height,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">t</span> <span class="keyword">in</span> <span class="number">0</span>..max_iter &#123;</span><br><span class="line">        <span class="keyword">if</span> z.<span class="title function_ invoke__">norm</span>() &gt;= <span class="number">2.0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        z = z * z + c;</span><br><span class="line">        i = t;</span><br><span class="line">    &#125;</span><br><span class="line">    i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规格 RGB 颜色值范围内的强度值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">normalize</span>(color: <span class="type">f32</span>, factor: <span class="type">f32</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    ((color * factor).<span class="title function_ invoke__">powf</span>(<span class="number">0.8</span>) * <span class="number">255</span>.) <span class="keyword">as</span> <span class="type">u8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> (width, height) = (<span class="number">1920</span>, <span class="number">1080</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">img</span> = ImageBuffer::<span class="title function_ invoke__">new</span>(width, height);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">iterations</span> = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Complex::<span class="title function_ invoke__">new</span>(-<span class="number">0.8</span>, <span class="number">0.156</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = ThreadPool::<span class="title function_ invoke__">new</span>(num_cpus::<span class="title function_ invoke__">get</span>());</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = <span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">y</span> <span class="keyword">in</span> <span class="number">0</span>..height &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">tx</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        pool.<span class="title function_ invoke__">execute</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">x</span> <span class="keyword">in</span> <span class="number">0</span>..width &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">i</span> = <span class="title function_ invoke__">julia</span>(c, x, y, width, height, iterations);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">pixel</span> = <span class="title function_ invoke__">wavelength_to_rgb</span>(<span class="number">380</span> + i * <span class="number">400</span> / iterations);</span><br><span class="line">                tx.<span class="title function_ invoke__">send</span>((x, y, pixel)).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法发送数据!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..(width * height) &#123;</span><br><span class="line">        <span class="keyword">let</span> (x, y, pixel) = rx.<span class="title function_ invoke__">recv</span>()?;</span><br><span class="line">        img.<span class="title function_ invoke__">put_pixel</span>(x, y, pixel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = img.<span class="title function_ invoke__">save</span>(<span class="string">&quot;output.png&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>将获得一张图片</li></ul><p><img src="/imgs/posts/pic-1680865445147.png" alt=""></p><h2 id="2-数据并行">2. 数据并行</h2><h3 id="2-1-并行改变数组中元素">2.1 并行改变数组中元素</h3><p>  实例使用了 <code>rayon</code> 库，这是一个 Rust 程序设计语言的数据并行库。<code>rayon</code> 为任何并行可迭代的数据类型提供 <code>par_iter_mut</code> 方法。这是一个类迭代器的链，可以对链内的数据并行计算。</p><ul><li><code>rayon</code>库，可通过<code>cargo add rayon</code> 命令安装</li></ul><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rayon</span> = <span class="string">&quot;1.7.0&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>];</span><br><span class="line">    arr.<span class="title function_ invoke__">par_iter_mut</span>().<span class="title function_ invoke__">for_each</span>(|p| *p -= <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出结果如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[-1, 6, 8, 10]</span><br></pre></td></tr></table></figure><h3 id="2-2-并行测试集合中任意或所有的元素是否匹配给定断言">2.2 并行测试集合中任意或所有的元素是否匹配给定断言</h3><p>  如何使用 <code>rayon::any</code> 和 <code>rayon::all</code> 方法，这两个方法是分别与 <code>std::any</code> 和 <code>std::all</code> 相对应的并行方法。<code>rayon::any</code> 并行检查迭代器的任意元素是否与断言匹配，并在找到一个匹配的元素时就返回。<code>rayon::all</code> 并行检查迭代器的所有元素是否与断言匹配，并在找到不匹配的元素时立即返回。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(!vec.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">any</span>(|n| (*n % <span class="number">2</span>) != <span class="number">0</span>)); <span class="comment">// 是否存在不被2整除的数(取反)</span></span><br><span class="line">    <span class="built_in">assert!</span>(vec.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">all</span>(|n| (*n % <span class="number">2</span>) == <span class="number">0</span>)); <span class="comment">// 是否所有数均被2整除</span></span><br><span class="line">    <span class="built_in">assert!</span>(!vec.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">any</span>(|n| *n &gt; <span class="number">8</span>)); <span class="comment">// 是否存在大于8的数(取反)</span></span><br><span class="line">    <span class="built_in">assert!</span>(vec.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">all</span>(|n| *n &lt;= <span class="number">8</span>)); <span class="comment">// 是否所有数均小于或等于8</span></span><br><span class="line"></span><br><span class="line">    vec.<span class="title function_ invoke__">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(vec.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">any</span>(|n| (*n % <span class="number">2</span>) != <span class="number">0</span>)); <span class="comment">// 是否存在不被2整除的数</span></span><br><span class="line">    <span class="built_in">assert!</span>(!vec.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">all</span>(|n| (*n % <span class="number">2</span>) == <span class="number">0</span>)); <span class="comment">// 是否所有数均被2整除(取反)</span></span><br><span class="line">    <span class="built_in">assert!</span>(vec.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">any</span>(|n| *n &gt; <span class="number">8</span>)); <span class="comment">// 是否存在大于8的数</span></span><br><span class="line">    <span class="built_in">assert!</span>(!vec.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">all</span>(|n| *n &lt;= <span class="number">8</span>)); <span class="comment">// 是否所有数均小于或等于8(取反)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>进行校验</li></ul><h3 id="2-3-使用给定断言并行搜索项">2.3 使用给定断言并行搜索项</h3><p>  使用 <code>rayon::find_any</code> 和 <code>par_iter</code> 并行搜索 <code>vector</code> 集合，以查找满足指定闭包中的断言的元素。如果有多个元素满足 <code>rayon::find_any</code> 闭包参数中定义的断言，<code>rayon</code> 将返回搜索发现的第一个元素，但不一定是 <code>vector</code> 集合的第一个元素。实例中闭包的参数是对引用的引用（<code>&amp;&amp;x</code>）</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f1</span> = v.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">find_any</span>(|&amp;&amp;x| x == <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f2</span> = v.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">find_any</span>(|&amp;&amp;x| x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x &gt; <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f3</span> = v.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">find_any</span>(|&amp;&amp;x| x &gt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(f1, <span class="title function_ invoke__">Some</span>(&amp;<span class="number">9</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(f2, <span class="title function_ invoke__">Some</span>(&amp;<span class="number">8</span>));</span><br><span class="line">    <span class="built_in">assert!</span>(f3 &gt; <span class="title function_ invoke__">Some</span>(&amp;<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>进行校验</li></ul><h3 id="2-4-对-vector-并行排序">2.4 对 <code>vector</code> 并行排序</h3><p>  首先分配空字符串 <code>vector</code>；然后，通过 <code>par_iter_mut().for_each</code>并行对 <code>vector</code> 填充随机值。尽管存在多种选择，可以对可枚举数据类型进行排序，但 <code>par_sort_unstable</code> 通常比稳定排序（相同的值排序后相对顺序不变）算法快。</p><ul><li>在之前基础上安装<code>rand</code>库，可通过<code>cargo add rand</code> 命令安装</li></ul><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rayon</span> = <span class="string">&quot;1.7.0&quot;</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.5&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::distributions::Alphanumeric;</span><br><span class="line"><span class="keyword">use</span> rand::&#123;thread_rng, Rng&#125;;</span><br><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">new</span>(); <span class="number">20</span>];</span><br><span class="line">    vec.<span class="title function_ invoke__">par_iter_mut</span>().<span class="title function_ invoke__">for_each</span>(|p| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rng</span> = <span class="title function_ invoke__">thread_rng</span>();</span><br><span class="line">        *p = (<span class="number">0</span>..<span class="number">5</span>).<span class="title function_ invoke__">map</span>(|_| rng.<span class="title function_ invoke__">sample</span>(Alphanumeric) <span class="keyword">as</span> <span class="type">char</span>).<span class="title function_ invoke__">collect</span>() <span class="comment">//与原书不同</span></span><br><span class="line">    &#125;);</span><br><span class="line">    vec.<span class="title function_ invoke__">par_sort_unstable</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>进行校验</li></ul><h3 id="2-5-Map-reduce-并行计算">2.5 <code>Map-reduce</code> 并行计算</h3><p>  使用 <code>rayon::filter</code>、<code>rayon::map</code>，以及 <code>rayon::reduce</code> 计算 <code>Person</code> 对象中年龄超过 30 岁的那些人的平均年龄。<code>rayon::filter</code> 过滤集合中满足给定断言的元素。<code>rayon::map</code> 对每个元素执行一次计算，创建一个新的迭代；<code>rayon::reduce</code> 执行新的计算，基于前一次的 <code>reduce</code> 计算结果和当前元素累加在一起。另外可以查看 <code>rayon::sum</code>，它与本实例中的 <code>reduce</code> 计算具有相同的结果。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;Person&gt; = <span class="built_in">vec!</span>[</span><br><span class="line">        Person &#123; age: <span class="number">23</span> &#125;,</span><br><span class="line">        Person &#123; age: <span class="number">19</span> &#125;,</span><br><span class="line">        Person &#123; age: <span class="number">42</span> &#125;,</span><br><span class="line">        Person &#123; age: <span class="number">17</span> &#125;,</span><br><span class="line">        Person &#123; age: <span class="number">17</span> &#125;,</span><br><span class="line">        Person &#123; age: <span class="number">31</span> &#125;,</span><br><span class="line">        Person &#123; age: <span class="number">30</span> &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_over_30</span> = v.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">filter</span>(|&amp;x| x.age &gt; <span class="number">30</span>).<span class="title function_ invoke__">count</span>() <span class="keyword">as</span> <span class="type">f32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum_over_30</span> = v</span><br><span class="line">        .<span class="title function_ invoke__">par_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|x| x.age)</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|&amp;x| x &gt; <span class="number">30</span>)</span><br><span class="line">        .<span class="title function_ invoke__">reduce</span>(|| <span class="number">0</span>, |x, y| x + y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">alt_sum_30</span>: <span class="type">u32</span> = v.<span class="title function_ invoke__">par_iter</span>().<span class="title function_ invoke__">map</span>(|x| x.age).<span class="title function_ invoke__">filter</span>(|&amp;x| x &gt; <span class="number">30</span>).<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">avg_over_30</span> = sum_over_30 <span class="keyword">as</span> <span class="type">f32</span> / num_over_30;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">alt_avg_over_30</span> = alt_sum_30 <span class="keyword">as</span> <span class="type">f32</span> / num_over_30;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>((avg_over_30 - alt_avg_over_30).<span class="title function_ invoke__">abs</span>() &lt; std::<span class="type">f32</span>::EPSILON); <span class="comment">//EPSILON: 0.00000011920929</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;30岁以上的人的平均年龄是 &#123;&#125;&quot;</span>, avg_over_30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>输出结果如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">30岁以上的人的平均年龄是 36.5</span><br></pre></td></tr></table></figure><h3 id="2-6-并行生成-png-缩略图">2.6 并行生成 <code>png</code> 缩略图</h3><p>  为当前目录中的所有 <code>.png</code> 图像文件生成缩略图，然后将生成的缩略图保存在一个名为 <code>thumbnails</code> 的新文件夹中。<code>glob::glob_with</code> 在当前目录中查找 <code>jpeg</code> 图像文件，<code>rayon</code> 通过 <code>par_iter</code> 方法调用 <code>DynamicImage::resize</code>，并行地调整图像大小。</p><ul><li>在之前基础上安装<code>glob</code>库，可通过<code>cargo add glob</code> 命令安装</li></ul><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br><span class="line"><span class="attr">image</span> = <span class="string">&quot;0.24.6&quot;</span></span><br><span class="line"><span class="attr">rayon</span> = <span class="string">&quot;1.7.0&quot;</span></span><br><span class="line"><span class="attr">glob</span> = <span class="string">&quot;0.3.1&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fs::create_dir_all;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> error_chain::ChainedError;</span><br><span class="line"><span class="keyword">use</span> glob::&#123;glob_with, MatchOptions&#125;;</span><br><span class="line"><span class="keyword">use</span> image::&#123;imageops::FilterType, ImageError&#125;;</span><br><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">    foreign_links &#123;</span><br><span class="line">        <span class="title function_ invoke__">Image</span>(ImageError);</span><br><span class="line">        <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">        <span class="title function_ invoke__">Glob</span>(glob::PatternError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">options</span>: MatchOptions = <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">files</span>: <span class="type">Vec</span>&lt;_&gt; = <span class="title function_ invoke__">glob_with</span>(<span class="string">&quot;*.png&quot;</span>, options)?</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|x| x.<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> files.<span class="title function_ invoke__">len</span>() == <span class="number">0</span> &#123;</span><br><span class="line">        error_chain::bail!(<span class="string">&quot;在当前目录中找不到 .png 文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">thumb_dir</span> = <span class="string">&quot;thumbnails&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">create_dir_all</span>(thumb_dir)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;将 &#123;&#125; 缩略图保存到 &#x27;&#123;&#125;&#x27;...&quot;</span>, files.<span class="title function_ invoke__">len</span>(), thumb_dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">image_failures</span>: <span class="type">Vec</span>&lt;_&gt; = files</span><br><span class="line">        .<span class="title function_ invoke__">par_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|path| &#123;</span><br><span class="line">            <span class="title function_ invoke__">make_thumbnail</span>(path, thumb_dir, <span class="number">300</span>)</span><br><span class="line">                .<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">chain_err</span>(|| path.<span class="title function_ invoke__">display</span>().<span class="title function_ invoke__">to_string</span>()))</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|x| x.<span class="title function_ invoke__">err</span>())</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    image_failures</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">display_chain</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; thumbnails 保存成功&quot;</span>, files.<span class="title function_ invoke__">len</span>() - image_failures.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">make_thumbnail</span>&lt;PA, PB&gt;(original: PA, thumb_dir: PB, longest_edge: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    PA: <span class="built_in">AsRef</span>&lt;Path&gt;,</span><br><span class="line">    PB: <span class="built_in">AsRef</span>&lt;Path&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">img</span> = image::<span class="title function_ invoke__">open</span>(original.<span class="title function_ invoke__">as_ref</span>())?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_path</span> = thumb_dir.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">join</span>(original);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(img</span><br><span class="line">        .<span class="title function_ invoke__">resize</span>(longest_edge, longest_edge, FilterType::Nearest)</span><br><span class="line">        .<span class="title function_ invoke__">save</span>(file_path)?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行<code>cargo run</code>(处理1.6小节生成的图片)输出结果如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">将 1 缩略图保存到 <span class="string">&#x27;thumbnails&#x27;</span>...</span><br><span class="line">1 thumbnails 保存成功</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── output.png <span class="comment"># 原始文件</span></span><br><span class="line">└── thumbnails</span><br><span class="line">    └── output.png <span class="comment"># 生成后的文件</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】三 压缩</title>
      <link href="/news/1680011142405.html"/>
      <url>/news/1680011142405.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用-tar-包">1. 使用 <code>tar</code> 包</h2><p>  需要安装<code>flate2</code>和<code>tar</code>库，可通过<code>cargo add flate2</code> 和<code>cargo add tar</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">flate2</span> = <span class="string">&quot;1.0.25&quot;</span></span><br><span class="line"><span class="attr">tar</span> = <span class="string">&quot;0.4.38&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-1-压缩目录为-tar-包">1.1 压缩目录为 <code>tar</code> 包</h3><p>  压缩 <code>/root/testtar</code>目录内的内容到 <code>archive.tar.gz</code> 压缩包中。创建一个用 <code>GzEncoder</code> 和 <code>tar::Builder</code> 包裹的 <code>File</code>。使用 <code>Builder::append_dir_all</code>，将 <code>/root/testtar</code>目录内的内容递归添加到 <code>backup/code</code>路径下的归档文件中。在将数据写入压缩包 <code>archive.tar.gz</code> 之前，<code>GzEncoder</code> 负责清晰地将数据压缩。</p><ul><li><code>/root/testtar</code>目录结构如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/root/testtar/</span><br><span class="line">├── Cargo.lock_copy</span><br><span class="line">├── Cargo.toml_copy</span><br><span class="line">└── src-rust</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure><ul><li>详细代码如下：</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> flate2::write::GzEncoder;</span><br><span class="line"><span class="keyword">use</span> flate2::Compression;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> tar::Builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tar_gz</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;archive.tar.gz&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">enc</span> = GzEncoder::<span class="title function_ invoke__">new</span>(tar_gz, Compression::<span class="title function_ invoke__">default</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tar</span> = Builder::<span class="title function_ invoke__">new</span>(enc);</span><br><span class="line">    tar.<span class="title function_ invoke__">append_dir_all</span>(<span class="string">&quot;backup/code&quot;</span>, <span class="string">&quot;/root/testtar&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行命令如下,在当前目录下生成一个名为<code>archive.tar.gz</code>的压缩包</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><ul><li>目录结构如下</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── archive.tar.gz</span><br><span class="line">├── src</span><br><span class="line">│   └── main.rs</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure><h3 id="1-2-解压-tar-包">1.2. 解压 <code>tar</code> 包</h3><p>  从当前工作目录中的压缩包 <code>archive.tar.gz</code>，解压（<code>GzDecoder</code>）和提取（<code>Archive::unpack</code>）所有文件，并放在<code>copy</code>目录下。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> flate2::read::GzDecoder;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> tar::Archive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = <span class="string">&quot;archive.tar.gz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tar_gz</span> = File::<span class="title function_ invoke__">open</span>(path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tar</span> = GzDecoder::<span class="title function_ invoke__">new</span>(tar_gz);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">archive</span> = Archive::<span class="title function_ invoke__">new</span>(tar);</span><br><span class="line">    archive.<span class="title function_ invoke__">unpack</span>(<span class="string">&quot;./copy/&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行命令如下,解压到<code>copy</code>目录下</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><ul><li>目录结构如下,可以看到目录包含<code>backup/code</code></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">copy/</span><br><span class="line">└── backup</span><br><span class="line">    └── code</span><br><span class="line">        ├── Cargo.lock_copy</span><br><span class="line">        ├── Cargo.toml_copy</span><br><span class="line">        └── src-rust</span><br><span class="line">            └── main.rs</span><br></pre></td></tr></table></figure><h3 id="1-3-从路径移除前缀时，解压-tar-包">1.3 从路径移除前缀时，解压 <code>tar</code> 包</h3><p>  循环遍历 <code>Archive::entries</code>。使用 <code>Path::strip_prefix</code> 移除指定的路径前缀（bundle/logs）。最终，通过 <code>Entry::unpack</code>提取 <code>tar::Entry</code>（<code>tar</code> 包中的内容）。此块代码需要安装<code>error-chain</code>库，通过<code>error-chain</code> 命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">error-chain</span> = <span class="string">&quot;0.12.4&quot;</span></span><br><span class="line"><span class="attr">flate2</span> = <span class="string">&quot;1.0.25&quot;</span></span><br><span class="line"><span class="attr">tar</span> = <span class="string">&quot;0.4.38&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> error_chain::error_chain;</span><br><span class="line"><span class="keyword">use</span> flate2::read::GzDecoder;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::path::PathBuf;</span><br><span class="line"><span class="keyword">use</span> tar::Archive;</span><br><span class="line"></span><br><span class="line">error_chain! &#123;</span><br><span class="line">  foreign_links &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(std::io::Error);</span><br><span class="line">    <span class="title function_ invoke__">StripPrefixError</span>(::std::path::StripPrefixError);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;archive.tar.gz&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">archive</span> = Archive::<span class="title function_ invoke__">new</span>(GzDecoder::<span class="title function_ invoke__">new</span>(file));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">prefix</span> = <span class="string">&quot;backup/code&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;提取了以下文件:&quot;</span>);</span><br><span class="line">    archive</span><br><span class="line">        .<span class="title function_ invoke__">entries</span>()?</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|e| e.<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|<span class="keyword">mut</span> entry| <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;PathBuf&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">path</span> = entry.<span class="title function_ invoke__">path</span>()?.<span class="title function_ invoke__">strip_prefix</span>(prefix)?.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line">            entry.<span class="title function_ invoke__">unpack</span>(&amp;path)?;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(path)</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|e| e.<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">for_each</span>(|x| <span class="built_in">println!</span>(<span class="string">&quot;&gt; &#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">display</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行命令如下,解压到<code>copy</code>目录下</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><ul><li>输出结果如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">提取了以下文件:</span><br><span class="line">&gt; src-rust</span><br><span class="line">&gt; src-rust/main.rs</span><br><span class="line">&gt; Cargo.lock_copy</span><br><span class="line">&gt; Cargo.toml_copy</span><br></pre></td></tr></table></figure><ul><li>解压到当前目录的目录结构如下</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── Cargo.lock_copy</span><br><span class="line">├── Cargo.toml_copy</span><br><span class="line">├── src-rust</span><br><span class="line">│   └── main.rs</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】二 命令行</title>
      <link href="/news/1679492996891.html"/>
      <url>/news/1679492996891.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-参数解析">1. 参数解析</h2><p>  需要安装<code>clap</code>库，可通过<code>cargo add clap --features derive</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">clap</span> = &#123; version = <span class="string">&quot;4.1.11&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-解析命令行参数">1.1 解析命令行参数</h3><p>  此应用程序使用 <code>clap</code> 构建器样式描述其命令行界面的结构。文档还提供了另外两种可用的方法去实例化应用程序。在构建器样式中，<code>short</code> 和 <code>long</code> 选项控制用户将要键入的标志；<code>short</code> 标志看起来像 <code>-f</code>，long 标志看起来像 <code>--file</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> clap::&#123;Arg, Command&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">matches</span> = Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;命令行-测试&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">version</span>(<span class="string">&quot;0.1.0&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">author</span>(<span class="string">&quot;Hackerman Jones &lt;hckrmnjones@hack.gov&gt;&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">about</span>(<span class="string">&quot;参数解析教学&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">arg</span>(</span><br><span class="line">            Arg::<span class="title function_ invoke__">new</span>(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">                .<span class="title function_ invoke__">short</span>(<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">                .<span class="title function_ invoke__">long</span>(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">                <span class="comment">//  .takes_value(true)</span></span><br><span class="line">                .<span class="title function_ invoke__">help</span>(<span class="string">&quot;A cool file&quot;</span>),</span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">arg</span>(</span><br><span class="line">            Arg::<span class="title function_ invoke__">new</span>(<span class="string">&quot;num&quot;</span>)</span><br><span class="line">                .<span class="title function_ invoke__">short</span>(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">                .<span class="title function_ invoke__">long</span>(<span class="string">&quot;number&quot;</span>)</span><br><span class="line">                <span class="comment">//  .takes_value(true)</span></span><br><span class="line">                .<span class="title function_ invoke__">help</span>(<span class="string">&quot;Five less than your favorite number&quot;</span>),</span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">get_matches</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">binding</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">myfile</span> = matches.get_one::&lt;<span class="type">String</span>&gt;(<span class="string">&quot;file&quot;</span>).<span class="title function_ invoke__">unwrap_or</span>(&amp;binding);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;传递的文件是: &#123;&#125;&quot;</span>, myfile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_str</span> = matches.get_one::&lt;<span class="type">String</span>&gt;(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> num_str &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;不知道你最喜欢的数字是什么。&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(s) =&gt; <span class="keyword">match</span> s.parse::&lt;<span class="type">i32</span>&gt;() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;你喜欢的数字是 &#123;&#125;.&quot;</span>, n + <span class="number">5</span>),</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;那不是一个数字! &#123;&#125;&quot;</span>, s),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行命令如下</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run -- -f abc.txt -n 100</span><br></pre></td></tr></table></figure><ul><li>程序输出结果</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">传递的文件是: abc.txt</span><br><span class="line">你喜欢的数字是 105.</span><br></pre></td></tr></table></figure><h2 id="2-ANSI-终端">2. <code>ANSI</code> 终端</h2><p>  需要安装<code>ansi_term</code>库，可通过<code>cargo add ansi_term</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">ansi_term</span> = <span class="string">&quot;0.12.1&quot;</span></span><br></pre></td></tr></table></figure><p>  <code>ansi_term</code> 中有两种主要的数据结构：<code>ANSIString</code> 和 <code>Style</code>。<code>Style</code> 包含样式信息：颜色，是否粗体文本，或者是否闪烁，或者其它样式。还有 <code>Colour</code> 变量，代表简单的前景色样式。<code>ANSIString</code> 是与 <code>Style</code> 配对的字符串。</p><h3 id="2-1-打印彩色文本到终端">2.1 打印彩色文本到终端</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ansi_term::Colour;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;This is &#123;&#125; in color, &#123;&#125; in color and &#123;&#125; in color&quot;</span>,</span><br><span class="line">        Colour::Red.<span class="title function_ invoke__">paint</span>(<span class="string">&quot;红色&quot;</span>),</span><br><span class="line">        Colour::Blue.<span class="title function_ invoke__">paint</span>(<span class="string">&quot;蓝色&quot;</span>),</span><br><span class="line">        Colour::Green.<span class="title function_ invoke__">paint</span>(<span class="string">&quot;绿色&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序输出结果</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">This is 红色 <span class="keyword">in</span> color, 蓝色 <span class="keyword">in</span> color and 绿色 <span class="keyword">in</span> color</span><br></pre></td></tr></table></figure><h3 id="2-2-终端中的粗体文本">2.2 终端中的粗体文本</h3><p>  对于比简单的前景色变化更复杂的事情，代码需要构造 <code>Style</code> 结构体。<code>Style::new()</code> 创建结构体，并链接属性。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ansi_term::Style;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and 这不是&quot;</span>, Style::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">bold</span>().<span class="title function_ invoke__">paint</span>(<span class="string">&quot;这是加粗&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序输出结果</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这是加粗 and 这不是</span><br></pre></td></tr></table></figure><h3 id="2-3-终端中的粗体和彩色文本">2.3 终端中的粗体和彩色文本</h3><p>  <code>Colour</code> 模块实现了许多类似 <code>Style</code> 的函数，并且可以链接方法。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> ansi_term::Colour;</span><br><span class="line"><span class="keyword">use</span> ansi_term::Style;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;&#125;, &#123;&#125; and &#123;&#125;&quot;</span>,</span><br><span class="line">        Colour::Yellow.<span class="title function_ invoke__">paint</span>(<span class="string">&quot;这是黄色的&quot;</span>),</span><br><span class="line">        Style::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">bold</span>().<span class="title function_ invoke__">paint</span>(<span class="string">&quot;这是加粗的&quot;</span>),</span><br><span class="line">        Colour::Yellow.<span class="title function_ invoke__">bold</span>().<span class="title function_ invoke__">paint</span>(<span class="string">&quot;这是黄色并加粗的&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序输出结果</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这是黄色的, 这是加粗的 and 这是黄色并加粗的</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python杂记】async和await使用</title>
      <link href="/news/1678864283156.html"/>
      <url>/news/1678864283156.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用的库-库-httpx-可通过-pip-install-httpx-命令安装">1. 使用的库(库 <code>httpx</code> 可通过 <code>pip install httpx</code> 命令安装)</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure><h2 id="2-async-和-await-的普通使用">2. <code>async</code> 和 <code>await</code> 的普通使用</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_other</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test_other</span>():</span><br><span class="line">    urls = [<span class="string">&#x27;https://httpbin.org/get&#x27;</span>, <span class="string">&#x27;https://httpbin.org/cookies&#x27;</span>, <span class="string">&#x27;https://httpbin.org/uuid&#x27;</span>, <span class="string">&#x27;https://httpbin.org/response-headers?freeform=&#x27;</span>]</span><br><span class="line">    tasks = [asyncio.ensure_future(fetch_other(url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</span><br></pre></td></tr></table></figure><h2 id="3-async-和-await-调用库-httpx">3. <code>async</code> 和 <code>await</code> 调用库 <code>httpx</code></h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_httpx</span>(<span class="params">client, url</span>):</span><br><span class="line">    resp = <span class="keyword">await</span> client.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.json()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test_httpx</span>():</span><br><span class="line">    urls = [<span class="string">&#x27;https://httpbin.org/get&#x27;</span>, <span class="string">&#x27;https://httpbin.org/cookies&#x27;</span>, <span class="string">&#x27;https://httpbin.org/uuid&#x27;</span>, <span class="string">&#x27;https://httpbin.org/response-headers?freeform=&#x27;</span>]</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient() <span class="keyword">as</span> client:</span><br><span class="line">        tasks = [asyncio.ensure_future(fetch_httpx(client, url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        responses = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">        <span class="keyword">return</span> responses</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="comment"># 其他流程</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    responses = loop.run_until_complete(test_httpx())</span><br><span class="line">    <span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">        <span class="built_in">print</span>(response)</span><br><span class="line">    loop.run_until_complete(test_other())</span><br><span class="line">    loop.close()</span><br><span class="line">    <span class="comment"># 其他流程</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;运行时长: %s 秒&#x27;</span>%(end-start))</span><br></pre></td></tr></table></figure><h2 id="4-详细情况">4. 详细情况</h2><h3 id="4-1-详细代码">4.1 详细代码</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_httpx</span>(<span class="params">client, url</span>):</span><br><span class="line">    resp = <span class="keyword">await</span> client.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.json()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test_httpx</span>():</span><br><span class="line">    urls = [<span class="string">&#x27;https://httpbin.org/get&#x27;</span>, <span class="string">&#x27;https://httpbin.org/cookies&#x27;</span>, <span class="string">&#x27;https://httpbin.org/uuid&#x27;</span>, <span class="string">&#x27;https://httpbin.org/response-headers?freeform=&#x27;</span>]</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient() <span class="keyword">as</span> client:</span><br><span class="line">        tasks = [asyncio.ensure_future(fetch_httpx(client, url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        responses = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">        <span class="keyword">return</span> responses</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_other</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test_other</span>():</span><br><span class="line">    urls = [<span class="string">&#x27;https://httpbin.org/get&#x27;</span>, <span class="string">&#x27;https://httpbin.org/cookies&#x27;</span>, <span class="string">&#x27;https://httpbin.org/uuid&#x27;</span>, <span class="string">&#x27;https://httpbin.org/response-headers?freeform=&#x27;</span>]</span><br><span class="line">    tasks = [asyncio.ensure_future(fetch_other(url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="comment"># 其他流程</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    responses = loop.run_until_complete(test_httpx())</span><br><span class="line">    <span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">        <span class="built_in">print</span>(response)</span><br><span class="line">    loop.run_until_complete(test_other())</span><br><span class="line">    loop.close()</span><br><span class="line">    <span class="comment"># 其他流程</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;运行时长: %s 秒&#x27;</span>%(end-start))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="4-2-运行输出结果">4.2 运行输出结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;args&#x27;: &#123;&#125;, &#x27;headers&#x27;: &#123;&#x27;Accept&#x27;: &#x27;*/*&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, br&#x27;, &#x27;Host&#x27;: &#x27;httpbin.org&#x27;, &#x27;User-Agent&#x27;: &#x27;python-httpx/0.23.0&#x27;, &#x27;X-Amzn-Trace-Id&#x27;: &#x27;Root=1-641168d8-29511e7271300606309ff8b9&#x27;&#125;, &#x27;origin&#x27;: &#x27;106.120.122.135&#x27;, &#x27;url&#x27;: &#x27;https://httpbin.org/get&#x27;&#125;</span><br><span class="line">&#123;&#x27;cookies&#x27;: &#123;&#125;&#125;</span><br><span class="line">&#123;&#x27;uuid&#x27;: &#x27;fd8c2608-7b3e-47f9-8aec-0c31299771a7&#x27;&#125;</span><br><span class="line">&#123;&#x27;Content-Length&#x27;: &#x27;87&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#x27;freeform&#x27;: &#x27;&#x27;&#125;</span><br><span class="line">https://httpbin.org/get</span><br><span class="line">https://httpbin.org/uuid</span><br><span class="line">https://httpbin.org/cookies</span><br><span class="line">https://httpbin.org/response-headers?freeform=</span><br><span class="line">运行时长: 12.626903533935547 秒</span><br></pre></td></tr></table></figure><h2 id="5-其他事项">5. 其他事项</h2><p>  文中使用<code>httpx</code>进行异步请求，如果使用<code>aiohttp</code>(<code>通过pip install aiohttp</code>命令安装)进行异步请求时，使用<code>loop.close()</code>关闭事件循环时会抛出异常<code>raise RuntimeError('Event loop is closed')</code>【Python 版本 3.9】。相关代码如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_asyncio</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> response.json()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test_asyncio</span>():</span><br><span class="line">    urls = [<span class="string">&#x27;https://httpbin.org/get&#x27;</span>, <span class="string">&#x27;https://httpbin.org/cookies&#x27;</span>, <span class="string">&#x27;https://httpbin.org/uuid&#x27;</span>, <span class="string">&#x27;https://httpbin.org/response-headers?freeform=&#x27;</span>]</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        tasks = [asyncio.ensure_future(fetch_asyncio(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        responses = <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line">        <span class="keyword">return</span> responses</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 其他流程</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    responses = loop.run_until_complete(test_asyncio())</span><br><span class="line">    <span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">        <span class="built_in">print</span>(response)</span><br><span class="line">    loop.close()</span><br><span class="line">    <span class="comment"># 其他流程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="5-1-运行报错结果">5.1 运行报错结果</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exception ignored <span class="keyword">in</span>: &lt;<span class="keyword">function</span> _ProactorBasePipeTransport.__del__ at 0x00000118E6D784C0&gt;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:\Program Files\Python39\lib\asyncio\proactor_events.py&quot;</span>, line 116, <span class="keyword">in</span> __del__</span><br><span class="line">    self.close()</span><br><span class="line">  File <span class="string">&quot;C:\Program Files\Python39\lib\asyncio\proactor_events.py&quot;</span>, line 108, <span class="keyword">in</span> close</span><br><span class="line">    self._loop.call_soon(self._call_connection_lost, None)</span><br><span class="line">  File <span class="string">&quot;C:\Program Files\Python39\lib\asyncio\base_events.py&quot;</span>, line 746, <span class="keyword">in</span> call_soon</span><br><span class="line">    self._check_closed()</span><br><span class="line">  File <span class="string">&quot;C:\Program Files\Python39\lib\asyncio\base_events.py&quot;</span>, line 510, <span class="keyword">in</span> _check_closed</span><br><span class="line">    raise RuntimeError(<span class="string">&#x27;Event loop is closed&#x27;</span>)</span><br><span class="line">RuntimeError: Event loop is closed</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 盘蛇教 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust Cookbook系列】一 算法</title>
      <link href="/news/1678889342364.html"/>
      <url>/news/1678889342364.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-生成随机值">1. 生成随机值</h2><p>  需要安装<code>rand</code>库，可通过<code>cargo add rand</code>命令安装</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.5&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-1-生成随机数">1.1 生成随机数</h3><p>  在随机数生成器 <code>rand::Rng</code> 的帮助下，通过 <code>rand::thread_rng</code> 生成随机数。可以开启多个线程，每个线程都有一个初始化的生成器。整数在其类型范围内均匀分布，浮点数是从 <code>0</code>均匀分布到 <code>1</code>，但不包括 <code>1</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rng</span> = rand::<span class="title function_ invoke__">thread_rng</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n1</span>: <span class="type">u8</span> = rng.<span class="title function_ invoke__">gen</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n2</span>: <span class="type">u16</span> = rng.<span class="title function_ invoke__">gen</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;随机生成 u8: &#123;&#125;&quot;</span>, n1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;随机生成 u16: &#123;&#125;&quot;</span>, n2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;随机生成 u32: &#123;&#125;&quot;</span>, rng.gen::&lt;<span class="type">u32</span>&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;随机生成 i32: &#123;&#125;&quot;</span>, rng.gen::&lt;<span class="type">i32</span>&gt;());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;随机生成 float: &#123;&#125;&quot;</span>, rng.gen::&lt;<span class="type">f64</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序输出结果</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">随机生成 u8: 158</span><br><span class="line">随机生成 u16: 26703</span><br><span class="line">随机生成 u32: 2989669353</span><br><span class="line">随机生成 i32: -1944070083</span><br><span class="line">随机生成 <span class="built_in">float</span>: 0.6281595400384855</span><br></pre></td></tr></table></figure><h3 id="1-2-生成范围内随机数">1.2 生成范围内随机数</h3><p>  使用 <code>Rng::gen_range</code>，在半开放的 <code>[0, 10)</code> 范围内（不包括 <code>10</code>）生成一个随机值。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rng</span> = rand::<span class="title function_ invoke__">thread_rng</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;整型Integer: &#123;&#125;&quot;</span>, rng.<span class="title function_ invoke__">gen_range</span>(<span class="number">0</span>..<span class="number">10</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;浮点型Float: &#123;&#125;&quot;</span>, rng.<span class="title function_ invoke__">gen_range</span>(<span class="number">0.0</span>..<span class="number">10.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序输出结果</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">整型Integer: 7</span><br><span class="line">浮点型Float: 4.609263483162893</span><br></pre></td></tr></table></figure><p>  使用 <code>Uniform</code> 模块可以得到均匀分布的值。下述代码和上述代码具有相同的效果，但在相同范围内重复生成数字时，下述代码性能可能会更好。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::distributions::&#123;Distribution, Uniform&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rng</span> = rand::<span class="title function_ invoke__">thread_rng</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">die</span> = Uniform::<span class="title function_ invoke__">from</span>(<span class="number">1</span>..<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">throw</span> = die.<span class="title function_ invoke__">sample</span>(&amp;<span class="keyword">mut</span> rng);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;掷骰子: &#123;&#125;&quot;</span>, throw);</span><br><span class="line">        <span class="keyword">if</span> throw == <span class="number">6</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序输出结果</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">掷骰子: 3</span><br><span class="line">掷骰子: 1</span><br><span class="line">掷骰子: 5</span><br><span class="line">掷骰子: 4</span><br><span class="line">掷骰子: 4</span><br><span class="line">掷骰子: 5</span><br><span class="line">掷骰子: 1</span><br><span class="line">掷骰子: 4</span><br><span class="line">掷骰子: 5</span><br><span class="line">掷骰子: 5</span><br><span class="line">掷骰子: 2</span><br><span class="line">掷骰子: 5</span><br><span class="line">掷骰子: 4</span><br><span class="line">掷骰子: 1</span><br><span class="line">掷骰子: 5</span><br><span class="line">掷骰子: 4</span><br><span class="line">掷骰子: 6</span><br></pre></td></tr></table></figure><h3 id="1-3-生成给定分布随机数">1.3 生成给定分布随机数</h3><p>  默认情况下，随机数在 <code>rand</code> crate 中是均匀分布。<code>rand_distr</code>(可通过<code>cargo add rand_distr</code> 安装) crate 提供其它的分布类型。如要使用，首先实例化一个分布，然后在随机数生成器<code>rand::Rng</code> 的帮助下，使用 <code>Distribution::sample</code> 从该分布中进行采样。如下是一个使用正态（<code>Normal</code>）分布的实例</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.5&quot;</span></span><br><span class="line"><span class="attr">rand_distr</span> = <span class="string">&quot;0.4.3&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand_distr::&#123;Distribution, Normal, NormalError&#125;;</span><br><span class="line"><span class="keyword">use</span> rand::thread_rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), NormalError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rng</span> = <span class="title function_ invoke__">thread_rng</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">normal</span> = Normal::<span class="title function_ invoke__">new</span>(<span class="number">2.0</span>, <span class="number">3.0</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = normal.<span class="title function_ invoke__">sample</span>(&amp;<span class="keyword">mut</span> rng);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 来自 N(2, 9) 分布&quot;</span>, v);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序输出结果</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4.025748774397368 来自 N(2, 9) 分布</span><br></pre></td></tr></table></figure><h3 id="1-4-生成自定义类型随机值">1.4 生成自定义类型随机值</h3><p>  随机生成一个元组 <code>(i32, bool, f64)</code> 和用户定义类型为 <code>Point</code> 的变量。为 <code>Standard</code> 实现 <code>Distribution</code> <code>trait</code>，以允许其随机生成。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> rand::distributions::&#123;Distribution, Standard&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Distribution</span>&lt;Point&gt; <span class="keyword">for</span> <span class="title class_">Standard</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sample</span>&lt;R: Rng + ?<span class="built_in">Sized</span>&gt;(&amp;<span class="keyword">self</span>, rng: &amp;<span class="keyword">mut</span> R) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        <span class="keyword">let</span> (rand_x, rand_y) = rng.<span class="title function_ invoke__">gen</span>();</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: rand_x,</span><br><span class="line">            y: rand_y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rng</span> = rand::<span class="title function_ invoke__">thread_rng</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rand_tuple</span> = rng.gen::&lt;(<span class="type">i32</span>, <span class="type">bool</span>, <span class="type">f64</span>)&gt;();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rand_point</span>: Point = rng.<span class="title function_ invoke__">gen</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;随机元组: &#123;:?&#125;&quot;</span>, rand_tuple);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;随机坐标: &#123;:?&#125;&quot;</span>, rand_point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序输出结果</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">随机元组: (-410099798, <span class="literal">true</span>, 0.3339881538362096)</span><br><span class="line">随机坐标: Point &#123; x: 1211748610, y: -959131956 &#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-从一组字母数字字符生成随机密码">1.5 从一组字母数字字符生成随机密码</h3><p>  随机生成一个给定长度的 <code>ASCII</code> 字符串，范围为 <code>A-Z</code>，<code>a-z</code>，<code>0-9</code>，使用字母数字样本</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::&#123;thread_rng, Rng&#125;;</span><br><span class="line"><span class="keyword">use</span> rand::distributions::Alphanumeric;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rand_string</span>: <span class="type">String</span> = <span class="title function_ invoke__">thread_rng</span>()</span><br><span class="line">        .<span class="title function_ invoke__">sample_iter</span>(&amp;Alphanumeric)</span><br><span class="line">        .<span class="title function_ invoke__">take</span>(<span class="number">16</span>)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(<span class="type">char</span>::from)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;随机密码: &#123;&#125;&quot;</span>, rand_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序输出结果</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">随机密码: bksgkrXebcPo3ZsW</span><br></pre></td></tr></table></figure><h3 id="1-6-从一组用户定义字符创建随机密码">1.6 从一组用户定义字符创建随机密码</h3><p>  使用用户自定义的字节字符串，使用 <code>gen_range</code> 函数，随机生成一个给定长度的 <code>ASCII</code> 字符串</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> CHARSET: &amp;[<span class="type">u8</span>] = <span class="string">b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ\</span></span><br><span class="line"><span class="string">                            abcdefghijklmnopqrstuvwxyz\</span></span><br><span class="line"><span class="string">                            0123456789)(*&amp;^%$#@!~&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> PASSWORD_LEN: <span class="type">usize</span> = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rng</span> = rand::<span class="title function_ invoke__">thread_rng</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">password</span>: <span class="type">String</span> = (<span class="number">0</span>..PASSWORD_LEN)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|_| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">idx</span> = rng.<span class="title function_ invoke__">gen_range</span>(<span class="number">0</span>..CHARSET.<span class="title function_ invoke__">len</span>());</span><br><span class="line">            CHARSET[idx] <span class="keyword">as</span> <span class="type">char</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;指定字符随机密码: &#123;&#125;&quot;</span>, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序输出结果</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">指定字符随机密码: Rz!eVvWN)Xg5OYae</span><br></pre></td></tr></table></figure><h2 id="2-Vector-排序">2. <code>Vector</code> 排序</h2><h3 id="2-1-整数-Vector-排序">2.1 整数 <code>Vector</code> 排序</h3><p>  通过 <code>vec::sort</code> 对一个整数 <code>Vector</code> 进行排序。另一种方法是使用 <code>vec::sort_unstable</code>，后者运行速度更快一些，但不保持相等元素的顺序。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">15</span>];</span><br><span class="line">    </span><br><span class="line">    vec.<span class="title function_ invoke__">sort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec, <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Vector-排序">2.2 <code>Vector</code> 排序</h3><p>  对于<code>f32</code> 或 <code>f64</code> 的 <code>vector，可以使用</code> <code>vec::sort_by</code> 和 <code>PartialOrd::partial_cmp</code> 对其进行排序</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1.1</span>, <span class="number">1.15</span>, <span class="number">5.5</span>, <span class="number">1.123</span>, <span class="number">2.0</span>];</span><br><span class="line"></span><br><span class="line">    vec.<span class="title function_ invoke__">sort_by</span>(|a, b| a.<span class="title function_ invoke__">partial_cmp</span>(b).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec, <span class="built_in">vec!</span>[<span class="number">1.1</span>, <span class="number">1.123</span>, <span class="number">1.15</span>, <span class="number">2.0</span>, <span class="number">5.5</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-结构体-Vector-排序">2.3 结构体 <code>Vector</code> 排序</h3><p>  依据自然顺序（按名称和年龄），对具有 <code>name</code> 和 <code>age</code> 属性的 <code>Person</code> 结构体 <code>Vector</code> 排序。为了使 <code>Person</code> 可排序，需要添加<code>traits</code>：<code>PartialEq</code>。这样也可以使用 <code>vec:sort_by</code> 方法自定义比较函数，如按照年龄排序。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">    salary: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(name: <span class="type">String</span>, age: <span class="type">u32</span>, salary: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Person &#123; name, age, salary &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">people</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Zoe&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">25</span>, <span class="number">9483.54</span>),</span><br><span class="line">        Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Al&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">60</span>, <span class="number">2433.64</span>),</span><br><span class="line">        Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;John&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">22</span>, <span class="number">6433.34</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 name 值对 people 进行排序</span></span><br><span class="line">    people.<span class="title function_ invoke__">sort_by</span>(|a, b| a.name.<span class="title function_ invoke__">cmp</span>(&amp;b.name));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        people,</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Al&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">60</span>, <span class="number">2433.64</span>),</span><br><span class="line">            Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;John&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">22</span>, <span class="number">6433.34</span>),</span><br><span class="line">            Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Zoe&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">25</span>, <span class="number">9483.54</span>),</span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 age 值对 people 进行排序(从小到大)</span></span><br><span class="line">    people.<span class="title function_ invoke__">sort_by</span>(|a, b| a.age.<span class="title function_ invoke__">cmp</span>(&amp;b.age));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        people,</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;John&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">22</span>, <span class="number">6433.34</span>),</span><br><span class="line">            Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Zoe&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">25</span>, <span class="number">9483.54</span>),</span><br><span class="line">            Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Al&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">60</span>, <span class="number">2433.64</span>),</span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// // 根据 salary 值对 people 进行排序(从大到小)</span></span><br><span class="line">    people.<span class="title function_ invoke__">sort_by</span>(|a, b| b.salary.<span class="title function_ invoke__">partial_cmp</span>(&amp;a.salary).<span class="title function_ invoke__">unwrap_or</span>(Ordering::Equal));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        people,</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Zoe&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">25</span>, <span class="number">9483.54</span>),</span><br><span class="line">            Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;John&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">22</span>, <span class="number">6433.34</span>),</span><br><span class="line">            Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Al&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">60</span>, <span class="number">2433.64</span>),</span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
            <tag> rustcookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust杂记】2023-03-13-压缩数据和解压数据</title>
      <link href="/news/1678714773864.html"/>
      <url>/news/1678714773864.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用compress压缩文件">1. 使用compress压缩文件</h2><h3 id="1-1-使用到的库flate2-配置文件Cargo-toml中添加-或通过cargo-add-flate2-添加">1.1 使用到的库<code>flate2</code>,配置文件Cargo.toml中添加(或通过cargo add flate2 添加)</h3><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">flate2</span> = <span class="string">&quot;1.0.25&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-使用库flate2压缩代码">1.2 使用库<code>flate2</code>压缩代码</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> flate2::write::GzEncoder;</span><br><span class="line"><span class="keyword">use</span> flate2::Compression;</span><br><span class="line"><span class="keyword">use</span> std::env::args;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::copy;</span><br><span class="line"><span class="keyword">use</span> std::io::BufReader;</span><br><span class="line"><span class="keyword">use</span> std::time::Instant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//在real_main函数中处理真正的程序</span></span><br><span class="line">    <span class="comment">//为了干净的结束和退出，在主函数中使用它</span></span><br><span class="line">    std::process::<span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">real_main</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">real_main</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">len</span>() != <span class="number">3</span> &#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;Usage: `source` `target`&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = BufReader::<span class="title function_ invoke__">new</span>(File::<span class="title function_ invoke__">open</span>(<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>()).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span> = File::<span class="title function_ invoke__">create</span>(<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">nth</span>(<span class="number">2</span>).<span class="title function_ invoke__">unwrap</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">encoder</span> = GzEncoder::<span class="title function_ invoke__">new</span>(output, Compression::<span class="title function_ invoke__">default</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="title function_ invoke__">copy</span>(&amp;<span class="keyword">mut</span> input, &amp;<span class="keyword">mut</span> encoder).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span> = encoder.<span class="title function_ invoke__">finish</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;源文件大小: &#123;:?&#125;&quot;</span>,</span><br><span class="line">        input.<span class="title function_ invoke__">get_ref</span>().<span class="title function_ invoke__">metadata</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">len</span>()</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;目标文件大小: &#123;:?&#125;&quot;</span>, output.<span class="title function_ invoke__">metadata</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;压缩时间: &#123;:?&#125;&quot;</span>, start.<span class="title function_ invoke__">elapsed</span>());</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-使用方式（以book-pdf为例）">1.3 使用方式（以book.pdf为例）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run book.pdf book</span><br></pre></td></tr></table></figure><h3 id="1-4-运行输出结果">1.4 运行输出结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">源文件大小: 2307697</span><br><span class="line">目标文件大小: 1885921</span><br><span class="line">压缩时间: 1.703851963s</span><br></pre></td></tr></table></figure><h2 id="2-使用decompress解压文件-以解压zip格式文件为例">2. 使用decompress解压文件(以解压<code>zip</code>格式文件为例)</h2><h3 id="2-1-使用到的库zip-配置文件Cargo-toml中添加-或通过cargo-add-zip添加">2.1 使用到的库<code>zip</code>,配置文件<code>Cargo.toml</code>中添加(或通过<code>cargo add zip</code>添加)</h3><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">zip</span> = <span class="string">&quot;0.6.4&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-使用库解压代码">2.2 使用库解压代码</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"><span class="keyword">use</span> zip::ZipArchive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//在real_main函数中处理真正的程序</span></span><br><span class="line">    <span class="comment">//为了干净的结束和退出，在主函数中使用它</span></span><br><span class="line">    std::process::<span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">real_main</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">real_main</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个名为 args 的向量来收集用户在 CLI 中的输入</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;_&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="comment">//如果 args 小于 2，就会出现问题，因为你需要发送</span></span><br><span class="line">    <span class="comment">// zip 文件，它会告诉你如何使用</span></span><br><span class="line">    <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Usage: &#123;&#125; &lt;filename&gt;&quot;</span>, args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//args在第2个位置，第一个索引表示的是文件名</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fname</span> = Path::<span class="title function_ invoke__">new</span>(&amp;*args[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//使用标准fs打开文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = fs::File::<span class="title function_ invoke__">open</span>(&amp;fname).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用存档阅读器功能</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">archive</span> = ZipArchive::<span class="title function_ invoke__">new</span>(file).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从0开始，覆盖整个archive的长度</span></span><br><span class="line">    <span class="comment">// zip 存档中会有多个文件，我们需要提取所有文件</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..archive.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = archive.<span class="title function_ invoke__">by_index</span>(i).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="comment">//设置提取文件的路径</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">outpath</span> = <span class="keyword">match</span> file.<span class="title function_ invoke__">enclosed_name</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(path) =&gt; path.<span class="title function_ invoke__">to_owned</span>(),</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">comment</span> = file.<span class="title function_ invoke__">comment</span>();</span><br><span class="line">            <span class="keyword">if</span> !comment.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;File &#123;&#125; comment: &#123;&#125;&quot;</span>, i, comment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// zip 也可以包含其他文件夹</span></span><br><span class="line">        <span class="title function_ invoke__">if</span> (*file.<span class="title function_ invoke__">name</span>()).<span class="title function_ invoke__">ends_with</span>(<span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;设置文件夹路径 &#123;&#125; 的目录 \&quot;&#123;&#125;\&quot;&quot;</span>, i, outpath.<span class="title function_ invoke__">display</span>());</span><br><span class="line">            <span class="comment">//递归创建一个新目录</span></span><br><span class="line">            fs::<span class="title function_ invoke__">create_dir_all</span>(&amp;outpath).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;文件 &#123;&#125; 提取到 \&quot;&#123;&#125;\&quot; (&#123;&#125; bytes)&quot;</span>,</span><br><span class="line">                i,</span><br><span class="line">                outpath.<span class="title function_ invoke__">display</span>(),</span><br><span class="line">                file.<span class="title function_ invoke__">size</span>()</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//如果这些文件没有父目录，则创建一个新目录</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(p) = outpath.<span class="title function_ invoke__">parent</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> !p.<span class="title function_ invoke__">exists</span>() &#123;</span><br><span class="line">                    fs::<span class="title function_ invoke__">create_dir_all</span>(&amp;p).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">outfile</span> = fs::File::<span class="title function_ invoke__">create</span>(&amp;outpath).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            io::<span class="title function_ invoke__">copy</span>(&amp;<span class="keyword">mut</span> file, &amp;<span class="keyword">mut</span> outfile).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Linux下获取和设置提取文件的权限</span></span><br><span class="line">        <span class="meta">#[cfg(unix)]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">use</span> std::os::unix::fs::PermissionsExt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(mode) = file.<span class="title function_ invoke__">unix_mode</span>() &#123;</span><br><span class="line">                fs::<span class="title function_ invoke__">set_permissions</span>(&amp;outpath, fs::Permissions::<span class="title function_ invoke__">from_mode</span>(mode)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-使用方式（以images-zip为例）">2.3 使用方式（以images.zip为例）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run images.zip </span><br></pre></td></tr></table></figure><h3 id="2-4-运行结果">2.4 运行结果</h3><ul><li>运行结果如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">设置文件夹路径 0 的目录 <span class="string">&quot;images/&quot;</span></span><br><span class="line">设置文件夹路径 1 的目录 <span class="string">&quot;images/axif/&quot;</span></span><br><span class="line">文件 2 提取到 <span class="string">&quot;images/axif/img3.avif&quot;</span> (34794 bytes)</span><br><span class="line">文件 3 提取到 <span class="string">&quot;images/img1.jpg&quot;</span> (721480 bytes)</span><br><span class="line">文件 4 提取到 <span class="string">&quot;images/img2.jpg&quot;</span> (715163 bytes)</span><br><span class="line">解压时间: 134.253736ms</span><br></pre></td></tr></table></figure><ul><li>解压文件路径如下：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">images</span><br><span class="line">├── axif</span><br><span class="line">│   └── img3.avif</span><br><span class="line">├── img1.jpg</span><br><span class="line">└── img2.jpg</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust杂记】标准库中的数据结构与算法</title>
      <link href="/news/1678627821546.html"/>
      <url>/news/1678627821546.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据结构">1. 数据结构</h2><p>  Rust的标准库提供了几种数据结构，可用于以各种方式存储和操作数据。如下所示：</p><ul><li><code>Vec&lt;T&gt;</code>：一个可增长的数组，可以存储可变数量的T类型元素。它被实现为一个动态分配的数组，并提供对其元素的有效访问。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v[<span class="number">2</span>], <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>LinkedList&lt;T&gt;</code>：一个双链表，可以存储可变数量的类型T的元素。它允许有效地插入和删除列表两端的元素，但与Vec<T>相比，它对单个元素的访问速度较慢。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::LinkedList;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = LinkedList::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    list.<span class="title function_ invoke__">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    list.<span class="title function_ invoke__">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    list.<span class="title function_ invoke__">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(list.<span class="title function_ invoke__">front</span>().<span class="title function_ invoke__">unwrap</span>(), &amp;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(list.<span class="title function_ invoke__">back</span>().<span class="title function_ invoke__">unwrap</span>(), &amp;<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>HashMap&lt;K, V&gt;</code>：一个哈希表，可以存储从K类型键到V类型值的映射。它提供了基于键值的高效插入、删除和查找。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(map.<span class="title function_ invoke__">get</span>(<span class="string">&quot;a&quot;</span>), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(map.<span class="title function_ invoke__">get</span>(<span class="string">&quot;b&quot;</span>), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(map.<span class="title function_ invoke__">get</span>(<span class="string">&quot;c&quot;</span>), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-算法">2. 算法</h2><p>  Rust标准库还提供了许多算法，可用于对数据执行常用操作。如下所示:</p><ul><li><code>sort</code>：使用稳定的排序算法对切片进行就地排序。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    v.<span class="title function_ invoke__">sort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>binary_search</code>：对排序的切片执行二分查找，以查找给定元素的索引。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">binary_search</span>(&amp;<span class="number">3</span>), <span class="title function_ invoke__">Ok</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">binary_search</span>(&amp;<span class="number">8</span>), <span class="title function_ invoke__">Err</span>(<span class="number">7</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>iter::sum</code>：计算迭代器中元素的和。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">i32</span> = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>find</code>：查找迭代器中满足给定闭包的第一个元素,以下2种形式。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_even</span> = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">find</span>(|x| *x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(first_even, <span class="title function_ invoke__">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_even</span> = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">find</span>(|&amp;x| x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert_eq!</span>(first_even, <span class="title function_ invoke__">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>min</code>和<code>max</code>：分别查找迭代器中的最小和最大元素。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">min</span> = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">min</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">max</span> = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">max</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(min, <span class="title function_ invoke__">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(max, <span class="title function_ invoke__">Some</span>(&amp;<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>all</code>和<code>any</code>：分别确定迭代器中的所有元素或任一元素是否满足给定的闭包。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">all_even</span> = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">all</span>(|x| x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">any_even</span> = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|x| x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(all_even, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(any_even, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>fold</code>：在迭代器上执行fold操作，根据迭代器的元素累积一个值。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fold函数第一个是初始值，第二个是一个闭包，闭包第一个参数是一个累计值，第二个参数是本次迭代元素的引用，返回值作为下一次迭代的累计值。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">i32</span> = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="number">2</span>, |acc, x| acc + x); <span class="comment">//相当于 2 + （(((1 + 2) + 3) + 4) + 5）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mul</span>: <span class="type">i32</span> = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="number">3</span>, |acc, x| acc * x); <span class="comment">//相当于 3 * （(((1 * 2) * 3) * 4) * 5）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">17</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(mul, <span class="number">360</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>map</code>: 即是对迭代的元素进行一次映射后再返回映射后的结果,<code>collect</code>是将一个迭代器迭代的所有元素组合成一个新的集合</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec_str</span> = vec.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x.<span class="title function_ invoke__">to_string</span>()).collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec_str, [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec_str</span>: <span class="type">Vec</span>&lt;_&gt; = vec.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec_str, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>filter</code> 是一个迭代器适配器，它接受一个闭包作为参数，该闭包返回一个布尔值。</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">    <span class="comment">// 错误示例 1</span></span><br><span class="line">    <span class="comment">// let list1: Vec&lt;_&gt; = v.iter().filter(|i| i % 3 == 0).collect();</span></span><br><span class="line">    <span class="comment">// let list2 = [0, 3, 6];</span></span><br><span class="line">    <span class="comment">// assert_eq!(list1, list2);</span></span><br><span class="line">    <span class="comment">// 错误示例 2</span></span><br><span class="line">    <span class="comment">// let list1: Vec&lt;_&gt; = v.iter().filter(|i| **i % 3 == 0).collect();</span></span><br><span class="line">    <span class="comment">// let list2 = [0, 3, 6];</span></span><br><span class="line">    <span class="comment">// assert_eq!(list1, list2);</span></span><br><span class="line">    <span class="comment">// 错误示例 3</span></span><br><span class="line">    <span class="comment">// let list1: Vec&lt;_&gt; = v.iter().filter(|i| **i % 3 == 0).copied().collect();</span></span><br><span class="line">    <span class="comment">// let list2 = [0, 3, 6];</span></span><br><span class="line">    <span class="comment">// assert_eq!(list1, list2);</span></span><br><span class="line">    <span class="comment">// 错误示例 4</span></span><br><span class="line">    <span class="comment">// let list1: Vec&lt;_&gt; = v.iter().filter(|i| **i % 3 == 0).copied().collect();</span></span><br><span class="line">    <span class="comment">// assert_eq!(list1, [0, 3, 6]);</span></span><br><span class="line">    <span class="comment">// 正确示例 </span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list1</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|i| **i % <span class="number">3</span> == <span class="number">0</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list2</span> = <span class="built_in">vec!</span>[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(list1, list2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Rust杂记】读取CSV文件</title>
      <link href="/news/1678456159235.html"/>
      <url>/news/1678456159235.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-假设对以下nba-csv文件进行读取">1. 假设对以下<code>nba.csv</code>文件进行读取</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">姓名,团队,号码,职位,年龄,身高,体重,大学,薪水</span><br><span class="line">埃弗里·布拉德利,波士顿凯尔特人队,0.0,PG,25.0,6-2,180.0,Texas,7730337.0</span><br><span class="line">杰·克劳德,波士顿凯尔特人队,99.0,SF,25.0,6-6,235.0,马奎特,6796117.0</span><br><span class="line">约翰·霍兰,波士顿凯尔特人队,30.0,SG,27.0,6-5,205.0,波士顿大学,</span><br><span class="line">R.J. 亨特,波士顿凯尔特人队,28.0,SG,22.0,6-5,185.0,佐治亚州,1148640.0</span><br><span class="line">杰雷布科,波士顿凯尔特人队,8.0,大前锋,29.0,6-10,231.0,,5000000.0</span><br><span class="line">阿米尔约翰逊,波士顿凯尔特人队,90.0,大前锋,29.0,6-9,240.0,,12000000.0</span><br><span class="line">乔丹米奇,波士顿凯尔特人队,55.0,PF,21.0,6-8,235.0,LSU,1170960.0</span><br><span class="line">凯利奥利尼克,波士顿凯尔特人队,41.0,中锋,25.0,7-0,238.0,冈萨加,2165160.0</span><br></pre></td></tr></table></figure><ul><li>其对应的表格展示如下：<table><thead><tr><th>姓名</th><th>团队</th><th>号码</th><th>职位</th><th>年龄</th><th>身高</th><th>体重</th><th>大学</th><th>薪水</th></tr></thead><tbody><tr><td>埃弗里·布拉德利</td><td>波士顿凯尔特人队</td><td>0.0</td><td>PG</td><td>25.0</td><td>6-2</td><td>180.0</td><td>Texas</td><td>7730337.0</td></tr><tr><td>杰·克劳德</td><td>波士顿凯尔特人队</td><td>99.0</td><td>SF</td><td>25.0</td><td>6-6</td><td>235.0</td><td>马奎特</td><td>6796117.0</td></tr><tr><td>约翰·霍兰</td><td>波士顿凯尔特人队</td><td>30.0</td><td>SG</td><td>27.0</td><td>6-5</td><td>205.0</td><td>波士顿大学</td><td></td></tr><tr><td>R.J. 亨特</td><td>波士顿凯尔特人队</td><td>28.0</td><td>SG</td><td>22.0</td><td>6-5</td><td>185.0</td><td>佐治亚州</td><td>1148640.0</td></tr><tr><td>杰雷布科</td><td>波士顿凯尔特人队</td><td>8.0</td><td>大前锋</td><td>29.0</td><td>6-10</td><td>231.0</td><td></td><td>5000000.0</td></tr><tr><td>阿米尔约翰逊</td><td>波士顿凯尔特人队</td><td>90.0</td><td>大前锋</td><td>29.0</td><td>6-9</td><td>240.0</td><td></td><td>12000000.0</td></tr><tr><td>乔丹米奇</td><td>波士顿凯尔特人队</td><td>55.0</td><td>PF</td><td>21.0</td><td>6-8</td><td>235.0</td><td>LSU</td><td>1170960.0</td></tr><tr><td>凯利奥利尼克</td><td>波士顿凯尔特人队</td><td>41.0</td><td>中锋</td><td>25.0</td><td>7-0</td><td>238.0</td><td>冈萨加</td><td>2165160.0</td></tr></tbody></table></li></ul><h2 id="2-配置安装库CSV">2. 配置安装库<code>CSV</code></h2><ul><li>可直接在<code>Cargo.toml</code>文件中<code>dependencies</code>下方的添加<code>csv = &quot;1.1&quot;</code>，也可通过<code>cargo add csv</code>命令安装</li></ul><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">csv</span> = <span class="string">&quot;1.1&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-读取CSV文件">3. 读取<code>CSV</code>文件</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> csv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_from_file</span>(path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reader</span> = csv::Reader::<span class="title function_ invoke__">from_path</span>(path)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">result</span> <span class="keyword">in</span> reader.<span class="title function_ invoke__">records</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">record</span> = result?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, record);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="title function_ invoke__">read_from_file</span>(<span class="string">&quot;./nba.csv&quot;</span>) &#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-上述代码输出内容如下">4. 上述代码输出内容如下</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">StringRecord([<span class="string">&quot;埃弗里·布拉德利&quot;</span>, <span class="string">&quot;波士顿凯尔特人队&quot;</span>, <span class="string">&quot;0.0&quot;</span>, <span class="string">&quot;PG&quot;</span>, <span class="string">&quot;25.0&quot;</span>, <span class="string">&quot;6-2&quot;</span>, <span class="string">&quot;180.0&quot;</span>, <span class="string">&quot;Texas&quot;</span>, <span class="string">&quot;7730337.0&quot;</span>])</span><br><span class="line">StringRecord([<span class="string">&quot;杰·克劳德&quot;</span>, <span class="string">&quot;波士顿凯尔特人队&quot;</span>, <span class="string">&quot;99.0&quot;</span>, <span class="string">&quot;SF&quot;</span>, <span class="string">&quot;25.0&quot;</span>, <span class="string">&quot;6-6&quot;</span>, <span class="string">&quot;235.0&quot;</span>, <span class="string">&quot;马奎特&quot;</span>, <span class="string">&quot;6796117.0&quot;</span>])</span><br><span class="line">StringRecord([<span class="string">&quot;约翰·霍兰&quot;</span>, <span class="string">&quot;波士顿凯尔特人队&quot;</span>, <span class="string">&quot;30.0&quot;</span>, <span class="string">&quot;SG&quot;</span>, <span class="string">&quot;27.0&quot;</span>, <span class="string">&quot;6-5&quot;</span>, <span class="string">&quot;205.0&quot;</span>, <span class="string">&quot;波士顿大学&quot;</span>, <span class="string">&quot;&quot;</span>])</span><br><span class="line">StringRecord([<span class="string">&quot;R.J. 亨特&quot;</span>, <span class="string">&quot;波士顿凯尔特人队&quot;</span>, <span class="string">&quot;28.0&quot;</span>, <span class="string">&quot;SG&quot;</span>, <span class="string">&quot;22.0&quot;</span>, <span class="string">&quot;6-5&quot;</span>, <span class="string">&quot;185.0&quot;</span>, <span class="string">&quot;佐治亚州&quot;</span>, <span class="string">&quot;1148640.0&quot;</span>])</span><br><span class="line">StringRecord([<span class="string">&quot;杰雷布科&quot;</span>, <span class="string">&quot;波士顿凯尔特人队&quot;</span>, <span class="string">&quot;8.0&quot;</span>, <span class="string">&quot;大前锋&quot;</span>, <span class="string">&quot;29.0&quot;</span>, <span class="string">&quot;6-10&quot;</span>, <span class="string">&quot;231.0&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;5000000.0&quot;</span>])</span><br><span class="line">StringRecord([<span class="string">&quot;阿米尔约翰逊&quot;</span>, <span class="string">&quot;波士顿凯尔特人队&quot;</span>, <span class="string">&quot;90.0&quot;</span>, <span class="string">&quot;大前锋&quot;</span>, <span class="string">&quot;29.0&quot;</span>, <span class="string">&quot;6-9&quot;</span>, <span class="string">&quot;240.0&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;12000000.0&quot;</span>])</span><br><span class="line">StringRecord([<span class="string">&quot;乔丹米奇&quot;</span>, <span class="string">&quot;波士顿凯尔特人队&quot;</span>, <span class="string">&quot;55.0&quot;</span>, <span class="string">&quot;PF&quot;</span>, <span class="string">&quot;21.0&quot;</span>, <span class="string">&quot;6-8&quot;</span>, <span class="string">&quot;235.0&quot;</span>, <span class="string">&quot;LSU&quot;</span>, <span class="string">&quot;1170960.0&quot;</span>])</span><br><span class="line">StringRecord([<span class="string">&quot;凯利奥利尼克&quot;</span>, <span class="string">&quot;波士顿凯尔特人队&quot;</span>, <span class="string">&quot;41.0&quot;</span>, <span class="string">&quot;中锋&quot;</span>, <span class="string">&quot;25.0&quot;</span>, <span class="string">&quot;7-0&quot;</span>, <span class="string">&quot;238.0&quot;</span>, <span class="string">&quot;冈萨加&quot;</span>, <span class="string">&quot;2165160.0&quot;</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 锈浪宫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csv </tag>
            
            <tag> rust </tag>
            
            <tag> crates </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python杂记】RSA加密使用</title>
      <link href="/news/1678453890145.html"/>
      <url>/news/1678453890145.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装-pycryptodome">1. 安装 <code>pycryptodome</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure><h2 id="2-使用公钥加密">2. 使用公钥加密</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">password</span>):</span><br><span class="line">    publickey = <span class="string">&#x27;&#x27;&#x27;-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsgDq4OqxuEisnk2F0EJF</span></span><br><span class="line"><span class="string">mw4xKa5IrcqEYHvqxPs2CHEg2kolhfWA2SjNuGAHxyDDE5MLtOvzuXjBx/5YJtc9</span></span><br><span class="line"><span class="string">zj2xR/0moesS+Vi/xtG1tkVaTCba+TV+Y5C61iyr3FGqr+KOD4/XECu0Xky1W9Zm</span></span><br><span class="line"><span class="string">maFADmZi7+6gO9wjgVpU9aLcBcw/loHOeJrCqjp7pA98hRJRY+MML8MK15mnC4eb</span></span><br><span class="line"><span class="string">ooOva+mJlstW6t/1lghR8WNV8cocxgcHHuXBxgns2MlACQbSdJ8c6Z3RQeRZBzyj</span></span><br><span class="line"><span class="string">fey6JCCfbEKouVrWIUuPphBL3OANfgp0B+QG31bapvePTfXU48TYK0M5kE+8Lgbb</span></span><br><span class="line"><span class="string">WQIDAQAB</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----&#x27;&#x27;&#x27;</span></span><br><span class="line">    key = RSA.import_key(publickey)</span><br><span class="line">    passwd = PKCS1_v1_5.new(key)</span><br><span class="line">    pwd = base64.b64encode(passwd.encrypt(<span class="built_in">bytes</span>(password, encoding=<span class="string">&#x27;utf-8&#x27;</span>))).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> pwd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 盘蛇教 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> rsa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python杂记】合并多个 xml 文件</title>
      <link href="/news/1678265743246.html"/>
      <url>/news/1678265743246.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-假设需要对以下-3-个文件进行合并">1. 假设需要对以下 3 个文件进行合并</h2><ul><li><code>file1.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- file1.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;b&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;c&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>file2.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- file2.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item A<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;b&quot;</span>&gt;</span>Item B<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> <span class="attr">value</span>=<span class="string">&quot;c&quot;</span>&gt;</span>Item C<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item D<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>file3.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- file3.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subitem</span>&gt;</span>Subitem X<span class="tag">&lt;/<span class="name">subitem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;4&quot;</span> <span class="attr">value</span>=<span class="string">&quot;d&quot;</span>&gt;</span>Item P<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subitem</span>&gt;</span>Subitem Y<span class="tag">&lt;/<span class="name">subitem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-合并输出的预计结果保存在-output-xml-中">2. 合并输出的预计结果保存在 output.xml 中</h2><ul><li>合并条件是满足 <em><code>&#123;'id': '1','value':'a'&#125;</code></em> 的所有元素</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- output.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item A<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item D<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subitem</span>&gt;</span>Subitem X<span class="tag">&lt;/<span class="name">subitem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subitem</span>&gt;</span>Subitem Y<span class="tag">&lt;/<span class="name">subitem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-合并方式一（根节点简单的情况）">3. 合并方式一（根节点简单的情况）</h2><ul><li>合并的方法如<code>merge_xml_files_root</code>所示</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_xml_files_root</span>(<span class="params">xml_files,root_data,item,attribs, output_file</span>):</span><br><span class="line">    root = ET.Element(root_data)</span><br><span class="line">    <span class="keyword">for</span> xml_file <span class="keyword">in</span> xml_files:</span><br><span class="line">        subtree = ET.parse(xml_file)</span><br><span class="line">        subroot = subtree.getroot()</span><br><span class="line">        attrib = [<span class="string">f&quot;[@<span class="subst">&#123;k&#125;</span>=&#x27;<span class="subst">&#123;v&#125;</span>&#x27;]&quot;</span> <span class="keyword">for</span> k,v <span class="keyword">in</span> attribs.items()]</span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> subroot.findall(<span class="string">f&quot;./<span class="subst">&#123;item&#125;</span>/<span class="subst">&#123;<span class="string">&#x27;&#x27;</span>.join(attrib)&#125;</span>&quot;</span>):</span><br><span class="line">            root.append(elem)</span><br><span class="line">    tree = ET.ElementTree(root)</span><br><span class="line">    tree.write(output_file)</span><br><span class="line">    tree.write(output_file)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    xml_files = [<span class="string">&#x27;file1.xml&#x27;</span>,<span class="string">&#x27;file2.xml&#x27;</span>,<span class="string">&#x27;file3.xml&#x27;</span>]</span><br><span class="line">    attribs = &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;value&#x27;</span>:<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">    output_file = <span class="string">&#x27;output.xml&#x27;</span></span><br><span class="line">    item = <span class="string">&#x27;item&#x27;</span></span><br><span class="line">    root_data = <span class="string">&#x27;data&#x27;</span></span><br><span class="line">    merge_xml_files_root(xml_files,root_data,item,attribs,output_file)</span><br></pre></td></tr></table></figure><h2 id="4-合并方式二（根节点未知）">4. 合并方式二（根节点未知）</h2><ul><li>合并的方法如<code>merge_xml_files</code>所示</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_xml_files</span>(<span class="params">xml_files,item,attribs, output_file</span>):</span><br><span class="line">    tree = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> xml_file <span class="keyword">in</span> xml_files:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tree:</span><br><span class="line">            <span class="comment"># 使用第一个文件初始化tree</span></span><br><span class="line">            tree = ET.parse(xml_file)</span><br><span class="line">            root = tree.getroot()</span><br><span class="line">            <span class="keyword">for</span> elem <span class="keyword">in</span> root.findall(<span class="string">f&quot;./<span class="subst">&#123;item&#125;</span>&quot;</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">any</span>(elem.attrib.get(key)!=value <span class="keyword">for</span> key, value <span class="keyword">in</span> attribs.items()):</span><br><span class="line">                     <span class="comment"># 请除第一个文件中不符合的结点</span></span><br><span class="line">                    root.remove(elem)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        root = tree.getroot()</span><br><span class="line">        subtree = ET.parse(xml_file)</span><br><span class="line">        subroot = subtree.getroot()</span><br><span class="line">        attrib = [<span class="string">f&quot;[@<span class="subst">&#123;k&#125;</span>=&#x27;<span class="subst">&#123;v&#125;</span>&#x27;]&quot;</span> <span class="keyword">for</span> k,v <span class="keyword">in</span> attribs.items()]</span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> subroot.findall(<span class="string">f&quot;./<span class="subst">&#123;item&#125;</span>/<span class="subst">&#123;<span class="string">&#x27;&#x27;</span>.join(attrib)&#125;</span>&quot;</span>):</span><br><span class="line">            root.append(elem)</span><br><span class="line">    tree.write(output_file)</span><br></pre></td></tr></table></figure><ul><li>可通过以下方式调用</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    xml_files = [<span class="string">&#x27;file1.xml&#x27;</span>,<span class="string">&#x27;file2.xml&#x27;</span>,<span class="string">&#x27;file3.xml&#x27;</span>]</span><br><span class="line">    attribs = &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;value&#x27;</span>:<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">    output_file = <span class="string">&#x27;output.xml&#x27;</span></span><br><span class="line">    item = <span class="string">&#x27;item&#x27;</span></span><br><span class="line">    merge_xml_files(xml_files,item,attribs,output_file)</span><br></pre></td></tr></table></figure><h2 id="5-其他使用方式">5. 其他使用方式</h2><ul><li>如果传入的 <code>attribs = &#123;'id': '1'&#125;</code>，将会得到满足该条件的结果，如下：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- output.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;c&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item A<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;b&quot;</span>&gt;</span>Item B<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item D<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subitem</span>&gt;</span>Subitem X<span class="tag">&lt;/<span class="name">subitem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subitem</span>&gt;</span>Subitem Y<span class="tag">&lt;/<span class="name">subitem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-扩充部分">6. 扩充部分</h2><ul><li>合并方式二使用<code>any()</code>函数进行结点删除,此外还有<code>all()</code>函数。<code>any()</code> 和 <code>all()</code> 都是 Python 内置函数。<code>any()</code> 函数用于判断给定的可迭代参数<code>iterable</code> 是否全部为 <code>False</code>，则返回 <code>False</code>，如果有一个为 <code>True</code>，则返回 <code>True</code>。元素除了是 0、空、FALSE 外都算 TRUE。</li></ul><h3 id="6-1-any-函数">6.1 <code>any()</code>函数</h3><ul><li><code>any()</code> 函数接受一个可迭代对象作为参数，如果可迭代对象中的任意一个元素为真值，则返回 <code>True</code>，否则返回 <code>False</code>。例如：</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>([<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>])) <span class="comment"># 输出 True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>([<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>])) <span class="comment"># 输出 False</span></span><br></pre></td></tr></table></figure><ul><li>文中使用的</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">any</span>(elem.attrib.get(key)!=value <span class="keyword">for</span> key, value <span class="keyword">in</span> attribs.items()</span><br></pre></td></tr></table></figure><ul><li>等价于</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> elem.attrib.get(<span class="string">&#x27;id&#x27;</span>)!=<span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> elem.attrib.get(<span class="string">&#x27;value&#x27;</span>)!=<span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-all-函数">6.2 <code>all()</code>函数</h3><ul><li><code>all()</code>函数也接受一个可迭代对象作为参数，如果可迭代对象中的所有元素都为真值，则返回 <code>True</code>，否则返回 <code>False</code>。例如：</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>([<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>])) <span class="comment"># 输出 True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>])) <span class="comment"># 输出 False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 盘蛇教 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【如何百科】Ubuntu安装最新docker</title>
      <link href="/news/1678175207403.html"/>
      <url>/news/1678175207403.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-在线安装">1. 在线安装</h2><h3 id="使用存储库安装-前言">使用存储库安装(前言)</h3><p>  在新主机上首次安装 Docker Engine 之前，需要设置 Docker 存储库。之后，您可以从存储库中安装和更新 Docker。如无法使用 <code>root</code> 权限安装，可使用 <code>sudo</code> 来安装 docker。</p><h3 id="1-1-设置存储库">1.1 设置存储库</h3><h4 id="1-1-1-更新-apt-包索引并安装包以允许-apt-通过-HTTPS-使用存储库">1.1.1 更新 <code>apt</code> 包索引并安装包以允许 <code>apt</code> 通过 HTTPS 使用存储库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure><h4 id="1-1-2-添加-Docker-官方GPG密钥">1.1.2 添加 Docker 官方<code>GPG</code>密钥</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -m 0755 -p /etc/apt/keyrings</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure><h4 id="1-1-3-使用以下命令设置存储库">1.1.3 使用以下命令设置存储库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure><h3 id="1-2-安装-Docker-引擎">1.2 安装 Docker 引擎</h3><h4 id="1-2-1-更新-apt-包索引">1.2.1 更新 <code>apt</code> 包索引</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><h4 id="1-2-2-安装-Docker-引擎、容器和-Docker-Compose">1.2.2 安装 Docker 引擎、容器和 Docker Compose</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><h4 id="1-2-3-通过运行-hello-world-镜像来验证-Docker-引擎安装是否成功">1.2.3 通过运行 <code>hello-world</code> 镜像来验证 Docker 引擎安装是否成功</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h4 id="1-2-4-注意事项">1.2.4 注意事项</h4><p>  <strong>通过上述安装的 <code>docker-compose</code> 启动时命令是 <code>docker compose</code>，而不是 <code>docker-compose</code>，如下</strong>：</p><ul><li><strong>成功示例</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><ul><li><strong>错误示例</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h2 id="2-离线安装">2. 离线安装</h2><p>  Docker 是一种开源的容器技术，可以让开发者和运维人员在不同的平台上快速部署和运行应用程序。<code>Docker </code>的优点是轻量、高效、可移植和安全。但是，如果要在没有互联网连接的环境中安装 Docker，就需要一些额外的步骤。本文将介绍如何在 <code>Ubuntu 16.04 LTS</code> 上离线安装 Docker 和 <code>Docker-compose</code>。</p><h3 id="2-1-准备工作">2.1 准备工作</h3><p>  在开始离线安装之前，我们需要准备以下几个文件：</p><ul><li><code>containerd.io</code> 包：这是 Docker 的一个依赖包，负责管理容器的生命周期。</li><li><code>docker-ce-cli</code> 包：这是 Docker 的命令行接口，提供了各种操作容器的命令。</li><li><code>docker-ce</code> 包：这是 Docker 的核心组件，包含了 Docker 引擎和其他功能。</li><li><code>docker-compose</code> 包：这是一个用于定义和运行多容器应用程序的工具。</li></ul><p>  可以从以下地址下载这些包，注意选择与 <code>Ubuntu</code> 版本相匹配的包。例如，如果，其他版本代号如下：</p><table><thead><tr><th>版本</th><th>代号</th><th>地址</th></tr></thead><tbody><tr><td>16.04 LTS</td><td>xenial</td><td><a href="https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/">官方下载地址</a></td></tr><tr><td>18.04 LTS</td><td>bionic</td><td><a href="https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/">官方下载地址</a></td></tr><tr><td>20.04 LTS</td><td>focal</td><td><a href="https://download.docker.com/linux/ubuntu/dists/focal/pool/stable/amd64/">官方下载地址</a></td></tr><tr><td>22.04 LTS</td><td>jammy</td><td><a href="https://download.docker.com/linux/ubuntu/dists/jammy/pool/stable/amd64/">官方下载地址</a></td></tr></tbody></table><p>  我们使用的是 <code>Ubuntu 16.04 LTS</code>（代号为 <code>xenial</code>）需要下载以下三个包，其他版本可下载对应的四个最新包</p><ul><li>containerd.io_1.4.6-1_amd64.deb</li><li>docker-ce-cli_20.10.7_3-0_ubuntu-xenial_amd64.deb</li><li>docker-ce_20.10.7_3-0_ubuntu-xenial_amd64.deb</li><li>docker-compose-Linux-x86_64 (官方下载地址中仅 Ubuntu 18 版本以上存在 docker-compose-plugin*.deb)</li></ul><p>  下载完成后，我们需要将这些文件拷贝到目标机器上，例如放在 <code>/home/ubuntu/docker</code> 目录下。</p><h3 id="2-2-卸载原有的-Docker">2.2. 卸载原有的 Docker</h3><p>  如果目标机器上已经安装了旧版本的 Docker，那么我们需要先卸载它们，以避免冲突。我们可以使用以下命令来卸载原有的 Docker：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get purge docker-ce</span><br><span class="line">apt-get autoremove --purge docker-ce</span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure><h3 id="2-3-安装新版的-Docker">2.3 安装新版的 Docker</h3><p>  接下来，我们可以使用 <code>dpkg</code> 命令来安装新版的 Docker。注意要按照依赖顺序来安装包，即先安装 <code>containerd.io</code> 包，再安装 <code>docker-ce-cli</code> 包，最后安装 <code>docker-ce</code> 包。可以使用以下命令来进行安装：</p><h4 id="2-3-1-安装核心包">2.3.1 安装核心包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/ubuntu/docker <span class="comment"># 进入存放文件的目录</span></span><br><span class="line">dpkg -i containerd.io_1.4.6-1_amd64.deb <span class="comment"># 安装 containerd.io 包</span></span><br><span class="line">dpkg -i docker-ce-cli_20.10.7_3-0_ubuntu-xenial_amd64.deb <span class="comment"># 安装 docker-ce-cli 包</span></span><br><span class="line">dpkg -i docker-ce_20.10.7_3-0_ubuntu-xenial_amd64.deb <span class="comment"># 安装 docker-ce 包</span></span><br></pre></td></tr></table></figure><ul><li>注: 如果安装 <code>containerd.io</code>包时提示如下信息</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">containerd.io depends on libseccomp2(&gt;=2.4.0);however:</span><br><span class="line"> Version of libseccomp2:amd64 on system is 2.3.1-2-ubuntu2~16.04.1.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>则需要在该地址下载<code>libseccomp2(&gt;=2.4.0)</code>包，如<code>libseccomp2_2.4.3-1ubuntu1_amd64.deb</code> <a href="http://archive.ubuntu.com/ubuntu/pool/main/libs/libseccomp/">官方下载地址</a>。下载完成后，使用 <code>dpkg</code> 命令安装</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i libseccomp2_2.4.3-1ubuntu1_amd64.deb</span><br></pre></td></tr></table></figure><ul><li>安装完成后按照上述<code>docker</code>的安装顺序重新安装即可。</li></ul><h4 id="2-3-2-通过运行-docker-version-镜像来验证-Docker-引擎安装是否成功">2.3.2 通过运行 <code>docker --version</code> 镜像来验证 Docker 引擎安装是否成功</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker --version <span class="comment"># 查看 Docker 版本信息</span></span><br></pre></td></tr></table></figure><ul><li>如果能够看到类似如下的输出，则说明 Docker 已经正常工作：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Docker version 20.10.7, build f0df350</span><br></pre></td></tr></table></figure><h4 id="2-3-3-安装docker-compose-包【可选】">2.3.3 安装<code>docker-compose</code> 包【可选】</h4><p>  Ubuntu 18 版本以上安装<code>docker-compose</code> 包，下面以<code>Ubuntu 22.04 LTS</code>为例。Ubuntu 16 版本安装<code>docker-compose</code> 在后文进行描述。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i docker-compose-plugin_2.6.0~ubuntu-jammy_amd64.deb   <span class="comment"># 安装 docker-compose 包</span></span><br></pre></td></tr></table></figure><ul><li>验证 <code>docker-compose</code> 是否安装成功(注意如果安装的是最新版，则启动时命令是 <code>docker compose</code>，而不是 <code>docker-compose</code>)：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose --version</span><br></pre></td></tr></table></figure><h3 id="2-4-docker-compose-离线安装">2.4 docker-compose 离线安装</h3><p>  <code>Docker-compose </code>是一个用于定义和运行多容器 Docker 应用程序的工具。它使用 <code>YAML</code> 文件来配置应用程序的服务、网络和卷，然后使用一个命令来创建和启动所有的服务。在没有互联网连接的环境中，需要离线安装 <code>docker-compose</code>。下面介绍如何在 <code>Ubuntu 16.04 LTS</code> 上离线安装 <code>docker-compose</code> 的步骤。</p><h4 id="2-4-1-下载-docker-compose">2.4.1 下载 <code>docker-compose</code></h4><p>  在可以访问互联网的电脑上，打开浏览器，访问 <a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a> ，找到最新的稳定版本（本文以 2.16.0【2023 年 3 月最新版】为例），点击 Assets 下的 <code>docker-compose-Linux-x86_64</code> 链接，下载二进制文件。将下载好的文件复制到 U 盘或其他可移动存储设备上，然后插入到目标服务器上。</p><h4 id="2-4-2-安装-docker-compose">2.4.2 安装 <code>docker-compose</code></h4><ul><li>在目标服务器上，打开终端，切换到 <code>root</code> 用户：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -s</span><br></pre></td></tr></table></figure><ul><li>创建一个 <code>/usr/local/bin</code> 目录（如果不存在）：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/bin</span><br></pre></td></tr></table></figure><ul><li>将 U 盘或其他可移动存储设备上的 <code>docker-compose-Linux-x86_64</code> 文件复制到 <code>/usr/local/bin</code> 目录下，并重命名为 <code>docker-compose</code> ：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /media/usb/docker-compose-Linux-x86_64 /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><ul><li>给 <code>docker-compose</code> 文件添加可执行权限：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><ul><li>验证 <code>docker-compose</code> 是否安装成功：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><ul><li>如果输出类似如下内容，则表示安装成功：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose version 2.16.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 万法天书 </category>
          
          <category> 如何百科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python杂记】可用的翻译API及其调用方式</title>
      <link href="/news/1678175269378.html"/>
      <url>/news/1678175269378.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-谷歌翻译-API（需要设置代理）">1. 谷歌翻译 API（需要设置代理）</h2><p>  以翻译 <strong>“Authentication Architecture”</strong> 为例</p><h3 id="1-1-网页调用">1.1 网页调用</h3><h4 id="1-1-1-通过浏览器或命令行调用">1.1.1 通过浏览器或命令行调用</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">curl &quot;https://translate.google.com/translate_a/single?client=gtx&amp;dt=t&amp;dj=<span class="number">1</span>&amp;ie=UTF-<span class="number">8</span>&amp;sl=auto&amp;tl=zh_CN&amp;q=Authentication%<span class="number">20</span>Architecture&quot; -H &quot;Accept: application/json&quot; --proxy http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">7890</span></span><br></pre></td></tr></table></figure><h4 id="1-1-2-返回结果">1.1.2 返回结果</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sentences&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trans&quot;</span><span class="punctuation">:</span> <span class="string">&quot;认证架构&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;orig&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Authentication Architecture&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;backend&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;model_specification&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;translation_engine_debug_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;model_tracking&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;checkpoint_md5&quot;</span><span class="punctuation">:</span> <span class="string">&quot;95ad550c486923f3a292df3e4cffc30f&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;launch_doc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;en_zh_2022q2.md&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;en&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;confidence&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;spell&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ld_result&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;srclangs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;en&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;srclangs_confidences&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;extended_srclangs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;en&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-通过-python-调用">1.2 通过 python 调用</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">translate_from_google</span>(<span class="params">txt: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    proxies = &#123;</span><br><span class="line">        <span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://127.0.0.1:7890&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https&quot;</span>: <span class="string">&quot;http://127.0.0.1:7890&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    txt = urllib.parse.quote(txt, safe=<span class="string">&#x27; ,=&amp;/+()&#x27;</span>)</span><br><span class="line">    url = <span class="string">&#x27;https://translate.google.com/translate_a/single?client=gtx&amp;dt=t&amp;dj=1&amp;ie=UTF-8&amp;sl=auto&amp;tl=zh_CN&amp;q=&#x27;</span>+txt</span><br><span class="line">    res = requests.get(url=url, proxies=proxies)</span><br><span class="line">    <span class="keyword">return</span> res.json().get(<span class="string">&#x27;sentences&#x27;</span>)[<span class="number">0</span>].get(<span class="string">&#x27;trans&#x27;</span>)  <span class="comment"># 谷歌</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">translate_from_google(<span class="string">&#x27;Authentication Architecture&#x27;</span>) <span class="comment"># 调用</span></span><br><span class="line"><span class="comment"># 输出&quot;认证架构&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2-有道翻译-API">2. 有道翻译 API</h2><h3 id="2-1-网页调用">2.1 网页调用</h3><h4 id="2-1-1-通过浏览器或命令行调用">2.1.1 通过浏览器或命令行调用</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">curl &quot;https://fanyi.youdao.com/translate?doctype=json&amp;<span class="built_in">type</span>=EN2ZH_CN&amp;i=Authentication%<span class="number">20</span>Architecture&quot; -H &quot;Accept: application/json&quot;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-返回的-json-结果">2.1.2 返回的 json 结果</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;EN2ZH_CN&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;errorCode&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;elapsedTime&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;translateResult&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Authentication Architecture&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;tgt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;认证体系结构&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-通过-python-调用">2.2 通过 python 调用</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">translate_from_youdao</span>(<span class="params">txt:<span class="built_in">str</span></span>)-&gt;<span class="built_in">str</span>:</span><br><span class="line">    txt = urllib.parse.quote(txt, safe=<span class="string">&#x27; ,=&amp;/+()&#x27;</span>)</span><br><span class="line">    url = <span class="string">&#x27;https://fanyi.youdao.com/translate?&amp;doctype=json&amp;type=EN2ZH_CN&amp;i=&#x27;</span>+txt</span><br><span class="line">    res = requests.get(url=url,proxies=proxies)</span><br><span class="line">    <span class="keyword">return</span> res.json().get(<span class="string">&#x27;translateResult&#x27;</span>)[<span class="number">0</span>][<span class="number">0</span>].get(<span class="string">&#x27;tgt&#x27;</span>) <span class="comment"># 有道</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">translate_from_youdao(<span class="string">&#x27;Authentication Architecture&#x27;</span>) <span class="comment"># 调用</span></span><br><span class="line"><span class="comment"># 输出&quot;认证体系结构&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程大陆 </category>
          
          <category> 盘蛇教 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【如何百科】Linux (WSL) 子系统如何与Windows通信</title>
      <link href="/news/1677410190368.html"/>
      <url>/news/1677410190368.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-检查网络是否通畅">1. 检查网络是否通畅</h2><h3 id="1-1-通过ipconfig获得WSL的ip地址，如-172-28-30-1">1.1 通过<code>ipconfig</code>获得WSL的ip地址，如 <code>172.28.30.1</code></h3><h3 id="1-2-进入Linux子系统，ping上面这个地址">1.2 进入Linux子系统，<code>ping</code>上面这个地址</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping 172.28.30.1</span><br></pre></td></tr></table></figure><h3 id="1-3-如果无法ping通-或使用过程中发现网络不通-，则可在Windows系统上通过powershell（管理员启动）运行如下命令，开启Linux-WSL-子系统访问Windows的防火墙">1.3 如果无法<code>ping</code>通(或使用过程中发现网络不通)，则可在Windows系统上通过<code>powershell</code>（管理员启动）运行如下命令，开启Linux (WSL) 子系统访问Windows的防火墙</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">New-NetFirewallRule</span> <span class="literal">-DisplayName</span> <span class="string">&quot;WSL&quot;</span> <span class="literal">-Direction</span> Inbound  <span class="literal">-InterfaceAlias</span> <span class="string">&quot;vEthernet (WSL)&quot;</span>  <span class="literal">-Action</span> Allow</span><br></pre></td></tr></table></figure><h2 id="2-获取WSL自动配置的域名">2. 获取WSL自动配置的域名</h2><h3 id="方法1">方法1</h3><ul><li>直接打开以下文件(可记事本打开或命令行查看)，寻找172.28.30.1对应的域名</li></ul><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> C:\Windows\System32\drivers\etc\hosts.ics</span><br></pre></td></tr></table></figure><h3 id="方法2">方法2</h3><ul><li>通过Linux子系统tracepath任意地址，如</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracepath baidu.com</span><br></pre></td></tr></table></figure><ul><li>则此时域名为命令执行结果中前两行出现的域名</li></ul><h3 id="结果">结果</h3><ul><li>可以发现域名是 <code>example.mshome.net</code> 的形式，<code>example</code>一般为Windows及Linux子系统的主机名。比如，主机名为<code>taissan</code>，那么域名则是 <code>taissan.mshome.net</code>。</li></ul><h2 id="3-Linux子系统访问Windows上的服务">3. Linux子系统访问Windows上的服务</h2><ul><li>Linux子系统访问Windows上的代理</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://taissan.mshome.net:7890</span><br></pre></td></tr></table></figure><h2 id="4-Windows访问Linux子系统上的服务">4. Windows访问Linux子系统上的服务</h2><ul><li>直接访问<code>localhost</code>+端口即可，如</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:8080</span><br></pre></td></tr></table></figure><h2 id="5-使用域名访问解决的问题">5. 使用域名访问解决的问题</h2><ul><li>配置域名访问后，后续无需再做配置。防止因电脑重启后wsl的IP变化，使得需要每次重新在Linux子系统中配置IP.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 万法天书 </category>
          
          <category> 如何百科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wsl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【杂记】测试Katex的公式支持程度</title>
      <link href="/news/1678109183215.html"/>
      <url>/news/1678109183215.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-测试代数（不支持双层大括号）">1. 测试代数（不支持双层大括号）</h2><ul><li>式子一</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>对于方程形如：</mtext><msup><mi>x</mi><mn>3</mn></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>设:</mtext><mi>ω</mi><mo>=</mo><mfrac><mrow><mo>−</mo><mn>1</mn><mo>+</mo><msqrt><mn>3</mn></msqrt><mi>i</mi></mrow><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>=</mo><mi>ω</mi><mo>=</mo><mfrac><mrow><mo>−</mo><mn>1</mn><mo>+</mo><msqrt><mn>3</mn></msqrt><mi>i</mi></mrow><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mn>3</mn></msub><mo>=</mo><msup><mi>ω</mi><mn>2</mn></msup><mo>=</mo><mfrac><mrow><mo>−</mo><mn>1</mn><mo>−</mo><msqrt><mn>3</mn></msqrt><mi>i</mi></mrow><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}  \text{对于方程形如：}x^{3}-1=0 \\  \text{设}\text{:}\omega =\frac{-1+\sqrt{3}i}{2} \\  x_{1}=1,x_{2}= \omega =\frac{-1+\sqrt{3}i}{2} \\  x_{3}= \omega ^{2}=\frac{-1-\sqrt{3}i}{2}\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.394em;vertical-align:-2.447em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.947em;"><span style="top:-5.145em;"><span class="pstrut" style="height:3.038em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">对于方程形如：</span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-3.747em;"><span class="pstrut" style="height:3.038em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">设</span></span><span class="mord text"><span class="mord">:</span></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.038em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.399em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9128em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">3</span></span></span><span style="top:-2.8728em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1272em;"><span></span></span></span></span></span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.349em;"><span class="pstrut" style="height:3.038em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.038em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.399em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9128em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">3</span></span></span><span style="top:-2.8728em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1272em;"><span></span></span></span></span></span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-0.951em;"><span class="pstrut" style="height:3.038em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.038em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.399em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9128em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">3</span></span></span><span style="top:-2.8728em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1272em;"><span></span></span></span></span></span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.447em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><ul><li>式子二</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><msup><mo><mi>x</mi></mo><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>x</mi><mo>+</mo><mi>c</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><mo>=</mo><msup><mo><mi>b</mi></mo><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><mo>=</mo><msup><mo><mi>b</mi></mo><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo><mi>x</mi></mo><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn></mrow></msub><mo>=</mo><mfrac><mrow><mo>−</mo><mi>b</mi><mo>±</mo><msqrt><mrow><msup><mo><mi>b</mi></mo><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo><mi>x</mi></mo><mn>1</mn></msub><mo>+</mo><msub><mo><mi>x</mi></mo><mn>2</mn></msub><mo>=</mo><mo>−</mo><mfrac><mi>b</mi><mi>a</mi></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mo><mi>x</mi></mo><mn>1</mn></msub><msub><mo><mi>x</mi></mo><mn>2</mn></msub><mo>=</mo><mfrac><mi>c</mi><mi>a</mi></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}  a\mathop{x}\nolimits^{2}+bx+c=0 \\  \Delta =\mathop{b}\nolimits^{2}-4ac \\  \Delta =\mathop{b}\nolimits^{2}-4ac \\  \mathop{x}\nolimits_{1,2}=\frac{-b\pm \sqrt{\mathop{b}\nolimits^{2}-4ac}}{2a} \\  \mathop{x}\nolimits_{1}+\mathop{x}\nolimits_{2}=-\frac{b}{a} \\  \mathop{x}\nolimits_{1}\mathop{x}\nolimits_{2}=\frac{c}{a}\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.5759em;vertical-align:-3.538em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.038em;"><span style="top:-6.2569em;"><span class="pstrut" style="height:3.0589em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop mathnormal" style="position:relative;top:-0.0347em;">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord mathnormal">b</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-4.9985em;"><span class="pstrut" style="height:3.0589em;"></span><span class="mord"><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop"><span class="mop mathnormal" style="position:relative;top:0.0972em;">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984em;"><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">4</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3.0589em;"></span><span class="mord"><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop"><span class="mop mathnormal" style="position:relative;top:0.0972em;">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984em;"><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">4</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span></span></span><span style="top:-2.3211em;"><span class="pstrut" style="height:3.0589em;"></span><span class="mord"><span class="mop"><span class="mop mathnormal" style="position:relative;top:-0.0347em;">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0589em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">b</span><span class="mbin mtight">±</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9499em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mop mtight"><span class="mop mathnormal mtight" style="position:relative;top:0.0972em;">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-2.8416em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight">−</span><span class="mord mtight">4</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span></span></span><span style="top:-2.9099em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.0901em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.081em;"><span class="pstrut" style="height:3.0589em;"></span><span class="mord"><span class="mop"><span class="mop mathnormal" style="position:relative;top:-0.0347em;">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop mathnormal" style="position:relative;top:-0.0347em;">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:0.119em;"><span class="pstrut" style="height:3.0589em;"></span><span class="mord"><span class="mop"><span class="mop mathnormal" style="position:relative;top:-0.0347em;">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop mathnormal" style="position:relative;top:-0.0347em;">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.538em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><ul><li>注：使用<mark class="hl-label blue">latex(katex)</mark> 时应使用<code>a\mathop&#123;x&#125;\nolimits^&#123;2&#125;+bx+c=0</code>，而不是<code>a\mathop&#123;&#123;x&#125;&#125;\nolimits^&#123;&#123;2&#125;&#125;+bx+c=0</code></li><li>即使用<mark class="hl-label green">单层</mark> 大括号<code>&#123;x&#125;</code>包裹参数，而不是<mark class="hl-label red">双层</mark> 大括号<code>&#123;&#123;x&#125;&#125;</code>包裹参数。</li></ul><h2 id="2-测试几何">2. 测试几何</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mo>⊂</mo><mi>α</mi><mo separator="true">,</mo><mi>n</mi><mo>⊂</mo><mi>α</mi><mo separator="true">,</mo><mi>m</mi><mo>∩</mo><mi>n</mi><mo>=</mo><mi>P</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>⊥</mo><mi>m</mi><mo separator="true">,</mo><mi>a</mi><mo>⊥</mo><mi>n</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">}</mo></mrow><mo>⇒</mo><mi>a</mi><mo>⊥</mo><mi>α</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\left.\begin{matrix}  m \subset \alpha ,n \subset \alpha ,m \cap n=P \\    a \perp m,a \perp n\end{matrix}\right\}\Rightarrow a \perp \alpha\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">}</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><h2 id="3-测试不等式">3. 测试不等式</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mrow><mo fence="true">(</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mi>k</mi></msub><msub><mi>b</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow><mrow><mtext> ⁣</mtext><mtext> ⁣</mtext><mn>2</mn></mrow></msup><mo>≤</mo><mrow><mo fence="true">(</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msubsup><mi>a</mi><mi>k</mi><mn>2</mn></msubsup><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msubsup><mi>b</mi><mi>k</mi><mn>2</mn></msubsup><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\left( \sum_{k=1}^n a_k b_k \right)^{\!\!2}\leq\left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3683em;vertical-align:-0.4341em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9342em;"><span style="top:-2.9342em;"><span class="pstrut" style="height:3.0083em;"></span><span class="mord"><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0083em;"><span style="top:-3.2572em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-0.1952em;"></span><span class="mspace mtight" style="margin-right:-0.1952em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4169em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4169em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4341em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><h2 id="4-测试积分">4. 测试积分</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><mover accent="true"><mi>f</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>ξ</mi><mtext> </mtext><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mi>ξ</mi><mi>x</mi></mrow></msup><mtext> </mtext><mi mathvariant="normal">d</mi><mi>ξ</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}f(x) = \int_{-\infty}^\infty  \hat f(x)\xi\,e^{2 \pi i \xi x}  \,\mathrm{d}\xi\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.372em;vertical-align:-0.436em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span style="top:-2.9781em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8593em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4142em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.0833em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.04601em;">ξ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">πi</span><span class="mord mathnormal mtight" style="margin-right:0.04601em;">ξ</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.04601em;">ξ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.436em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><h2 id="5-测试矩阵">5. 测试矩阵</h2><ul><li>矩阵一</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>A</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>11</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>12</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>21</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>22</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>m</mi><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>m</mi><mn>2</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>m</mi><mi>n</mi></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo fence="true">]</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}A_{m\times n}=  \begin{bmatrix}    a_{11}&amp; a_{12}&amp; \cdots  &amp; a_{1n} \\    a_{21}&amp; a_{22}&amp; \cdots  &amp; a_{2n} \\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    a_{m1}&amp; a_{m2}&amp; \cdots  &amp; a_{mn}  \end{bmatrix}  =\left [ a_{ij}\right ]\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-4.98em;"><span class="pstrut" style="height:4.98em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='5.400em' viewBox='0 0 667 5400'><path d='M403 1759 V84 H666 V0 H319 V1759 v1800 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v1800 v1759 h84z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">21</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.64em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.44em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.58em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.38em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">mn</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.667em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='5.400em' viewBox='0 0 667 5400'><path d='M347 1759 V0 H0 V84 H263 V1759 v1800 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v1800 v1759 h84z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><ul><li>矩阵二</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>A</mi><mo>=</mo><msub><mrow><mo fence="true">[</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo fence="true">]</mo></mrow><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msub><mo separator="true">,</mo><mi>B</mi><mo>=</mo><msub><mrow><mo fence="true">[</mo><msub><mi>b</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo fence="true">]</mo></mrow><mrow><mi>n</mi><mo>×</mo><mi>s</mi></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>c</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><msub><mi>b</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>C</mi><mo>=</mo><mi>A</mi><mi>B</mi><mo>=</mo><msub><mrow><mo fence="true">[</mo><msub><mi>c</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo fence="true">]</mo></mrow><mrow><mi>m</mi><mo>×</mo><mi>s</mi></mrow></msub><mo>=</mo><msub><mrow><mo fence="true">[</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><msub><mi>b</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo fence="true">]</mo></mrow><mrow><mi>m</mi><mo>×</mo><mi>s</mi></mrow></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{c}  A={\left[ a_{ij}\right]_{m \times n}},B={\left[ b_{ij}\right]_{n \times s}} \\    c_{ij}= \sum \limits_{k=1}^{n}a_{ik}b_{kj} \\    C=AB=\left[ c_{ij}\right]_{m \times s}    = \left[ \sum \limits_{k=1}^{n}a_{ik}b_{kj}\right]_{m \times s}\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.1478em;vertical-align:-2.8239em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.3239em;"><span style="top:-5.9339em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0725em;"><span style="top:-2.3642em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3941em;"><span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0725em;"><span style="top:-2.3642em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3941em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-4.1884em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3514em;"><span style="top:-2.0979em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">kj</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.7362em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0725em;"><span style="top:-2.3642em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3941em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3514em;"><span style="top:-2.0979em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">kj</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.6435em;"><span style="top:-1.6482em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1101em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.8239em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><h2 id="6-测试三角">6. 测试三角</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>α</mi><mo>+</mo><mi>sin</mi><mo>⁡</mo><mi>β</mi><mo>=</mo><mn>2</mn><mi>sin</mi><mo>⁡</mo><mfrac><mrow><mi>α</mi><mo>+</mo><mi>β</mi></mrow><mn>2</mn></mfrac><mi>cos</mi><mo>⁡</mo><mfrac><mrow><mi>α</mi><mo>−</mo><mi>β</mi></mrow><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\sin \alpha + \sin \beta =2 \sin \frac{\alpha + \beta}{2}\cos \frac{\alpha - \beta}{2}\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2922em;vertical-align:-0.3961em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8961em;"><span style="top:-2.9639em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3961em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><h2 id="7-测试统计">7. 测试统计</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>S</mi><mo>=</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>N</mi><mi>n</mi></mfrac><mo fence="true">)</mo></mrow><mo separator="true">,</mo><msub><mi>A</mi><mi>k</mi></msub><mo>=</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>M</mi><mi>k</mi></mfrac><mo fence="true">)</mo></mrow><mo>⋅</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>N</mi><mo>−</mo><mi>M</mi></mrow><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow></mfrac><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><mfrac><mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>M</mi><mi>k</mi></mfrac><mo fence="true">)</mo></mrow><mo>⋅</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>N</mi><mo>−</mo><mi>M</mi></mrow><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>N</mi><mi>n</mi></mfrac><mo fence="true">)</mo></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{c}  S= \binom{N}{n},A_{k}=\binom{M}{k}\cdot \binom{N-M}{n-k} \\  P\left ( A_{k}\right ) = \frac{\binom{M}{k}\cdot \binom{N-M}{n-k}}{\binom{N}{n}}\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.8457em;vertical-align:-1.6728em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.1728em;"><span style="top:-4.7605em;"><span class="pstrut" style="height:3.51em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9223em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9223em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9223em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span><span style="top:-2.8472em;"><span class="pstrut" style="height:3.51em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.51em;"><span style="top:-2.3925em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="delimsizing size1 mtight"><span class="mtight">(</span></span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9591em;"><span style="top:-2.156em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-2.971em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="delimsizing size1 mtight"><span class="mtight">)</span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7125em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="delimsizing size1 mtight"><span class="mtight">(</span></span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9591em;"><span style="top:-2.156em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-2.971em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="delimsizing size1 mtight"><span class="mtight">)</span></span></span></span><span class="mbin mtight">⋅</span><span class="mord mtight"><span class="mopen sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="delimsizing size1 mtight"><span class="mtight">(</span></span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9591em;"><span style="top:-2.156em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-2.971em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4035em;"><span></span></span></span></span></span><span class="mclose sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="delimsizing size1 mtight"><span class="mtight">)</span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.6728em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>P</mi><mrow><mo fence="true">(</mo><msubsup><mo>⋃</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>A</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}P \left( \bigcup \limits_{i=1}^{n}A_{i}\right) = \prod \limits_{i=1}^{n}P \left( A_{i}\right)\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4277em;vertical-align:-0.9638em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4638em;"><span style="top:-3.4638em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3514em;"><span style="top:-2.1223em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">⋃</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3514em;"><span style="top:-2.1223em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∏</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9638em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><h2 id="8-测试数列">8. 测试数列</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>n</mi><mrow><mo fence="true">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mrow><mo fence="true">)</mo><mo>⋅</mo><msup><mn>2</mn><mi>n</mi></msup></mrow></mrow></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mo fence="true">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mrow><mo fence="true">)</mo><mo>⋅</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></mrow></mfrac><mo>−</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>⋅</mo><msup><mn>2</mn><mi>n</mi></msup></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\frac{n+1}{n \left( n-1 \left) \cdot 2^{n}\right. \right.}= \frac{1}{\left( n-1 \left) \cdot 2^{n-1}\right. \right.}-\frac{1}{n \cdot 2^{n}}\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3651em;vertical-align:-0.4326em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9326em;"><span style="top:-3.0874em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">(</span></span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">)</span></span><span class="mord mtight">⋅</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">(</span></span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">)</span></span><span class="mord mtight">⋅</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">⋅</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4326em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><msup><mo stretchy="false">)</mo><mi>n</mi></msup><mo>=</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mi>n</mi><mi>x</mi></mrow><mrow><mn>1</mn><mo stretchy="false">!</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><mrow><mn>2</mn><mo stretchy="false">!</mo></mrow></mfrac><mo>+</mo><mo>⋯</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}(1+x)^{n} =1 + \frac{nx}{1!} + \frac{n(n-1)x^{2}}{2!} + \cdots\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4689em;vertical-align:-0.4845em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9845em;"><span style="top:-2.9845em;"><span class="pstrut" style="height:3.1089em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mclose mtight">!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1089em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mclose mtight">!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4845em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><h2 id="9-测试物理-不支持unicode扩展">9. 测试物理(不支持unicode扩展)</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mstyle mathsize="2.074em"><mo>∯</mo></mstyle><mi mathvariant="double-struck">S</mi></msub><mi mathvariant="bold">D</mi><mo>⋅</mo><mi mathvariant="normal">d</mi><mi>s</mi><mo>=</mo><msub><mi>Q</mi><mi>f</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mstyle mathsize="2.074em"><mo>∯</mo></mstyle><mi mathvariant="double-struck">S</mi></msub><mi mathvariant="bold">B</mi><mo>⋅</mo><mi mathvariant="normal">d</mi><mi>s</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mstyle mathsize="2.074em"><mo>∮</mo></mstyle><mi mathvariant="double-struck">L</mi><mrow></mrow></msubsup><mi mathvariant="bold">E</mi><mo>⋅</mo><mi mathvariant="normal">d</mi><mi>l</mi><mo>=</mo><mo>−</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mi mathvariant="normal">d</mi><msub><mi mathvariant="normal">Φ</mi><mi mathvariant="bold">B</mi></msub></mrow><mrow><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mfrac></mstyle></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mstyle mathsize="2.074em"><mo>∮</mo></mstyle><mi mathvariant="double-struck">L</mi><mrow></mrow></msubsup><mi mathvariant="bold">H</mi><mo>⋅</mo><mi mathvariant="normal">d</mi><mi>l</mi><mo>=</mo><msub><mi>I</mi><mi>f</mi></msub><mo>+</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mi mathvariant="normal">d</mi><msub><mi mathvariant="normal">Φ</mi><mi mathvariant="bold">D</mi></msub></mrow><mrow><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mfrac></mstyle></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">%此公式需要在设置中开启unicode扩展支持\begin{array}{l}    {\huge \oiint}_\mathbb{S}  \mathbf{D} \cdot\mathrm{d}s= Q_f \\    {\huge \oiint}_\mathbb{S}  \mathbf{B} \cdot\mathrm{d}s= 0 \\    {\huge \oint}_{\mathbb{L}}^{} \mathbf{E} \cdot \mathrm{d}l=-\cfrac{\mathrm{d}\Phi _{\mathbf{B}}}{\mathrm{d}t }  \\    {\huge \oint}_{\mathbb{L}}^{} \mathbf{H} \cdot \mathrm{d}l=I_f+\cfrac{\mathrm{d}\Phi _{\mathbf{D}}}{\mathrm{d}t }\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:9.419em;vertical-align:-4.4595em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.9595em;"><span style="top:-7.3639em;"><span class="pstrut" style="height:4.074em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mop vlist-t vlist-t2 sizing reset-size6 size10" style="position:relative;top:-0.0005em;"><span class="vlist-r"><span class="vlist" style="height:0.805em;"><span style="top:-4.074em;"><span class="pstrut" style="height:4.074em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;">∬</span></span><span style="top:-4.074em;"><span class="pstrut" style="height:4.074em;"></span><span class="overlay" style="height:0.499em;width:0.957em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.957em' height='0.499em' style='width:0.957em' viewBox='0 0 957 499' preserveAspectRatio='xMinYMin'><path d='M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2zm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.860.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.306em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.2021em;"><span style="top:-2.0157em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbb mtight">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6843em;"><span></span></span></span></span></span></span><span class="mord mathbf">D</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-5.01em;"><span class="pstrut" style="height:4.074em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mop vlist-t vlist-t2 sizing reset-size6 size10" style="position:relative;top:-0.0005em;"><span class="vlist-r"><span class="vlist" style="height:0.805em;"><span style="top:-4.074em;"><span class="pstrut" style="height:4.074em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;">∬</span></span><span style="top:-4.074em;"><span class="pstrut" style="height:4.074em;"></span><span class="overlay" style="height:0.499em;width:0.957em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.957em' height='0.499em' style='width:0.957em' viewBox='0 0 957 499' preserveAspectRatio='xMinYMin'><path d='M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2zm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.860.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.306em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.2021em;"><span style="top:-2.0157em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbb mtight">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6843em;"><span></span></span></span></span></span></span><span class="mord mathbf">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-2.6561em;"><span class="pstrut" style="height:4.074em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mop op-symbol small-op sizing reset-size6 size10" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∮</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4225em;"><span style="top:-2.0154em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbb mtight">L</span></span></span></span><span style="top:-4.1225em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6846em;"><span></span></span></span></span></span></span><span class="mord mathbf">E</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.59em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3303em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span></span></span><span style="top:-0.3005em;"><span class="pstrut" style="height:4.074em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mop op-symbol small-op sizing reset-size6 size10" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∮</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4225em;"><span style="top:-2.0154em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbb mtight">L</span></span></span></span><span style="top:-4.1225em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6846em;"><span></span></span></span></span></span></span><span class="mord mathbf">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.59em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3303em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.4595em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><h2 id="10-测试化学-不支持mhchem扩展">10. 测试化学(不支持mhchem扩展)</h2><ul><li>源latex代码如下:</li></ul><p>\begin{array}{l}\ce{Zn^2+  <=>[+ 2OH-][+ 2H+]  $\underset{\text{amphoteres Hydroxid}}{\ce{Zn(OH)2 v}}$  <=>[+ 2OH-][+ 2H+]  $\underset{\text{Hydroxozikat}}{\ce{[Zn(OH)4]^2-}}$}\end{array}</p><ul><li><a href="https://www.latexlive.com">公式模板来源</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 混元圣记 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> katex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【杂记】使用Github访问Google</title>
      <link href="/news/1677410182753.html"/>
      <url>/news/1677410182753.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-任意仓库打开Codespaces">1. 任意仓库打开<code>Codespaces</code></h2><h2 id="2-打开Codespaces的终端（页面类似于vscode）">2. 打开<code>Codespaces</code>的终端（页面类似于<code>vscode</code>）</h2><h2 id="3-运行如下命令">3. 运行如下命令</h2><h3 id="3-1-切换到root权限">3.1 切换到<code>root</code>权限</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -s</span><br></pre></td></tr></table></figure><h3 id="3-2-运行docker应用">3.2 运行<code>docker</code>应用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 6080:80 -v /dev/shm:/dev/shm dorowu/ubuntu-desktop-lxde-vnc</span><br></pre></td></tr></table></figure><h2 id="4-新窗口打开弹出的网页">4. 新窗口打开弹出的网页</h2><h2 id="5-在新的页面中打开firefox浏览器（其他浏览器貌似无法使用），即可使用">5. 在新的页面中打开<code>firefox</code>浏览器（其他浏览器貌似无法使用），即可使用</h2>]]></content>
      
      
      <categories>
          
          <category> 混元圣记 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CVE-2021-42694】Trojan Source木马源攻击</title>
      <link href="/news/1677410067156.html"/>
      <url>/news/1677410067156.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-RLO-LRI-ΓC«Γuª-和-PDI-LRI-Γu⌐Γuª-使用">1. <code>RLO LRI('ΓÇ«Γüª')</code> 和 <code>PDI LRI('Γü⌐Γüª')</code> 使用</h2><h3 id="1-1-使用DOS-CP437-编码">1.1 使用<code>DOS(CP437)</code>编码</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">access_level = <span class="string">&quot;user&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> access_level != <span class="string">&#x27;noneΓÇ«Γüª&#x27;</span>: <span class="comment"># Check if admin Γü⌐Γüª&#x27; and access_level != &#x27;user</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You are an admin.&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-2-使用utf-8-编码转换后（vscode：-Reopen-with-Encoding）">1.2 使用<code>utf-8</code> 编码转换后（vscode： Reopen with Encoding）</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">access_level = <span class="string">&quot;user&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> access_level != <span class="string">&#x27;none‮⁦&#x27;</span>: <span class="comment"># Check if admin ⁩⁦&#x27; and access_level != &#x27;user</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You are an admin.&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-RLI使用-Γuº">2. RLI使用<code>('Γüº')</code></h2><h3 id="2-1-使用DOS-CP437-编码">2.1 使用<code>DOS(CP437)</code>编码</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">bank = &#123; <span class="string">&#x27;alice&#x27;</span>: <span class="number">100</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subtract_funds</span>(<span class="params">account: <span class="built_in">str</span>, amount: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Subtract funds from bank account then Γüº&#x27;&#x27;&#x27;</span> ;<span class="keyword">return</span></span><br><span class="line">    bank[account] -= amount</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">subtract_funds(<span class="string">&#x27;alice&#x27;</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(bank)</span><br></pre></td></tr></table></figure><h3 id="2-2-使用utf-8-编码转换后">2.2 使用<code>utf-8</code> 编码转换后</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">bank = &#123; <span class="string">&#x27;alice&#x27;</span>: <span class="number">100</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subtract_funds</span>(<span class="params">account: <span class="built_in">str</span>, amount: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Subtract funds from bank account then ⁧&#x27;&#x27;&#x27;</span> ;<span class="keyword">return</span></span><br><span class="line">    bank[account] -= amount</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">subtract_funds(<span class="string">&#x27;alice&#x27;</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(bank)</span><br></pre></td></tr></table></figure><h2 id="3-╨¥-西里尔字母H-使用">3. <code>'╨¥'</code>(西里尔字母H)使用</h2><h3 id="3-1-使用DOS-CP437-编码">3.1 使用<code>DOS(CP437)</code>编码</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>╨¥ello():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Goodbye, World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sayHello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say╨¥ello()</span><br></pre></td></tr></table></figure><h3 id="3-2-使用utf-8-编码转换后-╨¥-变为类似H的字符">3.2 使用<code>utf-8</code> 编码转换后 <code>╨¥</code> 变为类似<code>H</code>的字符</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sayНello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Goodbye, World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sayHello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line"></span><br><span class="line">sayНello()</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><table><thead><tr><th>Abbreviation</th><th>Code Point</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>LRE</td><td>U+202A</td><td>Left-to-Right Embedding</td><td>尝试将以下文本视为从左到右</td></tr><tr><td>RLE</td><td>U+202B</td><td>Right-to-Left Embedding</td><td>尝试将以下文本视为从右到左</td></tr><tr><td>LRO</td><td>U+202D</td><td>Left-to-Right Override</td><td>强制将以下文本视为从左到右</td></tr><tr><td>RLO</td><td>U+202E</td><td>Right-to-Left Override</td><td>强制将以下文本视为从右到左</td></tr><tr><td>LRI</td><td>U+2066</td><td>Left-to-Right Isolate</td><td>强制将后续文本视为从左到右，而不影响相邻文本</td></tr><tr><td>RLI</td><td>U+2067</td><td>Right-to-Left Isolate</td><td>强制将后续文本视为从右到左，而不影响相邻文本</td></tr><tr><td>FSI</td><td>U+2068</td><td>First Strong Isolate</td><td>强制按照下一个字符指示的方向处理后续文本</td></tr><tr><td>PDF</td><td>U+202C</td><td>Pop Directional Formatting</td><td>终止最近的 LRE.RLE.LRO 或 RLO</td></tr><tr><td>PDI</td><td>U+2069</td><td>Pop Directional Isolate</td><td>终止最近的 LRI 或 RLI</td></tr></tbody></table><p><a href="https://trojansource.codes/trojan-source.pdf">trojan-source论文</a></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【如何百科】pip 离线安装第三方库及依赖</title>
      <link href="/news/1677407864745.html"/>
      <url>/news/1677407864745.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-已安装的模块名称导出到文件">1. 已安装的模块名称导出到文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip freeze &gt;requirements.txt </span><br></pre></td></tr></table></figure><h2 id="2-在线下载依赖">2. 在线下载依赖</h2><h3 id="2-1-直接下载对应包">2.1 直接下载对应包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip download -d D:\python\pip\package mitmproxy</span><br></pre></td></tr></table></figure><h3 id="2-2-通过requirements-txt直接下载对应包">2.2 通过requirements.txt直接下载对应包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip download -d D:\python\pip\package -r requirements.txt </span><br></pre></td></tr></table></figure><h2 id="3-将在线下载的包复制到离线电脑上">3. 将在线下载的包复制到离线电脑上</h2><ul><li>本文中从在线电脑上的路径<code>D:\python\pip\package</code> 下的包拷贝到离线电脑的<code>E:\python\pip\package</code>路径下</li></ul><h2 id="4-在离线电脑上安装已导出的模块，指定模块名称或指定包含所有模块列表的文件">4. 在离线电脑上安装已导出的模块，指定模块名称或指定包含所有模块列表的文件</h2><h3 id="4-1-直接安装对应包">4.1 直接安装对应包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install --no-index --find-links=E:\python\pip\package -r requirements</span><br></pre></td></tr></table></figure><h3 id="4-2-通过requirements-txt直接安装对应包">4.2 通过<code>requirements.txt</code>直接安装对应包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install --no-index --find-links=E:\python\pip\package mitmproxy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 万法天书 </category>
          
          <category> 如何百科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
